#ifndef _PROPERTIES_HPP_
#define _PROPERTIES_HPP_

/*
 * properties.hpp
 * 
 * Defines generic properties that drive the synthesis.
 * Among them, the output folder and filename where Hyper-NF
 * will generate the results, whether Hyper-NF will produce a 
 * pure software or a hardware assisted synthesis. If the latter
 * is selected, the number of CPU sockets, cores, NIC hardware 
 * queues the type of CPU architecture are requested.
 *
 * Copyright (c) 2015-2016 KTH Royal Institute of Technology
 * Copyright (c) 2015-2016 Georgios Katsikas, Marcel Enguehard
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#include <unordered_map>

// Default folder to save the synthesized Click configuration
#define DEFAULT_HYPER_NF_OUT_FOLDER static_cast<std::string> ("./results/")

// Default filename to save the synthesized Click (and RSS) configuration(s)
#define DEFAULT_HYPER_NF_CONF_NAME static_cast<std::string> ("synth-nf")

// Indicative defaults
#define DEFAULT_CPU_CORES_NO     16
#define DEFAULT_CPU_SOCKETS_NO   2
#define DEFAULT_NIC_HW_QUEUES_NO 128

// Indicative upper-bounds
#define MAX_CPU_CORES_NO         512
#define MAX_CPU_SOCKETS_NO       128
#define MAX_NIC_HW_QUEUES_NO     128

/*
 * Possible formats of Traffic Classes:
 * |--> To IPClassifier only                          (Click)
 * |--> To replicated IPClassifiers using RSS-Hashing (NIC+Click)
 * |--> To Flow Director rules in the NIC             (NIC+Click)
 * |--> To OpenFlow software/hardware switch          (Switch+Click)
 */
enum TrafficClassFormat {
	Click,
	RSS_Hashing,
	Flow_Director,
	OpenFlow
};

/*
 * Convert the property value given by the user (string) to one of the
 * above types.
 */
const std::unordered_map<std::string, TrafficClassFormat> TCLabelToFormat = {
	{static_cast<std::string> ("Click"),         Click         },
	{static_cast<std::string> ("RSS-Hashing"),   RSS_Hashing   },
	{static_cast<std::string> ("Flow-Director"), Flow_Director },
	{static_cast<std::string> ("OpenFlow"),      OpenFlow      }
};

// Default method to classify the traffic.
#define DEFAULT_TC_FORMAT Click

/*
 * Possible traffic processing layers
 * |--> L2: Ethernet headers are not stripped.
            A pointer (OFFSET 14 bytes) moves processing to IP layer.
 * |--> L3: Ethernet headers are stripped, IP packets are processed, 
            and EtherEncap turns them back to frames.
 */
enum ProcessingLayer {
	L2,
	L3
};

/*
 * Convert the property value given by the user (string) to one of the
 * above types.
 */
const std::unordered_map<std::string, ProcessingLayer> ProcLayerToNumber = {
	{static_cast<std::string> ("L2"), L2 },
	{static_cast<std::string> ("L3"), L3 }
};

// Default Click processing layer for Hyper-NF.
#define DEFAULT_PROC_LAYER L3

/*
 * Class that groups useful system properties for Hyper-NF.
 */
class Properties {
	private:
		/*
		 * Output folder. This is where Hyper-NF Generator places the output files.
		 */
		std::string        output_folder;

		/*
		 * Output filename. This is the file generated by Hyper-NF (in the output_folder).
		 * Note that based on the property file choices, this can be either one .click file
		 * (i.e., output_filename.click) or a set of files (e.g., output_filename.click and
		 * output_filename.rss)
		 */
		std::string        output_filename;

		/*
		 * Boolean that indicates whether the final output will target Intel-RSS + Click DPDK
		 * or simply Click.
		 */
		bool               hardware_classification;

		/*
		 * If hardware_classification is set, one of the following formats are supported:
		 * |--> RSS-Hashing: Splits traffic based on hash functions on specified fields.
		 *      Then, each core will execute the same (entire) Hyper-NF chain.
		 *      Benefits come form parallel processing.
		 * |--> FlowDirector: Assigns traffic to cores based on concrete Flow Director rules.
		 * |--> OpenFlow: Trasform a traffic class into OpenFlow rules that can be injected
		 *      into a software switch (e.g., OVS). Then OVS will send each traffic class to 
		 *      a different virtual interface.
		 * Otherwise, Click is the standard, all-in-software way.
		 */
		TrafficClassFormat traffic_classification_format;

		/*
		 * The network stack layer where Hyper-NF will process input traffic.
		 * Possible values are L2, L3
		 */
		ProcessingLayer   proc_layer;

		/*
		 * Boolean that indicates whether the target system supports
		 * Non-Uniform Memory Access (NUMA).
		 * This helps to do core allocation.
		 */
		bool              numa;

		/*
		 * How many CPU sockets the target system has.
		 * This helps to do core allocation.
		 */
		unsigned short    cpu_sockets_no;

		/*
		 * How many CPU cores (in total) the target system has.
		 * This helps to do core allocation.
		 */
		unsigned short    cpu_cores_no;

		/*
		 * How many hardware queues the target system's NIC has.
		 * This helps to do core allocation per queue.
		 */
		unsigned short    nic_hw_queues_no;

		/*
		 * Instead of simply attaching FromDPDKDevice elements to different NIC queues (and cores)
		 * Follow the paths of each FromDPDKDevice descriptor and pin elements along these paths.
		 * This might not always increase the throughput of Hyper-NF as inter-core communication
		 * might be increased without any reason.
		 */
		bool              rss_aggressive_pinning;

	public:

		/*
		 * Default contructor with indicative properties
		 */
		Properties () {
			this->output_folder                 = DEFAULT_HYPER_NF_OUT_FOLDER;
			this->output_filename               = DEFAULT_HYPER_NF_CONF_NAME;
			this->numa                          = true;
			this->hardware_classification       = false;
			this->traffic_classification_format = DEFAULT_TC_FORMAT;
			this->proc_layer                    = DEFAULT_PROC_LAYER;
			this->cpu_sockets_no                = DEFAULT_CPU_SOCKETS_NO;
			this->cpu_cores_no                  = DEFAULT_CPU_CORES_NO;
			this->nic_hw_queues_no              = DEFAULT_NIC_HW_QUEUES_NO;
			this->rss_aggressive_pinning        = false;
		};

		/*
		 * Contructor with dynamic properties
		 */
		Properties(
			const std::string &out_fold, const std::string &out_file, const bool &hw_class, 
			const TrafficClassFormat &tc_format, const ProcessingLayer &p_layer, 
			const bool &nm, const unsigned short &sockets_no, const unsigned short &cores_no,
			const unsigned short &nic_queues, const bool &rss_aggr_pin): 
			output_folder(out_fold), output_filename(out_file), hardware_classification(hw_class),
			traffic_classification_format(tc_format), proc_layer(p_layer), numa(nm),
			cpu_sockets_no(sockets_no), cpu_cores_no(cores_no), nic_hw_queues_no(nic_queues),
			rss_aggressive_pinning(rss_aggr_pin)
			{};

		/*
		 * Getters
		 */
		inline bool               has_numa                          (void) const { return this->numa; };
		inline bool               has_hardware_classification       (void) const { return this->hardware_classification; };
		inline TrafficClassFormat get_traffic_classification_format (void) const {
			return this->traffic_classification_format;
		};

		inline std::string        get_output_folder         (void) const { return this->output_folder;       };
		inline std::string        get_output_filename       (void) const { return this->output_filename;     };
		inline ProcessingLayer    get_processing_layer      (void) const { return this->proc_layer;          };

		inline unsigned short     get_cpu_cores_no          (void) const { return this->cpu_cores_no;        };
		inline unsigned short     get_cpu_sockets_no        (void) const { return this->cpu_sockets_no;      };
		inline unsigned short     get_nic_hw_queues_no      (void) const { return this->nic_hw_queues_no;    };

		inline bool               get_rss_aggressive_pinning(void) const { return this->rss_aggressive_pinning; };

		/*
		 * Setters (Basic sanity check)
		 */
		inline void set_output_folder                (const std::string &out_fold) {
			this->output_folder   = out_fold;
		}
		inline void set_output_filename              (const std::string &out_file) {
			this->output_filename = out_file;
		}
		inline void set_numa                         (const bool &nm)       {
			this->numa = nm;
		}
		inline void set_hardware_classification      (const bool &hw_class) {
			this->hardware_classification = hw_class;
		}
		inline void set_traffic_classification_format(const TrafficClassFormat &tc_format) {
			this->traffic_classification_format = tc_format;
		}
		inline void set_processing_layer             (const ProcessingLayer &p_layer) {
			assert ( (p_layer == L2) || (p_layer == L3) );
			this->proc_layer = p_layer;
		}
		inline void set_cpu_cores_no                 (const unsigned short &cores_no)   {
			assert ( (cores_no > 0) && (cores_no < MAX_CPU_CORES_NO) );
			this->cpu_cores_no = cores_no;
		}
		inline void set_cpu_sockets_no               (const unsigned short &sockets_no) {
			assert ( (sockets_no > 0) && (sockets_no < MAX_CPU_SOCKETS_NO) );
			this->cpu_sockets_no = sockets_no;
		}
		inline void set_nic_hw_queues_no             (const unsigned short &nic_queues) {
			assert ( (nic_queues > 0) && (nic_queues < MAX_NIC_HW_QUEUES_NO) );
			if ( nic_queues == 0 ) return;
			this->nic_hw_queues_no = nic_queues;
		}
		inline void set_rss_aggressive_pinning       (const bool &rss_aggr_pin) {
			this->rss_aggressive_pinning = rss_aggr_pin;
		}
};

/*
 * Translate the traffic classification enum type to text.
 */
inline const std::string tc_to_label(const TrafficClassFormat &tc_format) {
	switch (tc_format) {
		case Click:
			return std::string("Click");
		case RSS_Hashing:
			return std::string("RSS-Hashing");
		case Flow_Director:
			return std::string("Flow-Director");
		case OpenFlow:
			return std::string("OpenFlow");
		default:
			throw std::runtime_error("Unknown Traffic Class format");
	}
}

/*
 * Translate the traffic classification enum type to text.
 */
inline const std::string proc_layer_to_label(const ProcessingLayer &p_layer) {
	switch (p_layer) {
		case L2:
			return std::string("L2");
		case L3:
			return std::string("L3");
		default:
			throw std::runtime_error("Unknown traffic processing layer");
	}
}

#endif
