diff --git a/elements/analysis/storeicmptimeseqrecord.cc b/elements/analysis/storeicmptimeseqrecord.cc
new file mode 100644
index 0000000..75f35f6
--- /dev/null
+++ b/elements/analysis/storeicmptimeseqrecord.cc
@@ -0,0 +1,158 @@
+/*
+Programmer: Georgios Katsikas
+ * Copyright (c) 2016 
+
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, subject to the conditions
+ * listed in the Click LICENSE file. These conditions include: you must
+ * preserve this copyright notice, and you cannot mention the copyright
+ * holders in advertising related to the Software without their permission.
+ * The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
+ * notice is a summary of the Click LICENSE file; the license in that file is
+ * legally binding.
+*/
+
+#include <click/config.h>
+#include "storeicmptimeseqrecord.hh"
+#include <click/glue.hh>
+#include <clicknet/ip.h>
+#include <clicknet/ip6.h>
+#include <clicknet/icmp.h>
+#include <clicknet/tcp.h>
+#include <click/args.hh>
+#include <click/error.hh>
+
+
+
+CLICK_DECLS
+
+/*
+ */
+StoreICMPTimeSeqRecord::StoreICMPTimeSeqRecord() {
+	_count = 0;
+	_delta = 0;
+	_offset = 0;
+}
+
+
+
+int StoreICMPTimeSeqRecord::configure(Vector<String> &conf, ErrorHandler *errh) {
+	if (Args(conf, this, errh)
+		.read_mp("OFFSET", _offset)
+		.read("DELTA", _delta)
+		.complete() < 0)
+		return -1;
+	return 0;
+}
+
+// This is the tricky bit.  We can't rely on any headers being
+// filled out if elements like CheckIPHeader have not been called
+// so we should just access the raw data and cast wisely
+Packet* StoreICMPTimeSeqRecord::simple_action(Packet *packet) {
+	WritablePacket *p = packet->uniqueify();
+	Timestamp       tnow;
+	click_icmp     *icmph = 0;
+	PData          *pData;
+	uint32_t        csum = 0;
+	uint32_t        offset = _offset;
+
+	// the packet is shared and we can't modify it without screwing
+	// things up
+	if (!p) {
+	// If uniqueify() fails, packet itself is garbage and has been deleted
+		click_chatter("Non-Writable Packet!");
+		return 0;
+	}
+
+	// get the first two words of the IP header to see what it is to determine how to proceed further
+	if (p->length() < offset + sizeof(uint32_t) * 2) {
+		p->kill();
+		return 0;
+	}
+
+	// here need to get to the right offset.  The IP header can be of variable length due to options
+	// also, the header might be IPv4 of IPv6
+	u_char version = p->data()[offset] >> 4;
+	if (version == 0x04) {
+		const click_ip *ip = reinterpret_cast<const click_ip *>(p->data() + offset);
+		offset += ip->ip_hl << 2;
+	}
+	else if (version == 0x06) {
+		// IPv6 header is
+		const click_ip6 *ip6 = reinterpret_cast<const click_ip6 *>(p->data() + offset);
+		if (ip6->ip6_nxt == 0x01) { // ICMP is the next header
+			offset += sizeof(click_ip6);
+		}
+		else { // the next header is not ICMP so stop now
+			p->kill();
+			return 0;
+		}
+	}
+	else {
+		click_chatter("Unknown IP version!");
+		p->kill();
+		return 0;
+	}
+
+	if (p->length() < offset + sizeof(click_icmp) + sizeof(PData)) {
+		//click_chatter("Packet is too short");
+		p->kill();
+		return 0;
+	}
+
+	// eth, IP, headers must be bypassed with a correct offset
+	icmph = (click_icmp*)(p->data() + offset);
+	pData = (PData*)((char*)icmph + sizeof(click_icmp));
+	csum = icmph->icmp_cksum;
+
+	// we use incremental checksum computation to patch up the checksum after
+	// the payload will get modified
+	_count++;
+	if (_delta) {
+		Timestamp ts1(ntohl(pData->data[0]), Timestamp::nsec_to_subsec(ntohl(pData->data[1])));
+		Timestamp diff = Timestamp::now() - ts1;
+
+		//click_chatter("Seq %d Time Diff sec: %d usec: %d\n", ntohl(pData->seq_num), diff.sec(), diff.nsec());
+		pData->data[2] = htonl(diff.sec());
+		pData->data[3] = htonl(diff.nsec());
+		csum += click_in_cksum((const unsigned char*)(pData->data + 2), 2 * sizeof(uint32_t));
+	}
+	else {
+		tnow = Timestamp::now();
+
+		// subtract the previous contribution from CHECKSUM in case PData values are non-zero
+		csum -= click_in_cksum((const unsigned char*)pData, sizeof(PData));
+		pData->seq_num = htonl(_count);
+		pData->data[0] = htonl(tnow.sec());
+		pData->data[1] = htonl(tnow.nsec());
+		pData->data[2] = 0;
+		pData->data[3] = 0;
+		csum += click_in_cksum((const unsigned char*)pData, sizeof(PData));
+	}
+
+	csum = (0xFFFF & csum) + ((0xFFFF0000 & csum) >> 16);
+	csum = (csum != 0xFFFF) ? csum : 0;
+
+	// now that we modified the packet it is time to fix up the
+	// csum of the header.
+	icmph->icmp_cksum = (uint16_t)csum;
+
+	return p;
+}
+
+
+int StoreICMPTimeSeqRecord::reset_handler(const String &, Element *e, void *, ErrorHandler *) {
+	StoreICMPTimeSeqRecord *t = (StoreICMPTimeSeqRecord *) e;
+
+	t->_count = 0;
+	return 0;
+}
+
+void StoreICMPTimeSeqRecord::add_handlers() {
+	add_data_handlers("count", Handler::f_read, &_count);
+	add_write_handler("reset", reset_handler);
+}
+
+CLICK_ENDDECLS
+EXPORT_ELEMENT(StoreICMPTimeSeqRecord)
diff --git a/elements/analysis/storeicmptimeseqrecord.hh b/elements/analysis/storeicmptimeseqrecord.hh
new file mode 100644
index 0000000..977d683
--- /dev/null
+++ b/elements/analysis/storeicmptimeseqrecord.hh
@@ -0,0 +1,108 @@
+// -*- c-basic-offset: 4 -*-
+/*
+Programmer: Georgios Katsikas
+ * Copyright (c) 2016 
+
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, subject to the conditions
+ * listed in the Click LICENSE file. These conditions include: you must
+ * preserve this copyright notice, and you cannot mention the copyright
+ * holders in advertising related to the Software without their permission.
+ * The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
+ * notice is a summary of the Click LICENSE file; the license in that file is
+ * legally binding.
+*/
+#ifndef CLICK_STOREICMPTIMESEQRECORD_HH
+#define CLICK_STOREICMPTIMESEQRECORD_HH
+#include <click/element.hh>
+
+CLICK_DECLS
+
+/*
+=c
+
+StoreICMPTimeSeqRecord([I<keywords> OFFSET, DELTA])
+
+=s timestamps
+
+=d
+
+StoreICMPTimeSeqRecord element can be handy when computing end-to-end ICMP packet
+delays.  The element embeds a timestamp and a sequence number into a packet and
+adjusts the checksum of the ICMP packet.  Once the initial timestamp has been
+placed into the payload of the ICMP packet, a time difference can be computed
+once a packet passes through another StoreICMPTimeSeqRecord element.  The data can be
+accessed by examining the packet payload (e.g., do a tcpdump and then do post
+processing of the data).  The element uses partial checksums to speed up the
+processing.  The element works with IPv4 and IPv6 packets. In case of IPv6,
+it assumes that the next header field is ICMP.  If this is not the case, the
+element will discard the packet.
+
+Packet payload found after the ICMP header.  Note, the ICMP payload must be at least
+22 bytes long.  The values will be stored in network byte order.
+
+uint32_t seq_num
+uint32_t initial_second
+uint32_t initial_nano_second
+uint32_t difference_second
+uint32_t difference_nano_second
+
+Keyword arguments are:
+
+=over 2
+
+=item OFFSET
+
+Number of bytes to offset from the beginning of the packet where the IPv4/6 header can be found.
+If raw Ethernet packets are fed into this element, then OFFSET needs to be 14.
+
+=item DELTA
+
+Determines which time values are set. If DELTA is false (the default), then the initial_second
+and initial_nano_second values are set to the current time, and the difference values are set to 0.
+If DELTA is true, then the initial values are left as is, and the difference values are set to
+the difference between the current time and the packet's initial time.
+
+=back
+
+=e
+    src :: RatedSource(\<00>, LENGTH 22, RATE 1, LIMIT 100)
+        -> ICMPIPEncap(10.0.1.1, 20.0.0.2)
+        -> EtherEncap(0x0800, 00:04:23:D0:93:63, 00:17:cb:0d:f8:db)
+        -> StoreICMPTimeSeqRecord(OFFSET 14, DELTA false)
+        -> DelayShaper(100msec)
+        -> StoreICMPTimeSeqRecord(OFFSET 14, DELTA true)
+        -> ToDump("dump.dmp");
+*/
+class StoreICMPTimeSeqRecord : public Element {
+	public:
+		StoreICMPTimeSeqRecord() CLICK_COLD;
+
+		const char *class_name() const	{ return "StoreICMPTimeSeqRecord"; }
+		const char *port_count() const	{ return PORTS_1_1; }
+
+		void add_handlers() CLICK_COLD;
+		int  configure(Vector<String> &conf, ErrorHandler *errh) CLICK_COLD;
+
+		Packet *simple_action(Packet *);
+
+		// packet data payload access struct
+		// Header | PDATA | rest of data
+		// This comes out to 22 bytes which will fit into the smallest Ethernet frame
+		struct PData {
+			uint32_t seq_num;
+			uint32_t data[4];
+		};
+
+	private:
+		unsigned long _count;
+		bool          _delta;  // if true put in_timestamp else out_timestamp
+		uint32_t      _offset; //how much to shift to get to the IPv4/v6 header
+
+		static String read_handler(Element *, void *) CLICK_COLD;
+		static int    reset_handler(const String &, Element *, void *, ErrorHandler *);
+};
+
+CLICK_ENDDECLS
+#endif
diff --git a/elements/analysis/storetcptimeseqrecord.cc b/elements/analysis/storetcptimeseqrecord.cc
new file mode 100644
index 0000000..50fe1f8
--- /dev/null
+++ b/elements/analysis/storetcptimeseqrecord.cc
@@ -0,0 +1,153 @@
+/*
+Programmer: Georgios Katsikas
+ * Copyright (c) 2016 
+
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, subject to the conditions
+ * listed in the Click LICENSE file. These conditions include: you must
+ * preserve this copyright notice, and you cannot mention the copyright
+ * holders in advertising related to the Software without their permission.
+ * The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
+ * notice is a summary of the Click LICENSE file; the license in that file is
+ * legally binding.
+*/
+
+#include <click/config.h>
+#include "storetcptimeseqrecord.hh"
+#include <click/glue.hh>
+#include <clicknet/ip.h>
+#include <clicknet/ip6.h>
+#include <clicknet/tcp.h>
+#include <click/args.hh>
+#include <click/error.hh>
+
+CLICK_DECLS
+
+/*
+ */
+StoreTCPTimeSeqRecord::StoreTCPTimeSeqRecord() {
+	_count = 0;
+	_delta = 0;
+	_offset = 0;
+}
+
+int StoreTCPTimeSeqRecord::configure(Vector<String> &conf, ErrorHandler *errh) {
+	if (Args(conf, this, errh)
+		.read_mp("OFFSET", _offset)
+		.read("DELTA", _delta)
+		.complete() < 0)
+		return -1;
+	return 0;
+}
+
+// This is the tricky bit.  We can't rely on any headers being
+// filled out if elements like CheckIPHeader have not been called
+// so we should just access the raw data and cast wisely
+Packet* StoreTCPTimeSeqRecord::simple_action(Packet *packet) {
+	WritablePacket *p = packet->uniqueify();
+	Timestamp      tnow;
+	click_tcp      *tcph = 0;
+	PData          *pData;
+	uint32_t       csum = 0;
+	uint32_t       offset = _offset;
+
+	// the packet is shared and we can't modify it without screwing
+	// things up
+	if (!p) {
+	// If uniqueify() fails, packet itself is garbage and has been deleted
+		click_chatter("Non-Writable Packet!");
+		return 0;
+	}
+
+	// get the first two words of the IP header to see what it is to determine how to proceed further
+	if (p->length() < offset + sizeof(uint32_t) * 2) {
+		p->kill();
+		return 0;
+	}
+
+	// here need to get to the right offset.  The IP header can be of variable length due to options
+	// also, the header might be IPv4 of IPv6
+	u_char version = p->data()[offset] >> 4;
+	if (version == 0x04) {
+		const click_ip *ip = reinterpret_cast<const click_ip *>(p->data() + offset);
+		offset += ip->ip_hl << 2;
+	}
+	else if (version == 0x06) {
+		// IPv6 header is
+		const click_ip6 *ip6 = reinterpret_cast<const click_ip6 *>(p->data() + offset);
+		if (ip6->ip6_nxt == 0x06) { // TCP is the next header
+			offset += sizeof(click_ip6);
+		}
+		else { // the next header is not TCP so stop now
+			p->kill();
+			return 0;
+		}
+	}
+	else {
+		click_chatter("Unknown IP version!");
+		p->kill();
+		return 0;
+	}
+
+	if (p->length() < offset + sizeof(click_tcp) + sizeof(PData)) {
+		//click_chatter("Packet is too short");
+		p->kill();
+		return 0;
+	}
+
+	// eth, IP, headers must be bypassed with a correct offset
+	tcph = (click_tcp*)(p->data() + offset);
+	pData = (PData*)((char*)tcph + sizeof(click_tcp));
+	csum = tcph->th_sum;
+
+	// we use incremental checksum computation to patch up the checksum after
+	// the payload will get modified
+	_count++;
+	if (_delta) {
+		Timestamp ts1(ntohl(pData->data[0]), Timestamp::nsec_to_subsec(ntohl(pData->data[1])));
+		Timestamp diff = Timestamp::now() - ts1;
+
+		//click_chatter("Seq %d Time Diff sec: %d usec: %d\n", ntohl(pData->seq_num), diff.sec(), diff.nsec());
+		pData->data[2] = htonl(diff.sec());
+		pData->data[3] = htonl(diff.nsec());
+		csum += click_in_cksum((const unsigned char*)(pData->data + 2), 2 * sizeof(uint32_t));
+	}
+	else {
+		tnow = Timestamp::now();
+
+		// subtract the previous contribution from CHECKSUM in case PData values are non-zero
+		csum -= click_in_cksum((const unsigned char*)pData, sizeof(PData));
+		pData->seq_num = htonl(_count);
+		pData->data[0] = htonl(tnow.sec());
+		pData->data[1] = htonl(tnow.nsec());
+		pData->data[2] = 0;
+		pData->data[3] = 0;
+		csum += click_in_cksum((const unsigned char*)pData, sizeof(PData));
+	}
+
+	csum = (0xFFFF & csum) + ((0xFFFF0000 & csum) >> 16);
+	csum = (csum != 0xFFFF) ? csum : 0;
+
+	// now that we modified the packet it is time to fix up the
+	// csum of the header.
+	tcph->th_sum = (uint16_t)csum;
+
+	return p;
+}
+
+
+int StoreTCPTimeSeqRecord::reset_handler(const String &, Element *e, void *, ErrorHandler *) {
+	StoreTCPTimeSeqRecord *t = (StoreTCPTimeSeqRecord *) e;
+
+	t->_count = 0;
+	return 0;
+}
+
+void StoreTCPTimeSeqRecord::add_handlers() {
+	add_data_handlers("count", Handler::f_read, &_count);
+	add_write_handler("reset", reset_handler);
+}
+
+CLICK_ENDDECLS
+EXPORT_ELEMENT(StoreTCPTimeSeqRecord)
diff --git a/elements/analysis/storetcptimeseqrecord.hh b/elements/analysis/storetcptimeseqrecord.hh
new file mode 100644
index 0000000..5aa8883
--- /dev/null
+++ b/elements/analysis/storetcptimeseqrecord.hh
@@ -0,0 +1,99 @@
+// -*- c-basic-offset: 4 -*-
+/*
+Programmer: Georgios Katsikas
+ * Copyright (c) 2016 
+
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, subject to the conditions
+ * listed in the Click LICENSE file. These conditions include: you must
+ * preserve this copyright notice, and you cannot mention the copyright
+ * holders in advertising related to the Software without their permission.
+ * The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
+ * notice is a summary of the Click LICENSE file; the license in that file is
+ * legally binding.
+*/
+#ifndef CLICK_STORETCPTIMESEQRECORD_HH
+#define CLICK_STORETCPTIMESEQRECORD_HH
+#include <click/element.hh>
+
+CLICK_DECLS
+
+/*
+=c
+
+StoreTCPTimeSeqRecord([I<keywords> OFFSET, DELTA])
+
+=s timestamps
+
+=d
+
+StoreTCPTimeSeqRecord element can be handy when computing end-to-end TCP packet
+delays.  The element embeds a timestamp and a sequence number into a packet and
+adjusts the checksum of the TCP packet.  Once the initial timestamp has been
+placed into the payload of the TCP packet, a time difference can be computed
+once a packet passes through another StoreTCPTimeSeqRecord element.  The data can be
+accessed by examining the packet payload (e.g., do a tcpdump and then do post
+processing of the data).  The element uses partial checksums to speed up the
+processing.  The element works with IPv4 and IPv6 packets. In case of IPv6,
+it assumes that the next header field is TCP.  If this is not the case, the
+element will discard the packet.
+
+Packet payload found after the TCP header.  Note, the TCP payload must be at least
+22 bytes long.  The values will be stored in network byte order.
+
+uint32_t seq_num
+uint32_t initial_second
+uint32_t initial_nano_second
+uint32_t difference_second
+uint32_t difference_nano_second
+
+Keyword arguments are:
+
+=over 2
+
+=item OFFSET
+
+Number of bytes to offset from the beginning of the packet where the IPv4/6 header can be found.
+If raw Ethernet packets are fed into this element, then OFFSET needs to be 14.
+
+=item DELTA
+
+Determines which time values are set. If DELTA is false (the default), then the initial_second
+and initial_nano_second values are set to the current time, and the difference values are set to 0.
+If DELTA is true, then the initial values are left as is, and the difference values are set to
+the difference between the current time and the packet's initial time.
+
+=back
+*/
+class StoreTCPTimeSeqRecord : public Element {
+	public:
+		StoreTCPTimeSeqRecord() CLICK_COLD;
+
+		const char *class_name() const	{ return "StoreTCPTimeSeqRecord"; }
+		const char *port_count() const	{ return PORTS_1_1; }
+
+		void add_handlers() CLICK_COLD;
+		int  configure(Vector<String> &conf, ErrorHandler *errh) CLICK_COLD;
+
+		Packet *simple_action(Packet *);
+
+		// packet data payload access struct
+		// Header | PDATA | rest of data
+		// This comes out to 22 bytes which will fit into the smallest Ethernet frame
+		struct PData {
+			uint32_t seq_num;
+			uint32_t data[4];
+		};
+
+	private:
+		unsigned long _count;
+		bool          _delta;  // if true put in_timestamp else out_timestamp
+		uint32_t      _offset; //how much to shift to get to the IPv4/v6 header
+
+		static String read_handler(Element *, void *) CLICK_COLD;
+		static int    reset_handler(const String &, Element *, void *, ErrorHandler *);
+};
+
+CLICK_ENDDECLS
+#endif
diff --git a/elements/ip/decipttl.cc b/elements/ip/decipttl.cc
index cdc8dca..86e1a78 100644
--- a/elements/ip/decipttl.cc
+++ b/elements/ip/decipttl.cc
@@ -24,7 +24,7 @@
 CLICK_DECLS
 
 DecIPTTL::DecIPTTL()
-    : _active(true), _multicast(true)
+    : _active(true), _multicast(true), _calc_checksum(true)
 {
     _drops = 0;
 }
@@ -37,8 +37,9 @@ int
 DecIPTTL::configure(Vector<String> &conf, ErrorHandler *errh)
 {
     return Args(conf, this, errh)
-	.read("ACTIVE", _active)
-	.read("MULTICAST", _multicast).complete();
+	.read("ACTIVE",        _active)
+	.read("CALC_CHECKSUM", _calc_checksum)
+	.read("MULTICAST",     _multicast).complete();
 }
 
 Packet *
@@ -51,6 +52,7 @@ DecIPTTL::simple_action(Packet *p)
     if (!_multicast && IPAddress(ip_in->ip_dst).is_multicast())
 	return p;
 
+    // Time to drop
     if (ip_in->ip_ttl <= 1) {
 	++_drops;
 	checked_output_push(1, p);
@@ -60,7 +62,13 @@ DecIPTTL::simple_action(Packet *p)
 	if (!q)
 	    return 0;
 	click_ip *ip = q->ip_header();
-	--ip->ip_ttl;
+
+	// Decrement
+	ip->ip_ttl --;
+
+	// Hyper-NF: Do not calculate IP checksum if you are requested to do so
+	if ( !_calc_checksum )
+		return q;
 
 	// 19.Aug.1999 - incrementally update IP checksum as suggested by SOSP
 	// reviewers, according to RFC1141, as updated by RFC1624.
@@ -81,6 +89,7 @@ DecIPTTL::add_handlers()
 {
     add_data_handlers("drops", Handler::OP_READ, &_drops);
     add_data_handlers("active", Handler::OP_READ | Handler::OP_WRITE | Handler::CHECKBOX, &_active);
+    add_data_handlers("calc_checksum", Handler::OP_READ | Handler::OP_WRITE | Handler::CHECKBOX, &_calc_checksum);
 }
 
 CLICK_ENDDECLS
diff --git a/elements/ip/decipttl.hh b/elements/ip/decipttl.hh
index b2ff703..7f5aa4a 100644
--- a/elements/ip/decipttl.hh
+++ b/elements/ip/decipttl.hh
@@ -62,6 +62,8 @@ class DecIPTTL : public Element { public:
     bool _active;
     bool _multicast;
 
+    // Hyper-NF: Make the Checksum calculation optional
+    bool _calc_checksum;
 };
 
 CLICK_ENDDECLS
diff --git a/elements/ip/ipfilter.cc b/elements/ip/ipfilter.cc
index beafd02..fa1a584 100644
--- a/elements/ip/ipfilter.cc
+++ b/elements/ip/ipfilter.cc
@@ -55,7 +55,10 @@ static const StaticNameDB::Entry type_entries[] = {
     { "type", IPFilter::FIELD_ICMP_TYPE },
     { "unfrag", IPFilter::TYPE_IPUNFRAG },
     { "vers", IPFilter::FIELD_VERSION },
-    { "win", IPFilter::FIELD_TCP_WIN }
+    { "win", IPFilter::FIELD_TCP_WIN },
+    /* Fields IP_SRC and IP_DST added for HyperNF */
+    { "src", IPFilter::FIELD_IP_SRC},
+    { "dst", IPFilter::FIELD_IP_DST}
 };
 
 static const StaticNameDB::Entry tcp_opt_entries[] = {
@@ -294,6 +297,9 @@ IPFilter::Primitive::unparse_type(int srcdst, int type)
        case FIELD_TTL: sa << "ip ttl"; break;
        case FIELD_TCP_WIN: sa << "tcp win"; break;
        case FIELD_ICMP_TYPE: sa << "icmp type"; break;
+       /* Fields IP_SRC and IP_DST added for HyperNF */
+       case FIELD_IP_SRC: sa << "ip src"; break;
+       case FIELD_IP_DST: sa << "ip dst"; break;
        default:
 	if (type & FIELD_PROTO_MASK)
 	  sa << unparse_transp_proto((type & FIELD_PROTO_MASK) >> FIELD_PROTO_SHIFT);
diff --git a/elements/ip/ipfilter.hh b/elements/ip/ipfilter.hh
index 25b63af..ddaffee 100644
--- a/elements/ip/ipfilter.hh
+++ b/elements/ip/ipfilter.hh
@@ -177,7 +177,10 @@ class IPFilter : public Element { public:
 	FIELD_DSCP	= (TYPE_FIELD | ((1*8) << FIELD_OFFSET_SHIFT) | 5),
 	FIELD_TTL	= (TYPE_FIELD | ((8*8) << FIELD_OFFSET_SHIFT) | 7),
 	FIELD_TCP_WIN = (TYPE_FIELD | (IP_PROTO_TCP << FIELD_PROTO_SHIFT) | ((14*8) << FIELD_OFFSET_SHIFT) | 15),
-	FIELD_ICMP_TYPE = (TYPE_FIELD | (IP_PROTO_ICMP << FIELD_PROTO_SHIFT) | (0 << FIELD_OFFSET_SHIFT) | 7)
+	FIELD_ICMP_TYPE = (TYPE_FIELD | (IP_PROTO_ICMP << FIELD_PROTO_SHIFT) | (0 << FIELD_OFFSET_SHIFT) | 7),
+        /* Fields IP_SRC and IP_DST added for HyperNF */
+        FIELD_IP_SRC = (TYPE_FIELD | ((12*8) << FIELD_OFFSET_SHIFT) | 31),
+        FIELD_IP_DST = (TYPE_FIELD | ((16*8) << FIELD_OFFSET_SHIFT) | 31),
     };
 
     enum {
diff --git a/include/click/router.hh b/include/click/router.hh
index dc83606..87a7b68 100644
--- a/include/click/router.hh
+++ b/include/click/router.hh
@@ -129,7 +129,14 @@ class Router { public:
     inline Router* hotswap_router() const;
     void set_hotswap_router(Router* router);
 
-    int initialize(ErrorHandler* errh);
+    /*
+     * Hyper-NF Modification to prevent Click from initializing the elements in this call.
+     * We simply want to have the Click DAG populated with all the elements and connections.
+     * The 2nd argument is set to false by default. This is how normal Click calls the function
+     * so it does not affect normal Click executions.
+     */
+    int initialize(ErrorHandler* errh, bool initialize_only_dag=false);
+
     void activate(bool foreground, ErrorHandler* errh);
     inline void activate(ErrorHandler* errh);
     inline void set_foreground(bool foreground);
@@ -296,6 +303,10 @@ class Router { public:
 
     Router* _next_router;
 
+    // Hyper-NF extension: If set to true, the router's elements are not initialized
+    // Router::initialize() and ~Router() use this field to properly set and reset the router
+    bool _do_not_initialize;
+
 #if CLICK_LINUXMODULE
     Vector<struct module*> _modules;
 #endif
diff --git a/lib/driver.cc b/lib/driver.cc
index 0b4ac0f..01a8b70 100644
--- a/lib/driver.cc
+++ b/lib/driver.cc
@@ -527,8 +527,9 @@ click_read_router(String filename, bool is_expr, ErrorHandler *errh, bool initia
     l->end_parse(cookie);
 
     // initialize if requested
+    bool initialize_only_dag = false;
     if (initialize)
-	if (errh->nerrors() > before || router->initialize(errh) < 0) {
+	if (errh->nerrors() > before || router->initialize(errh, initialize_only_dag) < 0) {
 	    delete router;
 	    return 0;
 	}
diff --git a/lib/router.cc b/lib/router.cc
index d345236..cd11e0d 100644
--- a/lib/router.cc
+++ b/lib/router.cc
@@ -83,7 +83,8 @@ Router::Router(const String &configuration, Master *master)
       _configuration(configuration),
       _notifier_signals(0),
       _arena_factory(new HashMap_ArenaFactory),
-      _hotswap_router(0), _thread_sched(0), _name_info(0), _next_router(0)
+      _hotswap_router(0), _thread_sched(0), _name_info(0), _next_router(0),
+      _do_not_initialize(false)
 {
     _refcount = 0;
     _runcount = 0;
@@ -117,7 +118,8 @@ Router::~Router()
 	for (int ord = _elements.size() - 1; ord >= 0; ord--)
 	    _elements[ _element_configure_order[ord] ]->cleanup(Element::CLEANUP_ROUTER_INITIALIZED);
     } else if (_state != ROUTER_DEAD) {
-	assert(_element_configure_order.size() == 0 && _state <= ROUTER_PRECONFIGURE);
+        // We do not follow all the Click states thus this assertion must be commented
+	//assert(_element_configure_order.size() == 0 && _state <= ROUTER_PRECONFIGURE);
 	for (int i = _elements.size() - 1; i >= 0; i--)
 	    _elements[i]->cleanup(Element::CLEANUP_NO_ROUTER);
     }
@@ -151,6 +153,12 @@ Router::~Router()
 	delete ns;
     }
     delete _name_info;
+
+    // Return here in case that the router has been constructed by setting this member to true.
+    // In this case we haven't registered our Router in the first place.
+    if ( _do_not_initialize )
+    	return;
+
     if (_master)
 	_master->unregister_router(this);
 }
@@ -1085,7 +1093,7 @@ Router::initialize_handlers(bool defaults, bool specifics)
 }
 
 int
-Router::initialize(ErrorHandler *errh)
+Router::initialize(ErrorHandler *errh, bool do_not_initialize)
 {
     if (_state != ROUTER_NEW)
 	return errh->error("second attempt to initialize router");
@@ -1165,6 +1173,18 @@ Router::initialize(ErrorHandler *errh)
 	}
     }
 
+    //////////////////////////////////////////////////////////////////////////////
+    /*
+     * Hyper-NF modification to prevent the initialization of Click elements
+     * It happens only when the boolean argument is true. Default is false.
+     */
+    //////////////////////////////////////////////////////////////////////////////
+    if ( do_not_initialize ) {
+	// This field is useful in the destructor
+	_do_not_initialize = true;
+	return 0;
+    }
+
 #if CLICK_DMALLOC
     CLICK_DMALLOC_REG("iHoo");
 #endif
diff --git a/userlevel/click.cc b/userlevel/click.cc
index a5e01cc..63f1cbb 100644
--- a/userlevel/click.cc
+++ b/userlevel/click.cc
@@ -388,8 +388,9 @@ parse_configuration(const String &text, bool text_is_expr, bool hotswap,
   if (hotswap && click_router && click_router->initialized())
       router->set_hotswap_router(click_router);
 
+  bool initialize_only_dag = false;
   if (errh->nerrors() == before_errors
-      && router->initialize(errh) >= 0)
+      && router->initialize(errh, initialize_only_dag) >= 0)
     return router;
   else {
     delete router;
