diff --git a/elements/ip/decipttl.cc b/elements/ip/decipttl.cc
index cdc8dca..cf7ae50 100644
--- a/elements/ip/decipttl.cc
+++ b/elements/ip/decipttl.cc
@@ -24,7 +24,7 @@
 CLICK_DECLS
 
 DecIPTTL::DecIPTTL()
-    : _active(true), _multicast(true)
+    : _active(true), _multicast(true), _calc_checksum(true)
 {
     _drops = 0;
 }
@@ -37,8 +37,9 @@ int
 DecIPTTL::configure(Vector<String> &conf, ErrorHandler *errh)
 {
     return Args(conf, this, errh)
-	.read("ACTIVE", _active)
-	.read("MULTICAST", _multicast).complete();
+	.read("ACTIVE",        _active)
+	.read("CALC_CHECKSUM", _calc_checksum)
+	.read("MULTICAST",     _multicast).complete();
 }
 
 Packet *
@@ -51,6 +52,7 @@ DecIPTTL::simple_action(Packet *p)
     if (!_multicast && IPAddress(ip_in->ip_dst).is_multicast())
 	return p;
 
+    // Time to drop
     if (ip_in->ip_ttl <= 1) {
 	++_drops;
 	checked_output_push(1, p);
@@ -60,7 +62,13 @@ DecIPTTL::simple_action(Packet *p)
 	if (!q)
 	    return 0;
 	click_ip *ip = q->ip_header();
-	--ip->ip_ttl;
+
+	// Decrement
+	ip->ip_ttl --;
+
+	// SNF: Do not calculate IP checksum if you are requested to do so
+	if ( !_calc_checksum )
+		return q;
 
 	// 19.Aug.1999 - incrementally update IP checksum as suggested by SOSP
 	// reviewers, according to RFC1141, as updated by RFC1624.
@@ -81,6 +89,7 @@ DecIPTTL::add_handlers()
 {
     add_data_handlers("drops", Handler::OP_READ, &_drops);
     add_data_handlers("active", Handler::OP_READ | Handler::OP_WRITE | Handler::CHECKBOX, &_active);
+    add_data_handlers("calc_checksum", Handler::OP_READ | Handler::OP_WRITE | Handler::CHECKBOX, &_calc_checksum);
 }
 
 CLICK_ENDDECLS
diff --git a/elements/ip/decipttl.hh b/elements/ip/decipttl.hh
index b2ff703..c1b6c92 100644
--- a/elements/ip/decipttl.hh
+++ b/elements/ip/decipttl.hh
@@ -62,6 +62,8 @@ class DecIPTTL : public Element { public:
     bool _active;
     bool _multicast;
 
+    // SNF: Make the Checksum calculation optional
+    bool _calc_checksum;
 };
 
 CLICK_ENDDECLS
diff --git a/elements/ip/ipfilter.cc b/elements/ip/ipfilter.cc
index 7cff8b2..af056f7 100644
--- a/elements/ip/ipfilter.cc
+++ b/elements/ip/ipfilter.cc
@@ -55,7 +55,10 @@ static const StaticNameDB::Entry type_entries[] = {
     { "type", IPFilter::FIELD_ICMP_TYPE },
     { "unfrag", IPFilter::TYPE_IPUNFRAG },
     { "vers", IPFilter::FIELD_VERSION },
-    { "win", IPFilter::FIELD_TCP_WIN }
+    { "win", IPFilter::FIELD_TCP_WIN },
+    /* Fields IP_SRC and IP_DST added for SNF */
+    { "src", IPFilter::FIELD_IP_SRC},
+    { "dst", IPFilter::FIELD_IP_DST}
 };
 
 static const StaticNameDB::Entry tcp_opt_entries[] = {
@@ -294,6 +297,9 @@ IPFilter::Primitive::unparse_type(int srcdst, int type)
        case FIELD_TTL: sa << "ip ttl"; break;
        case FIELD_TCP_WIN: sa << "tcp win"; break;
        case FIELD_ICMP_TYPE: sa << "icmp type"; break;
+       /* Fields IP_SRC and IP_DST added for SNF */
+       case FIELD_IP_SRC: sa << "ip src"; break;
+       case FIELD_IP_DST: sa << "ip dst"; break;
        default:
 	if (type & FIELD_PROTO_MASK)
 	  sa << unparse_transp_proto((type & FIELD_PROTO_MASK) >> FIELD_PROTO_SHIFT);
diff --git a/elements/ip/ipfilter.hh b/elements/ip/ipfilter.hh
index 667f387..63421b1 100644
--- a/elements/ip/ipfilter.hh
+++ b/elements/ip/ipfilter.hh
@@ -172,7 +172,10 @@ class IPFilter : public Element { public:
 	FIELD_DSCP	= (TYPE_FIELD | ((1*8) << FIELD_OFFSET_SHIFT) | 5),
 	FIELD_TTL	= (TYPE_FIELD | ((8*8) << FIELD_OFFSET_SHIFT) | 7),
 	FIELD_TCP_WIN = (TYPE_FIELD | (IP_PROTO_TCP << FIELD_PROTO_SHIFT) | ((14*8) << FIELD_OFFSET_SHIFT) | 15),
-	FIELD_ICMP_TYPE = (TYPE_FIELD | (IP_PROTO_ICMP << FIELD_PROTO_SHIFT) | (0 << FIELD_OFFSET_SHIFT) | 7)
+	FIELD_ICMP_TYPE = (TYPE_FIELD | (IP_PROTO_ICMP << FIELD_PROTO_SHIFT) | (0 << FIELD_OFFSET_SHIFT) | 7),
+        /* Fields IP_SRC and IP_DST added for SNF */
+        FIELD_IP_SRC = (TYPE_FIELD | ((12*8) << FIELD_OFFSET_SHIFT) | 31),
+        FIELD_IP_DST = (TYPE_FIELD | ((16*8) << FIELD_OFFSET_SHIFT) | 31),
     };
 
     enum {
diff --git a/elements/ip/ipoutputcombo.cc b/elements/ip/ipoutputcombo.cc
index 3320a05..deda012 100644
--- a/elements/ip/ipoutputcombo.cc
+++ b/elements/ip/ipoutputcombo.cc
@@ -2,7 +2,10 @@
  * ipoutputcombo.{cc,hh} -- IP router output combination element
  * Eddie Kohler
  *
+ * Optional checksum calculation by Georgios Katsikas
+ *
  * Copyright (c) 1999-2000 Massachusetts Institute of Technology
+ * Copyright (c) 2016 KTH Royal Institute of Technology
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -24,6 +27,7 @@
 CLICK_DECLS
 
 IPOutputCombo::IPOutputCombo()
+    : _calc_checksum(true)
 {
 }
 
@@ -37,6 +41,7 @@ IPOutputCombo::configure(Vector<String> &conf, ErrorHandler *errh)
     return Args(conf, this, errh)
 	.read_mp("COLOR", _color)
 	.read_mp("IPADDR", _my_ip)
+	.read("CALC_CHECKSUM", _calc_checksum)
 	.read_mp("MTU", _mtu).complete();
 }
 
@@ -173,7 +178,7 @@ IPOutputCombo::push(int, Packet *p_in)
   }
 
   // IPGWOptions / FixIPSrc
-  if (do_cksum) {
+  if (do_cksum && _calc_checksum) {
     ip->ip_sum = 0;
     ip->ip_sum = click_in_cksum(p->data(), hlen);
   }
@@ -186,8 +191,11 @@ IPOutputCombo::push(int, Packet *p_in)
     ip->ip_ttl--;
     // 19.Aug.1999 - incrementally update IP checksum as suggested by SOSP
     // reviewers, according to RFC1141 and RFC1624
-    unsigned long sum = (~ntohs(ip->ip_sum) & 0xFFFF) + 0xFEFF;
-    ip->ip_sum = ~htons(sum + (sum >> 16));
+    // Do not calculate IP checksum if you are requested to do so
+    if (_calc_checksum) {
+        unsigned long sum = (~ntohs(ip->ip_sum) & 0xFFFF) + 0xFEFF;
+        ip->ip_sum = ~htons(sum + (sum >> 16));
+    }
   }
 
   // Fragmenter
@@ -204,6 +212,12 @@ IPOutputCombo::push(int, Packet *p_in)
   output(2).push(p);
 }
 
+void
+IPOutputCombo::add_handlers()
+{
+    add_data_handlers("calc_checksum", Handler::OP_READ | Handler::OP_WRITE | Handler::CHECKBOX, &_calc_checksum);
+}
+
 CLICK_ENDDECLS
 EXPORT_ELEMENT(IPOutputCombo)
 ELEMENT_MT_SAFE(IPOutputCombo)
diff --git a/elements/ip/ipoutputcombo.hh b/elements/ip/ipoutputcombo.hh
index 8fc95bd..0326702 100644
--- a/elements/ip/ipoutputcombo.hh
+++ b/elements/ip/ipoutputcombo.hh
@@ -7,7 +7,7 @@ CLICK_DECLS
 
 /*
  * =c
- * IPOutputCombo(COLOR, IPADDR, MTU)
+ * IPOutputCombo(COLOR, IPADDR, MTU, CALC_CHECKSUM)
  * =s ip
  * output combo for IP routing
  * =d
@@ -32,6 +32,11 @@ CLICK_DECLS
  * outputs for PaintTee, IPGWOptions, and DecIPTTL, respectively; and
  * output 4 is for packets longer than MTU.
  *
+ * =item CALC_CHECKSUM
+ * Boolean. If true, the element does not calculate the IP checksum,
+ * since it is assumed that a subsequent element will do so.
+ * Defaults to true.
+ *
  * =n
  *
  * IPOutputCombo does no fragmentation. You'll still need an IPFragmenter for
@@ -52,6 +57,7 @@ class IPOutputCombo : public Element {
   const char *processing() const		{ return PUSH; }
 
   int configure(Vector<String> &, ErrorHandler *) CLICK_COLD;
+  void add_handlers() CLICK_COLD;
 
   void push(int, Packet *);
 
@@ -60,7 +66,7 @@ class IPOutputCombo : public Element {
   int _color;			// PaintTee
   struct in_addr _my_ip;	// IPGWOptions, FixIPSrc
   unsigned _mtu;		// Fragmenter
-
+  bool _calc_checksum;          // Make the checksum calculation optional
 };
 
 CLICK_ENDDECLS
diff --git a/elements/ip/iprewriterbase.cc b/elements/ip/iprewriterbase.cc
index 50e3f34..cd5e942 100644
--- a/elements/ip/iprewriterbase.cc
+++ b/elements/ip/iprewriterbase.cc
@@ -50,7 +50,6 @@ CLICK_DECLS
 //
 // IPMapper
 //
-
 void
 IPMapper::notify_rewriter(IPRewriterBase *, IPRewriterInput *, ErrorHandler *)
 {
@@ -66,9 +65,12 @@ IPMapper::rewrite_flowid(IPRewriterInput *, const IPFlowID &, IPFlowID &,
 //
 // IPRewriterBase
 //
-
 IPRewriterBase::IPRewriterBase()
-    : _map(0), _heap(new IPRewriterHeap), _gc_timer(gc_timer_hook, this)
+    : _map(0), _heap(new IPRewriterHeap), _gc_timer(gc_timer_hook, this),
+	_drop_bcast(false), _ipgw_opt(false), _fix_ip_src(false),
+	_ip_fragment(false), _dec_ip_ttl(false), _calc_checksum(true),
+	_my_ip(), _mtu(1500), _headroom(Packet::default_headroom),
+	_honor_df(true), _verbose(false)
 {
     _timeouts[0] = default_timeout;
     _timeouts[1] = default_guarantee;
@@ -158,9 +160,45 @@ IPRewriterBase::configure(Vector<String> &conf, ErrorHandler *errh)
 	.read("GUARANTEE", SecondsArg(), _timeouts[1])
 	.read("REAP_INTERVAL", SecondsArg(), _gc_interval_sec)
 	.read("REAP_TIME", Args::deprecated, SecondsArg(), _gc_interval_sec)
+	.read("DROP_BCAST", _drop_bcast)
+	.read("IPGW_OPTIONS", _ipgw_opt)
+	.read("FIX_IP_SRC", _fix_ip_src)
+	.read("DEC_IP_TTL", _dec_ip_ttl)
+	.read("IP_FRAGMENT", _ip_fragment)
+	.read("IP_OUT_COMBO", _ip_out_combo)
+	.read("CALC_CHECKSUM", _calc_checksum)
+	.read("MTU", _mtu)
+	.read("HEADROOM", _headroom)
+	.read("HONOR_DF", _honor_df)
+	.read("VERBOSE", _verbose)
 	.consume() < 0)
 	return -1;
 
+    // Combines all these elements
+    if ( _ip_out_combo ) {
+	_dec_ip_ttl = _fix_ip_src = _ipgw_opt = _drop_bcast = true;
+    }
+
+    // These elements modify parts of header space
+    if ( _ipgw_opt || _fix_ip_src || _dec_ip_ttl || _ip_out_combo ) {
+	_calc_checksum = true;
+    }
+
+    /*
+    click_chatter("\n");
+    click_chatter("   DEC_IP_TTL: %s", _dec_ip_ttl? "True":"False");
+    click_chatter("   DROP_BCAST: %s", _drop_bcast? "True":"False");
+    click_chatter(" IPGW_OPTIONS: %s", _ipgw_opt? "True":"False");
+    click_chatter("   FIX_IP_SRC: %s", _fix_ip_src? "True":"False");
+    click_chatter("  IP_FRAGMENT: %s", _ip_fragment? "True":"False");
+    click_chatter("CALC_CHECKSUM: %s", _calc_checksum? "True":"False");
+    click_chatter("     HONOR_DF: %s", _honor_df? "True":"False");
+    click_chatter("      VERBOSE: %s", _verbose? "True":"False");
+    click_chatter("     HEADROOM: %d", _headroom);
+    click_chatter("          MTU: %d", _mtu);
+    click_chatter("       IPADDR: %s", IPAddress(_my_ip).s().c_str());
+    */
+
     if (capacity_word) {
 	Element *e;
 	IPRewriterBase *rwb;
@@ -175,18 +213,40 @@ IPRewriterBase::configure(Vector<String> &conf, ErrorHandler *errh)
 	    return errh->error("bad MAPPING_CAPACITY");
     }
 
-    if (conf.size() != ninputs())
-	return errh->error("need %d arguments, one per input port", ninputs());
-
     _timeouts[0] *= CLICK_HZ;	// _timeouts is measured in jiffies
     _timeouts[1] *= CLICK_HZ;
 
+    bool has_ipaddr = false;
+    String ipaddr_pat = String("IPADDR");
     for (int i = 0; i < conf.size(); ++i) {
+	//click_chatter("Arg: %s", conf[i].c_str());
+
+	// IPADDR argument not handled above
+	int start_pos = conf[i].find_left(ipaddr_pat, 0);
+	if ( start_pos >= 0 ) {
+		has_ipaddr = true;
+		String ip = conf[i].substring(start_pos+ipaddr_pat.length()+1, -1);
+		//click_chatter("Found %s", ip.c_str());
+		_my_ip = IPAddress(ip).in_addr();
+		//click_chatter("       IPADDR: %s", IPAddress(_my_ip).s().c_str());
+		continue;
+	}
+
 	IPRewriterInput is;
 	if (parse_input_spec(conf[i], is, i, errh) >= 0)
 	    _input_specs.push_back(is);
     }
 
+    int extra_params = has_ipaddr? 1:0;
+    if ( conf.size()-extra_params != ninputs() )
+	return errh->error("need %d arguments, one per input port", ninputs());
+
+    if ( (_ip_fragment) && (_mtu < 8) )
+	return errh->error("MTU must be at least 8");
+
+    if ( (_ipgw_opt || _fix_ip_src) && (_my_ip != 0) )
+	return errh->error("IPGWOptions and/or FixIPSrc operations require IPADDR to be set");
+
     return _input_specs.size() == ninputs() ? 0 : -1;
 }
 
@@ -497,6 +557,22 @@ IPRewriterBase::llrpc(unsigned command, void *data)
 	return Element::llrpc(command, data);
 }
 
+void
+IPRewriterBase::print_flow_info(IPRewriterEntry *m, click_ip *iph)
+{
+    if (!m || !iph)
+	return;
+
+    click_chatter("---->        IP Proto: %d\n", iph->ip_p);
+    click_chatter("---->        Src   IP: %s\n", m->flowid().saddr().s().c_str());
+    click_chatter("---->        Src Port: %d\n", htons(m->flowid().sport()));
+    click_chatter("---->        Dst   IP: %s\n", m->flowid().daddr().s().c_str());
+    click_chatter("---->        Dst Port: %d\n", htons(m->flowid().dport()));
+    click_chatter("---->       Direction: %s\n", m->direction()? "Response":"Forward");
+    click_chatter("----> Forward Outport: %d\n", m->output());
+    click_chatter("\n");
+}
+
 ELEMENT_REQUIRES(IPRewriterMapping IPRewriterPattern)
 ELEMENT_PROVIDES(IPRewriterBase)
 CLICK_ENDDECLS
diff --git a/elements/ip/iprewriterbase.hh b/elements/ip/iprewriterbase.hh
index b7ced3a..bfaf0e3 100644
--- a/elements/ip/iprewriterbase.hh
+++ b/elements/ip/iprewriterbase.hh
@@ -140,6 +140,21 @@ class IPRewriterBase : public Element { public:
     uint32_t _gc_interval_sec;
     Timer _gc_timer;
 
+    // SNF extensions: IP Rewriter can possibly apply these operations
+    bool _drop_bcast;           // DropBroadcast
+    bool _ipgw_opt;             // IPGWOptions
+    bool _fix_ip_src;           // FixIPSrc
+    bool _ip_fragment;          // IPFragmenter
+    bool _dec_ip_ttl;           // DecIPTTL
+    bool _ip_out_combo;         // DropBroadcast + IPGWOptions + FixIPSrc + DecIPTTL
+    bool _calc_checksum;
+
+    struct in_addr _my_ip;      // For IPGWOptions, FixIPSrc
+    unsigned       _mtu;        // For IP Fragmenter
+    unsigned       _headroom;
+    bool           _honor_df;
+    bool           _verbose;
+
     enum {
 	default_timeout = 300,	   // 5 minutes
 	default_guarantee = 5,	   // 5 seconds
@@ -171,6 +186,8 @@ class IPRewriterBase : public Element { public:
     friend int IPRewriterInput::rewrite_flowid(const IPFlowID &flowid,
 			IPFlowID &rewritten_flowid, Packet *p, int mapid);
 
+    void print_flow_info(IPRewriterEntry *m, click_ip *iph);
+
   private:
 
     void shift_heap_best_effort(click_jiffies_t now_j);
diff --git a/elements/ip/iprwmapping.cc b/elements/ip/iprwmapping.cc
index 966382c..766fe49 100644
--- a/elements/ip/iprwmapping.cc
+++ b/elements/ip/iprwmapping.cc
@@ -55,7 +55,7 @@ IPRewriterFlow::IPRewriterFlow(IPRewriterInput *owner, const IPFlowID &flowid,
 }
 
 void
-IPRewriterFlow::apply(WritablePacket *p, bool direction, unsigned annos)
+IPRewriterFlow::apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum)
 {
     assert(p->has_network_header());
     click_ip *iph = p->ip_header();
@@ -68,7 +68,11 @@ IPRewriterFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 	p->set_dst_ip_anno(revflow.saddr());
     if (direction && (annos & 2))
 	p->set_anno_u8(annos >> 2, _reply_anno);
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+
+    // SNF: Allow to skip IP checksum calculation
+    if ( calc_checksum ) {
+	update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+    }
 
     // end if not first fragment
     if (!IP_FIRSTFRAG(iph))
@@ -79,13 +83,20 @@ IPRewriterFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 	click_tcp *tcph = p->tcp_header();
 	tcph->th_sport = revflow.dport();
 	tcph->th_dport = revflow.sport();
-	update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+	// SNF extension: Allow to skip TCP checksum calculation
+	if ( calc_checksum ) {
+		update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+	}
     } else if (iph->ip_p == IP_PROTO_UDP) {
 	click_udp *udph = p->udp_header();
 	udph->uh_sport = revflow.dport();
 	udph->uh_dport = revflow.sport();
-	if (udph->uh_sum)	// 0 checksum is no checksum
-	    update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	if (udph->uh_sum) {	// 0 checksum is no checksum
+	    // SNF extension: Allow to skip TCP checksum calculation
+	    if ( calc_checksum ) {
+		update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	    }
+	}
     }
 }
 
diff --git a/elements/ip/iprwmapping.hh b/elements/ip/iprwmapping.hh
index 446f95b..5ee3860 100644
--- a/elements/ip/iprwmapping.hh
+++ b/elements/ip/iprwmapping.hh
@@ -135,7 +135,7 @@ class IPRewriterFlow { public:
     static inline void update_csum(uint16_t *csum, bool direction,
 				   uint16_t csum_delta);
 
-    void apply(WritablePacket *p, bool direction, unsigned annos);
+    void apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum);
 
     void unparse(StringAccum &sa, bool direction, click_jiffies_t now) const;
     void unparse_ports(StringAccum &sa, bool direction, click_jiffies_t now) const;
diff --git a/elements/tcpudp/iprewriter.cc b/elements/tcpudp/iprewriter.cc
index 0bc909b..8f153e5 100644
--- a/elements/tcpudp/iprewriter.cc
+++ b/elements/tcpudp/iprewriter.cc
@@ -2,6 +2,8 @@
  * iprewriter.{cc,hh} -- rewrites packet source and destination
  * Max Poletto, Eddie Kohler
  *
+ * 
+ *
  * Copyright (c) 2000 Massachusetts Institute of Technology
  * Copyright (c) 2008-2010 Meraki, Inc.
  *
@@ -127,6 +129,24 @@ IPRewriter::push(int port, Packet *p_in)
 	return;
     }
 
+    // SNF: Decrement IP TTL!
+    // Do it here, before jumping to either UDP or TCP
+    if ( _dec_ip_ttl ) {
+	// Safe decrement
+	if ( iph->ip_ttl > 1 ) {
+	    iph->ip_ttl --;
+	    // Checksum is not mandatory anymore
+	    if ( _calc_checksum ) {
+		unsigned long sum = (~ntohs(iph->ip_sum) & 0xFFFF) + 0xFEFF;
+		iph->ip_sum = ~htons(sum + (sum >> 16));
+	    }
+	}
+	// End flow if TTL is 0
+	else {
+	    return;
+	}
+    }
+
     IPFlowID flowid(p);
     HashContainer<IPRewriterEntry> *map = (iph->ip_p == IP_PROTO_TCP ? &_map : &_udp_map);
     IPRewriterEntry *m = map->get(flowid);
@@ -135,8 +155,10 @@ IPRewriter::push(int port, Packet *p_in)
 	IPRewriterInput &is = _input_specs.unchecked_at(port);
 	IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
 	int result = is.rewrite_flowid(flowid, rewritten_flowid, p, iph->ip_p == IP_PROTO_TCP ? 0 : IPRewriterInput::mapid_iprewriter_udp);
-	if (result == rw_addmap)
+	if (result == rw_addmap) {
 	    m = IPRewriter::add_flow(iph->ip_p, flowid, rewritten_flowid, port);
+	    //print_flow_info(m, iph);
+	}
 	if (!m) {
 	    checked_output_push(result, p);
 	    return;
@@ -148,14 +170,14 @@ IPRewriter::push(int port, Packet *p_in)
     IPRewriterFlow *mf = m->flow();
     if (iph->ip_p == IP_PROTO_TCP) {
 	TCPFlow *tcpmf = static_cast<TCPFlow *>(mf);
-	tcpmf->apply(p, m->direction(), _annos);
+	tcpmf->apply(p, m->direction(), _annos, _calc_checksum);
 	if (_timeouts[1])
 	    tcpmf->change_expiry(_heap, true, now_j + _timeouts[1]);
 	else
 	    tcpmf->change_expiry(_heap, false, now_j + tcp_flow_timeout(tcpmf));
     } else {
 	UDPFlow *udpmf = static_cast<UDPFlow *>(mf);
-	udpmf->apply(p, m->direction(), _annos);
+	udpmf->apply(p, m->direction(), _annos, _calc_checksum);
 	if (_udp_timeouts[1])
 	    udpmf->change_expiry(_heap, true, now_j + _udp_timeouts[1]);
 	else
diff --git a/elements/tcpudp/tcprewriter.cc b/elements/tcpudp/tcprewriter.cc
index 6e10003..b704312 100644
--- a/elements/tcpudp/tcprewriter.cc
+++ b/elements/tcpudp/tcprewriter.cc
@@ -84,7 +84,7 @@ TCPRewriter::TCPFlow::update_seqno_delta(bool direction,
 }
 
 void
-TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len)
+TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len, bool calc_checksum)
 {
     if ((int)(tcph->th_off << 2) < len)
 	len = tcph->th_off << 2;
@@ -106,10 +106,14 @@ TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len)
 	      } else {
 		  uint8_t *end_sack = opt + opt[1];
 
-		  // develop initial checksum value
-		  uint16_t *csum_begin = reinterpret_cast<uint16_t *>(begin_opt + ((opt + 2 - begin_opt) & ~1));
-		  for (uint16_t *csum = csum_begin; reinterpret_cast<uint8_t *>(csum) < end_sack; csum++)
-		      csum_delta += ~*csum & 0xFFFF;
+		  // SNF extension: Allow to skip TCP checksum calculation
+		  uint16_t *csum_begin= 0;
+		  if ( calc_checksum ) {
+			// develop initial checksum value
+			csum_begin = reinterpret_cast<uint16_t *>(begin_opt + ((opt + 2 - begin_opt) & ~1));
+			for (uint16_t *csum = csum_begin; reinterpret_cast<uint8_t *>(csum) < end_sack; csum++)
+				csum_delta += ~*csum & 0xFFFF;
+		  }
 
 		  for (opt += 2; opt < end_sack; opt += 8) {
 #if HAVE_INDIFFERENT_ALIGNMENT
@@ -125,10 +129,13 @@ TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len)
 #endif
 		  }
 
-		  // finish off csum_delta calculation
-		  for (uint16_t *csum = csum_begin; reinterpret_cast<uint8_t *>(csum) < end_sack; csum++)
-		      csum_delta += *csum;
-		  break;
+		  // SNF extension: Allow to skip TCP checksum calculation
+		  if ( calc_checksum ) {
+			// finish off csum_delta calculation
+			for (uint16_t *csum = csum_begin; reinterpret_cast<uint8_t *>(csum) < end_sack; csum++)
+				csum_delta += *csum;
+			break;
+		  }
 	      }
 	  default:
 	    if (opt[1] < 2)
@@ -138,7 +145,8 @@ TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len)
 	}
 
   done:
-    if (csum_delta) {
+    // SNF extension: Allow to skip TCP checksum calculation
+    if (csum_delta && !calc_checksum) {
 	uint32_t sum = (~tcph->th_sum & 0xFFFF) + csum_delta;
 	sum = (sum & 0xFFFF) + (sum >> 16);
 	tcph->th_sum = ~(sum + (sum >> 16));
@@ -146,7 +154,7 @@ TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len)
 }
 
 void
-TCPRewriter::TCPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
+TCPRewriter::TCPFlow::apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum)
 {
     assert(p->has_network_header());
     click_ip *iph = p->ip_header();
@@ -159,7 +167,11 @@ TCPRewriter::TCPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 	p->set_dst_ip_anno(revflow.saddr());
     if (direction && (annos & 2))
 	p->set_anno_u8(annos >> 2, _reply_anno);
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+
+    // SNF extension: Allow to skip IP checksum calculation
+    if ( calc_checksum ) {
+	update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+    }
 
     // end if not first fragment
     if (!IP_FIRSTFRAG(iph) || p->transport_length() < 18)
@@ -169,7 +181,10 @@ TCPRewriter::TCPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
     click_tcp *tcph = p->tcp_header();
     tcph->th_sport = revflow.dport();
     tcph->th_dport = revflow.sport();
-    update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+    // SNF extension: Allow to skip TCP checksum calculation
+    if ( calc_checksum ) {
+	update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+    }
 
     // track connection state
     bool have_payload = ((iph->ip_hl + tcph->th_off) << 2) < ntohs(iph->ip_len);
@@ -203,22 +218,28 @@ TCPRewriter::TCPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 
     if (_dt->delta[direction] || _dt->has_trigger(direction)) {
 	uint32_t newval = htonl(new_seq(direction, ntohl(tcph->th_seq)));
-	click_update_in_cksum(&tcph->th_sum, tcph->th_seq >> 16, newval >> 16);
-	click_update_in_cksum(&tcph->th_sum, tcph->th_seq, newval);
+	// SNF extension: Allow to skip TCP checksum calculation
+	if ( calc_checksum ) {
+		click_update_in_cksum(&tcph->th_sum, tcph->th_seq >> 16, newval >> 16);
+		click_update_in_cksum(&tcph->th_sum, tcph->th_seq, newval);
+	}
 	tcph->th_seq = newval;
     }
 
     if (_dt->delta[!direction] || _dt->has_trigger(!direction)) {
 	uint32_t newval = htonl(new_ack(direction, ntohl(tcph->th_ack)));
-	click_update_in_cksum(&tcph->th_sum, tcph->th_ack >> 16, newval >> 16);
-	click_update_in_cksum(&tcph->th_sum, tcph->th_ack, newval);
+	// SNF extension: Allow to skip TCP checksum calculation
+	if ( calc_checksum ) {
+		click_update_in_cksum(&tcph->th_sum, tcph->th_ack >> 16, newval >> 16);
+		click_update_in_cksum(&tcph->th_sum, tcph->th_ack, newval);
+	}
 	tcph->th_ack = newval;
 
 	// update SACK sequence numbers
 	if (tcph->th_off > 8
 	    || (tcph->th_off == 8
 		&& *(reinterpret_cast<const uint32_t *>(tcph + 1)) != htonl(0x0101080A)))
-	    apply_sack(direction, tcph, p->transport_length());
+	    apply_sack(direction, tcph, p->transport_length(), calc_checksum);
     }
 }
 
@@ -331,7 +352,7 @@ TCPRewriter::push(int port, Packet *p_in)
     }
 
     TCPFlow *mf = static_cast<TCPFlow *>(m->flow());
-    mf->apply(p, m->direction(), _annos);
+    mf->apply(p, m->direction(), _annos, _calc_checksum);
 
     click_jiffies_t now_j = click_jiffies();
     if (_timeouts[1])
diff --git a/elements/tcpudp/tcprewriter.hh b/elements/tcpudp/tcprewriter.hh
index bcae3fc..2bb8a6c 100644
--- a/elements/tcpudp/tcprewriter.hh
+++ b/elements/tcpudp/tcprewriter.hh
@@ -127,7 +127,7 @@ class TCPRewriter : public IPRewriterBase { public:
 	tcp_seq_t new_seq(bool direction, tcp_seq_t seqno) const;
 	tcp_seq_t new_ack(bool direction, tcp_seq_t seqno) const;
 
-	void apply(WritablePacket *p, bool direction, unsigned annos);
+	void apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum);
 
 	void unparse(StringAccum &sa, bool direction, click_jiffies_t now) const;
 
@@ -150,7 +150,7 @@ class TCPRewriter : public IPRewriterBase { public:
 
 	delta_transition *_dt;
 
-	void apply_sack(bool direction, click_tcp *tcp, int transport_len);
+	void apply_sack(bool direction, click_tcp *tcp, int transport_len, bool calc_checksum);
 
     };
 
diff --git a/elements/tcpudp/udprewriter.cc b/elements/tcpudp/udprewriter.cc
index b3d0f62..3dde533 100644
--- a/elements/tcpudp/udprewriter.cc
+++ b/elements/tcpudp/udprewriter.cc
@@ -27,7 +27,7 @@
 CLICK_DECLS
 
 void
-UDPRewriter::UDPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
+UDPRewriter::UDPFlow::apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum)
 {
     assert(p->has_network_header());
     click_ip *iph = p->ip_header();
@@ -40,7 +40,11 @@ UDPRewriter::UDPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 	p->set_dst_ip_anno(revflow.saddr());
     if (direction && (annos & 2))
 	p->set_anno_u8(annos >> 2, _reply_anno);
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+
+    // SNF: Allow to skip IP checksum calculation
+    if ( calc_checksum ) {
+	update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+    }
 
     // end if not first fragment
     if (!IP_FIRSTFRAG(iph))
@@ -55,8 +59,10 @@ UDPRewriter::UDPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 	    update_csum(&reinterpret_cast<click_tcp *>(udph)->th_sum, direction, _udp_csum_delta);
     } else if (iph->ip_p == IP_PROTO_UDP) {
 	if (p->transport_length() >= 8 && udph->uh_sum)
-	    // 0 checksum is no checksum
-	    update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	    // SNF: Allow to skip UDP checksum calculation
+	    if ( calc_checksum ) {
+		update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	    }
     }
 
     // track connection state
@@ -165,7 +171,7 @@ UDPRewriter::push(int port, Packet *p_in)
     }
 
     UDPFlow *mf = static_cast<UDPFlow *>(m->flow());
-    mf->apply(p, m->direction(), _annos);
+    mf->apply(p, m->direction(), _annos, _calc_checksum);
 
     click_jiffies_t now_j = click_jiffies();
     if (_timeouts[1])
diff --git a/elements/tcpudp/udprewriter.hh b/elements/tcpudp/udprewriter.hh
index 4246624..6cd0caa 100644
--- a/elements/tcpudp/udprewriter.hh
+++ b/elements/tcpudp/udprewriter.hh
@@ -175,7 +175,7 @@ class UDPRewriter : public IPRewriterBase { public:
 	    return _tflags > 6;
 	}
 
-	void apply(WritablePacket *p, bool direction, unsigned annos);
+	void apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum);
 
     };
 
diff --git a/include/click/router.hh b/include/click/router.hh
index e4eb40c..3e9c0d4 100644
--- a/include/click/router.hh
+++ b/include/click/router.hh
@@ -131,7 +131,14 @@ class Router { public:
     inline Router* hotswap_router() const;
     void set_hotswap_router(Router* router);
 
-    int initialize(ErrorHandler* errh);
+    /*
+     * SNF Modification to prevent Click from initializing the elements in this call.
+     * We simply want to have the Click DAG populated with all the elements and connections.
+     * The 2nd argument is set to false by default. This is how normal Click calls the function
+     * so it does not affect normal Click executions.
+     */
+    int initialize(ErrorHandler* errh, bool initialize_only_dag=false);
+
     void activate(bool foreground, ErrorHandler* errh);
     inline void activate(ErrorHandler* errh);
     inline void set_foreground(bool foreground);
@@ -298,6 +305,10 @@ class Router { public:
 
     Router* _next_router;
 
+    // SNF extension: If set to true, the router's elements are not initialized
+    // Router::initialize() and ~Router() use this field to properly set and reset the router
+    bool _do_not_initialize;
+
 #if CLICK_LINUXMODULE
     Vector<struct module*> _modules;
 #endif
diff --git a/lib/driver.cc b/lib/driver.cc
index c2a701f..b06bbe7 100644
--- a/lib/driver.cc
+++ b/lib/driver.cc
@@ -3,9 +3,13 @@
  * driver.cc -- support for packages
  * Eddie Kohler
  *
+ * Extensions to allow optional deactivation of the router's complete initialization
+ * Georgios Katsikas
+ *
  * Copyright (c) 2001 Mazu Networks, Inc.
  * Copyright (c) 2003 International Computer Science Institute
  * Copyright (c) 2007 Regents of the University of California
+ * Copyright (c) 2016 KTH Royal Institute of Technology
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -527,8 +531,10 @@ click_read_router(String filename, bool is_expr, ErrorHandler *errh, bool initia
     l->end_parse(cookie);
 
     // initialize if requested
+    // SNF extension: If initialize_only_dag is true, the router's elements are not initialized.
+    bool initialize_only_dag = false;
     if (initialize)
-        if (errh->nerrors() > before || router->initialize(errh) < 0) {
+        if (errh->nerrors() > before || router->initialize(errh, initialize_only_dag) < 0) {
             delete router;
             return 0;
         }
diff --git a/lib/router.cc b/lib/router.cc
index 4954ca7..650e1be 100644
--- a/lib/router.cc
+++ b/lib/router.cc
@@ -3,10 +3,14 @@
  * router.{cc,hh} -- a Click router configuration
  * Eddie Kohler
  *
+ * Extensions to allow optional deactivation of the router's complete initialization
+ * Georgios Katsikas
+ *
  * Copyright (c) 1999-2000 Massachusetts Institute of Technology
  * Copyright (c) 2000 Mazu Networks, Inc.
  * Copyright (c) 2004-2007 Regents of the University of California
  * Copyright (c) 2008 Meraki, Inc.
+ * Copyright (c) 2016 KTH Royal Institute of Technology
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -83,7 +87,8 @@ Router::Router(const String &configuration, Master *master)
       _configuration(configuration),
       _notifier_signals(0),
       _arena_factory(new HashMap_ArenaFactory),
-      _hotswap_router(0), _thread_sched(0), _name_info(0), _next_router(0)
+      _hotswap_router(0), _thread_sched(0), _name_info(0), _next_router(0),
+      _do_not_initialize(false)
 {
     _refcount = 0;
     _runcount = 0;
@@ -117,7 +122,9 @@ Router::~Router()
         for (int ord = _elements.size() - 1; ord >= 0; ord--)
             _elements[ _element_configure_order[ord] ]->cleanup(Element::CLEANUP_ROUTER_INITIALIZED);
     } else if (_state != ROUTER_DEAD) {
-        assert(_element_configure_order.size() == 0 && _state <= ROUTER_PRECONFIGURE);
+        // We do not follow all the Click states when _do_not_initialize is true
+        if (!_do_not_initialize)
+            assert(_element_configure_order.size() == 0 && _state <= ROUTER_PRECONFIGURE);
         for (int i = _elements.size() - 1; i >= 0; i--)
             _elements[i]->cleanup(Element::CLEANUP_NO_ROUTER);
     }
@@ -151,6 +158,12 @@ Router::~Router()
         delete ns;
     }
     delete _name_info;
+
+    // Return here in case that the router has been constructed by setting this member to true.
+    // In this case we haven't registered our Router in the first place.
+    if (_do_not_initialize)
+    	return;
+
     if (_master)
         _master->unregister_router(this);
 }
@@ -1085,7 +1098,7 @@ Router::initialize_handlers(bool defaults, bool specifics)
 }
 
 int
-Router::initialize(ErrorHandler *errh)
+Router::initialize(ErrorHandler *errh, bool do_not_initialize)
 {
     if (_state != ROUTER_NEW)
         return errh->error("second attempt to initialize router");
@@ -1165,6 +1178,18 @@ Router::initialize(ErrorHandler *errh)
         }
     }
 
+    //////////////////////////////////////////////////////////////////////////////
+    /*
+     * SNF modification to prevent the initialization of Click elements
+     * It happens only when the boolean argument is true. Default is false.
+     */
+    //////////////////////////////////////////////////////////////////////////////
+    if ( do_not_initialize ) {
+	// This field is useful in the destructor
+	_do_not_initialize = true;
+	return 0;
+    }
+
 #if CLICK_DMALLOC
     CLICK_DMALLOC_REG("iHoo");
 #endif
diff --git a/userlevel/click.cc b/userlevel/click.cc
index df694aa..07d662d 100644
--- a/userlevel/click.cc
+++ b/userlevel/click.cc
@@ -3,12 +3,16 @@
  * click.cc -- user-level Click main program
  * Eddie Kohler
  *
+ * Extensions to allow optional deactivation of the router's complete initialization
+ * Georgios Katsikas
+ *
  * Copyright (c) 1999-2000 Massachusetts Institute of Technology
  * Copyright (c) 2000 Mazu Networks, Inc.
  * Copyright (c) 2001-2003 International Computer Science Institute
  * Copyright (c) 2004-2006 Regents of the University of California
  * Copyright (c) 2008-2009 Meraki, Inc.
  * Copyright (c) 1999-2015 Eddie Kohler
+ * Copyright (c) 2016 KTH Royal Institute of Technology
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -60,6 +64,7 @@
 #include <click/handlercall.hh>
 #include "elements/standard/quitwatcher.hh"
 #include "elements/userlevel/controlsocket.hh"
+
 CLICK_USING_DECLS
 
 #define HELP_OPT                300
@@ -396,8 +401,9 @@ parse_configuration(const String &text, bool text_is_expr, bool hotswap,
   if (hotswap && click_router && click_router->initialized())
       router->set_hotswap_router(click_router);
 
+  bool initialize_only_dag = false;
   if (errh->nerrors() == before_errors
-      && router->initialize(errh) >= 0)
+      && router->initialize(errh, initialize_only_dag) >= 0)
     return router;
   else {
     delete router;
