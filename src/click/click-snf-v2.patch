diff --git a/elements/analysis/storeicmptimeseqrecord.cc b/elements/analysis/storeicmptimeseqrecord.cc
new file mode 100644
index 0000000..75f35f6
--- /dev/null
+++ b/elements/analysis/storeicmptimeseqrecord.cc
@@ -0,0 +1,158 @@
+/*
+Programmer: Georgios Katsikas
+ * Copyright (c) 2016 
+
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, subject to the conditions
+ * listed in the Click LICENSE file. These conditions include: you must
+ * preserve this copyright notice, and you cannot mention the copyright
+ * holders in advertising related to the Software without their permission.
+ * The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
+ * notice is a summary of the Click LICENSE file; the license in that file is
+ * legally binding.
+*/
+
+#include <click/config.h>
+#include "storeicmptimeseqrecord.hh"
+#include <click/glue.hh>
+#include <clicknet/ip.h>
+#include <clicknet/ip6.h>
+#include <clicknet/icmp.h>
+#include <clicknet/tcp.h>
+#include <click/args.hh>
+#include <click/error.hh>
+
+
+
+CLICK_DECLS
+
+/*
+ */
+StoreICMPTimeSeqRecord::StoreICMPTimeSeqRecord() {
+	_count = 0;
+	_delta = 0;
+	_offset = 0;
+}
+
+
+
+int StoreICMPTimeSeqRecord::configure(Vector<String> &conf, ErrorHandler *errh) {
+	if (Args(conf, this, errh)
+		.read_mp("OFFSET", _offset)
+		.read("DELTA", _delta)
+		.complete() < 0)
+		return -1;
+	return 0;
+}
+
+// This is the tricky bit.  We can't rely on any headers being
+// filled out if elements like CheckIPHeader have not been called
+// so we should just access the raw data and cast wisely
+Packet* StoreICMPTimeSeqRecord::simple_action(Packet *packet) {
+	WritablePacket *p = packet->uniqueify();
+	Timestamp       tnow;
+	click_icmp     *icmph = 0;
+	PData          *pData;
+	uint32_t        csum = 0;
+	uint32_t        offset = _offset;
+
+	// the packet is shared and we can't modify it without screwing
+	// things up
+	if (!p) {
+	// If uniqueify() fails, packet itself is garbage and has been deleted
+		click_chatter("Non-Writable Packet!");
+		return 0;
+	}
+
+	// get the first two words of the IP header to see what it is to determine how to proceed further
+	if (p->length() < offset + sizeof(uint32_t) * 2) {
+		p->kill();
+		return 0;
+	}
+
+	// here need to get to the right offset.  The IP header can be of variable length due to options
+	// also, the header might be IPv4 of IPv6
+	u_char version = p->data()[offset] >> 4;
+	if (version == 0x04) {
+		const click_ip *ip = reinterpret_cast<const click_ip *>(p->data() + offset);
+		offset += ip->ip_hl << 2;
+	}
+	else if (version == 0x06) {
+		// IPv6 header is
+		const click_ip6 *ip6 = reinterpret_cast<const click_ip6 *>(p->data() + offset);
+		if (ip6->ip6_nxt == 0x01) { // ICMP is the next header
+			offset += sizeof(click_ip6);
+		}
+		else { // the next header is not ICMP so stop now
+			p->kill();
+			return 0;
+		}
+	}
+	else {
+		click_chatter("Unknown IP version!");
+		p->kill();
+		return 0;
+	}
+
+	if (p->length() < offset + sizeof(click_icmp) + sizeof(PData)) {
+		//click_chatter("Packet is too short");
+		p->kill();
+		return 0;
+	}
+
+	// eth, IP, headers must be bypassed with a correct offset
+	icmph = (click_icmp*)(p->data() + offset);
+	pData = (PData*)((char*)icmph + sizeof(click_icmp));
+	csum = icmph->icmp_cksum;
+
+	// we use incremental checksum computation to patch up the checksum after
+	// the payload will get modified
+	_count++;
+	if (_delta) {
+		Timestamp ts1(ntohl(pData->data[0]), Timestamp::nsec_to_subsec(ntohl(pData->data[1])));
+		Timestamp diff = Timestamp::now() - ts1;
+
+		//click_chatter("Seq %d Time Diff sec: %d usec: %d\n", ntohl(pData->seq_num), diff.sec(), diff.nsec());
+		pData->data[2] = htonl(diff.sec());
+		pData->data[3] = htonl(diff.nsec());
+		csum += click_in_cksum((const unsigned char*)(pData->data + 2), 2 * sizeof(uint32_t));
+	}
+	else {
+		tnow = Timestamp::now();
+
+		// subtract the previous contribution from CHECKSUM in case PData values are non-zero
+		csum -= click_in_cksum((const unsigned char*)pData, sizeof(PData));
+		pData->seq_num = htonl(_count);
+		pData->data[0] = htonl(tnow.sec());
+		pData->data[1] = htonl(tnow.nsec());
+		pData->data[2] = 0;
+		pData->data[3] = 0;
+		csum += click_in_cksum((const unsigned char*)pData, sizeof(PData));
+	}
+
+	csum = (0xFFFF & csum) + ((0xFFFF0000 & csum) >> 16);
+	csum = (csum != 0xFFFF) ? csum : 0;
+
+	// now that we modified the packet it is time to fix up the
+	// csum of the header.
+	icmph->icmp_cksum = (uint16_t)csum;
+
+	return p;
+}
+
+
+int StoreICMPTimeSeqRecord::reset_handler(const String &, Element *e, void *, ErrorHandler *) {
+	StoreICMPTimeSeqRecord *t = (StoreICMPTimeSeqRecord *) e;
+
+	t->_count = 0;
+	return 0;
+}
+
+void StoreICMPTimeSeqRecord::add_handlers() {
+	add_data_handlers("count", Handler::f_read, &_count);
+	add_write_handler("reset", reset_handler);
+}
+
+CLICK_ENDDECLS
+EXPORT_ELEMENT(StoreICMPTimeSeqRecord)
diff --git a/elements/analysis/storeicmptimeseqrecord.hh b/elements/analysis/storeicmptimeseqrecord.hh
new file mode 100644
index 0000000..977d683
--- /dev/null
+++ b/elements/analysis/storeicmptimeseqrecord.hh
@@ -0,0 +1,108 @@
+// -*- c-basic-offset: 4 -*-
+/*
+Programmer: Georgios Katsikas
+ * Copyright (c) 2016 
+
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, subject to the conditions
+ * listed in the Click LICENSE file. These conditions include: you must
+ * preserve this copyright notice, and you cannot mention the copyright
+ * holders in advertising related to the Software without their permission.
+ * The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
+ * notice is a summary of the Click LICENSE file; the license in that file is
+ * legally binding.
+*/
+#ifndef CLICK_STOREICMPTIMESEQRECORD_HH
+#define CLICK_STOREICMPTIMESEQRECORD_HH
+#include <click/element.hh>
+
+CLICK_DECLS
+
+/*
+=c
+
+StoreICMPTimeSeqRecord([I<keywords> OFFSET, DELTA])
+
+=s timestamps
+
+=d
+
+StoreICMPTimeSeqRecord element can be handy when computing end-to-end ICMP packet
+delays.  The element embeds a timestamp and a sequence number into a packet and
+adjusts the checksum of the ICMP packet.  Once the initial timestamp has been
+placed into the payload of the ICMP packet, a time difference can be computed
+once a packet passes through another StoreICMPTimeSeqRecord element.  The data can be
+accessed by examining the packet payload (e.g., do a tcpdump and then do post
+processing of the data).  The element uses partial checksums to speed up the
+processing.  The element works with IPv4 and IPv6 packets. In case of IPv6,
+it assumes that the next header field is ICMP.  If this is not the case, the
+element will discard the packet.
+
+Packet payload found after the ICMP header.  Note, the ICMP payload must be at least
+22 bytes long.  The values will be stored in network byte order.
+
+uint32_t seq_num
+uint32_t initial_second
+uint32_t initial_nano_second
+uint32_t difference_second
+uint32_t difference_nano_second
+
+Keyword arguments are:
+
+=over 2
+
+=item OFFSET
+
+Number of bytes to offset from the beginning of the packet where the IPv4/6 header can be found.
+If raw Ethernet packets are fed into this element, then OFFSET needs to be 14.
+
+=item DELTA
+
+Determines which time values are set. If DELTA is false (the default), then the initial_second
+and initial_nano_second values are set to the current time, and the difference values are set to 0.
+If DELTA is true, then the initial values are left as is, and the difference values are set to
+the difference between the current time and the packet's initial time.
+
+=back
+
+=e
+    src :: RatedSource(\<00>, LENGTH 22, RATE 1, LIMIT 100)
+        -> ICMPIPEncap(10.0.1.1, 20.0.0.2)
+        -> EtherEncap(0x0800, 00:04:23:D0:93:63, 00:17:cb:0d:f8:db)
+        -> StoreICMPTimeSeqRecord(OFFSET 14, DELTA false)
+        -> DelayShaper(100msec)
+        -> StoreICMPTimeSeqRecord(OFFSET 14, DELTA true)
+        -> ToDump("dump.dmp");
+*/
+class StoreICMPTimeSeqRecord : public Element {
+	public:
+		StoreICMPTimeSeqRecord() CLICK_COLD;
+
+		const char *class_name() const	{ return "StoreICMPTimeSeqRecord"; }
+		const char *port_count() const	{ return PORTS_1_1; }
+
+		void add_handlers() CLICK_COLD;
+		int  configure(Vector<String> &conf, ErrorHandler *errh) CLICK_COLD;
+
+		Packet *simple_action(Packet *);
+
+		// packet data payload access struct
+		// Header | PDATA | rest of data
+		// This comes out to 22 bytes which will fit into the smallest Ethernet frame
+		struct PData {
+			uint32_t seq_num;
+			uint32_t data[4];
+		};
+
+	private:
+		unsigned long _count;
+		bool          _delta;  // if true put in_timestamp else out_timestamp
+		uint32_t      _offset; //how much to shift to get to the IPv4/v6 header
+
+		static String read_handler(Element *, void *) CLICK_COLD;
+		static int    reset_handler(const String &, Element *, void *, ErrorHandler *);
+};
+
+CLICK_ENDDECLS
+#endif
diff --git a/elements/analysis/storetcptimeseqrecord.cc b/elements/analysis/storetcptimeseqrecord.cc
new file mode 100644
index 0000000..50fe1f8
--- /dev/null
+++ b/elements/analysis/storetcptimeseqrecord.cc
@@ -0,0 +1,153 @@
+/*
+Programmer: Georgios Katsikas
+ * Copyright (c) 2016 
+
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, subject to the conditions
+ * listed in the Click LICENSE file. These conditions include: you must
+ * preserve this copyright notice, and you cannot mention the copyright
+ * holders in advertising related to the Software without their permission.
+ * The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
+ * notice is a summary of the Click LICENSE file; the license in that file is
+ * legally binding.
+*/
+
+#include <click/config.h>
+#include "storetcptimeseqrecord.hh"
+#include <click/glue.hh>
+#include <clicknet/ip.h>
+#include <clicknet/ip6.h>
+#include <clicknet/tcp.h>
+#include <click/args.hh>
+#include <click/error.hh>
+
+CLICK_DECLS
+
+/*
+ */
+StoreTCPTimeSeqRecord::StoreTCPTimeSeqRecord() {
+	_count = 0;
+	_delta = 0;
+	_offset = 0;
+}
+
+int StoreTCPTimeSeqRecord::configure(Vector<String> &conf, ErrorHandler *errh) {
+	if (Args(conf, this, errh)
+		.read_mp("OFFSET", _offset)
+		.read("DELTA", _delta)
+		.complete() < 0)
+		return -1;
+	return 0;
+}
+
+// This is the tricky bit.  We can't rely on any headers being
+// filled out if elements like CheckIPHeader have not been called
+// so we should just access the raw data and cast wisely
+Packet* StoreTCPTimeSeqRecord::simple_action(Packet *packet) {
+	WritablePacket *p = packet->uniqueify();
+	Timestamp      tnow;
+	click_tcp      *tcph = 0;
+	PData          *pData;
+	uint32_t       csum = 0;
+	uint32_t       offset = _offset;
+
+	// the packet is shared and we can't modify it without screwing
+	// things up
+	if (!p) {
+	// If uniqueify() fails, packet itself is garbage and has been deleted
+		click_chatter("Non-Writable Packet!");
+		return 0;
+	}
+
+	// get the first two words of the IP header to see what it is to determine how to proceed further
+	if (p->length() < offset + sizeof(uint32_t) * 2) {
+		p->kill();
+		return 0;
+	}
+
+	// here need to get to the right offset.  The IP header can be of variable length due to options
+	// also, the header might be IPv4 of IPv6
+	u_char version = p->data()[offset] >> 4;
+	if (version == 0x04) {
+		const click_ip *ip = reinterpret_cast<const click_ip *>(p->data() + offset);
+		offset += ip->ip_hl << 2;
+	}
+	else if (version == 0x06) {
+		// IPv6 header is
+		const click_ip6 *ip6 = reinterpret_cast<const click_ip6 *>(p->data() + offset);
+		if (ip6->ip6_nxt == 0x06) { // TCP is the next header
+			offset += sizeof(click_ip6);
+		}
+		else { // the next header is not TCP so stop now
+			p->kill();
+			return 0;
+		}
+	}
+	else {
+		click_chatter("Unknown IP version!");
+		p->kill();
+		return 0;
+	}
+
+	if (p->length() < offset + sizeof(click_tcp) + sizeof(PData)) {
+		//click_chatter("Packet is too short");
+		p->kill();
+		return 0;
+	}
+
+	// eth, IP, headers must be bypassed with a correct offset
+	tcph = (click_tcp*)(p->data() + offset);
+	pData = (PData*)((char*)tcph + sizeof(click_tcp));
+	csum = tcph->th_sum;
+
+	// we use incremental checksum computation to patch up the checksum after
+	// the payload will get modified
+	_count++;
+	if (_delta) {
+		Timestamp ts1(ntohl(pData->data[0]), Timestamp::nsec_to_subsec(ntohl(pData->data[1])));
+		Timestamp diff = Timestamp::now() - ts1;
+
+		//click_chatter("Seq %d Time Diff sec: %d usec: %d\n", ntohl(pData->seq_num), diff.sec(), diff.nsec());
+		pData->data[2] = htonl(diff.sec());
+		pData->data[3] = htonl(diff.nsec());
+		csum += click_in_cksum((const unsigned char*)(pData->data + 2), 2 * sizeof(uint32_t));
+	}
+	else {
+		tnow = Timestamp::now();
+
+		// subtract the previous contribution from CHECKSUM in case PData values are non-zero
+		csum -= click_in_cksum((const unsigned char*)pData, sizeof(PData));
+		pData->seq_num = htonl(_count);
+		pData->data[0] = htonl(tnow.sec());
+		pData->data[1] = htonl(tnow.nsec());
+		pData->data[2] = 0;
+		pData->data[3] = 0;
+		csum += click_in_cksum((const unsigned char*)pData, sizeof(PData));
+	}
+
+	csum = (0xFFFF & csum) + ((0xFFFF0000 & csum) >> 16);
+	csum = (csum != 0xFFFF) ? csum : 0;
+
+	// now that we modified the packet it is time to fix up the
+	// csum of the header.
+	tcph->th_sum = (uint16_t)csum;
+
+	return p;
+}
+
+
+int StoreTCPTimeSeqRecord::reset_handler(const String &, Element *e, void *, ErrorHandler *) {
+	StoreTCPTimeSeqRecord *t = (StoreTCPTimeSeqRecord *) e;
+
+	t->_count = 0;
+	return 0;
+}
+
+void StoreTCPTimeSeqRecord::add_handlers() {
+	add_data_handlers("count", Handler::f_read, &_count);
+	add_write_handler("reset", reset_handler);
+}
+
+CLICK_ENDDECLS
+EXPORT_ELEMENT(StoreTCPTimeSeqRecord)
diff --git a/elements/analysis/storetcptimeseqrecord.hh b/elements/analysis/storetcptimeseqrecord.hh
new file mode 100644
index 0000000..5aa8883
--- /dev/null
+++ b/elements/analysis/storetcptimeseqrecord.hh
@@ -0,0 +1,99 @@
+// -*- c-basic-offset: 4 -*-
+/*
+Programmer: Georgios Katsikas
+ * Copyright (c) 2016 
+
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, subject to the conditions
+ * listed in the Click LICENSE file. These conditions include: you must
+ * preserve this copyright notice, and you cannot mention the copyright
+ * holders in advertising related to the Software without their permission.
+ * The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
+ * notice is a summary of the Click LICENSE file; the license in that file is
+ * legally binding.
+*/
+#ifndef CLICK_STORETCPTIMESEQRECORD_HH
+#define CLICK_STORETCPTIMESEQRECORD_HH
+#include <click/element.hh>
+
+CLICK_DECLS
+
+/*
+=c
+
+StoreTCPTimeSeqRecord([I<keywords> OFFSET, DELTA])
+
+=s timestamps
+
+=d
+
+StoreTCPTimeSeqRecord element can be handy when computing end-to-end TCP packet
+delays.  The element embeds a timestamp and a sequence number into a packet and
+adjusts the checksum of the TCP packet.  Once the initial timestamp has been
+placed into the payload of the TCP packet, a time difference can be computed
+once a packet passes through another StoreTCPTimeSeqRecord element.  The data can be
+accessed by examining the packet payload (e.g., do a tcpdump and then do post
+processing of the data).  The element uses partial checksums to speed up the
+processing.  The element works with IPv4 and IPv6 packets. In case of IPv6,
+it assumes that the next header field is TCP.  If this is not the case, the
+element will discard the packet.
+
+Packet payload found after the TCP header.  Note, the TCP payload must be at least
+22 bytes long.  The values will be stored in network byte order.
+
+uint32_t seq_num
+uint32_t initial_second
+uint32_t initial_nano_second
+uint32_t difference_second
+uint32_t difference_nano_second
+
+Keyword arguments are:
+
+=over 2
+
+=item OFFSET
+
+Number of bytes to offset from the beginning of the packet where the IPv4/6 header can be found.
+If raw Ethernet packets are fed into this element, then OFFSET needs to be 14.
+
+=item DELTA
+
+Determines which time values are set. If DELTA is false (the default), then the initial_second
+and initial_nano_second values are set to the current time, and the difference values are set to 0.
+If DELTA is true, then the initial values are left as is, and the difference values are set to
+the difference between the current time and the packet's initial time.
+
+=back
+*/
+class StoreTCPTimeSeqRecord : public Element {
+	public:
+		StoreTCPTimeSeqRecord() CLICK_COLD;
+
+		const char *class_name() const	{ return "StoreTCPTimeSeqRecord"; }
+		const char *port_count() const	{ return PORTS_1_1; }
+
+		void add_handlers() CLICK_COLD;
+		int  configure(Vector<String> &conf, ErrorHandler *errh) CLICK_COLD;
+
+		Packet *simple_action(Packet *);
+
+		// packet data payload access struct
+		// Header | PDATA | rest of data
+		// This comes out to 22 bytes which will fit into the smallest Ethernet frame
+		struct PData {
+			uint32_t seq_num;
+			uint32_t data[4];
+		};
+
+	private:
+		unsigned long _count;
+		bool          _delta;  // if true put in_timestamp else out_timestamp
+		uint32_t      _offset; //how much to shift to get to the IPv4/v6 header
+
+		static String read_handler(Element *, void *) CLICK_COLD;
+		static int    reset_handler(const String &, Element *, void *, ErrorHandler *);
+};
+
+CLICK_ENDDECLS
+#endif
diff --git a/elements/icmp/icmprewriter.cc b/elements/icmp/icmprewriter.cc
index 28de1db..e780844 100644
--- a/elements/icmp/icmprewriter.cc
+++ b/elements/icmp/icmprewriter.cc
@@ -43,6 +43,7 @@ ICMPRewriter::configure(Vector<String> &conf, ErrorHandler *errh)
     if (Args(conf, this, errh)
 	.read_mp("MAPS", AnyArg(), arg)
 	.read("DST_ANNO", dst_anno)
+	.read("CALC_CHECKSUM", _calc_checksum)
 	.read("REPLY_ANNO", AnnoArg(1), reply_anno).read_status(has_reply_anno)
 	.complete() < 0)
 	return -1;
@@ -163,7 +164,9 @@ ICMPRewriter::handle(WritablePacket *p)
 	click_ip *iph = p->ip_header();
 	memcpy(old_hw, &iph->ip_dst, 4);
 	iph->ip_dst = new_flowid.daddr();
-	update_in_cksum(&iph->ip_sum, old_hw, reinterpret_cast<const uint16_t *>(&iph->ip_dst), 2);
+	if ( _calc_checksum ) {
+		update_in_cksum(&iph->ip_sum, old_hw, reinterpret_cast<const uint16_t *>(&iph->ip_dst), 2);
+	}
 	if (_annos & 1)
 	    p->set_dst_ip_anno(new_flowid.daddr());
     }
@@ -176,7 +179,9 @@ ICMPRewriter::handle(WritablePacket *p)
     enc_iph->ip_src = new_flowid.daddr();
     enc_iph->ip_dst = new_flowid.saddr(); // XXX source routing
     memcpy(&new_hw[1], &enc_iph->ip_src, 8);
-    update_in_cksum(&enc_iph->ip_sum, old_hw + 1, new_hw + 1, 4);
+    if ( _calc_checksum ) {
+	update_in_cksum(&enc_iph->ip_sum, old_hw + 1, new_hw + 1, 4);
+    }
     new_hw[0] = enc_iph->ip_sum;
     nhw = 5;
 
@@ -200,7 +205,9 @@ ICMPRewriter::handle(WritablePacket *p)
 		enc_csum = &(reinterpret_cast<click_udp *>(enc_transp)->uh_sum);
 	    if (enc_csum) {
 		old_hw[nhw] = *enc_csum;
-		update_in_cksum(enc_csum, old_hw + 1, new_hw + 1, nhw - 1);
+		if ( _calc_checksum ) {
+			update_in_cksum(enc_csum, old_hw + 1, new_hw + 1, nhw - 1);
+		}
 		new_hw[nhw] = *enc_csum;
 		nhw++;
 	    }
@@ -211,15 +218,19 @@ ICMPRewriter::handle(WritablePacket *p)
 	    enc_icmph->icmp_identifier = new_hw[nhw] = new_flowid.dport();
 	    nhw++;
 	    old_hw[nhw] = enc_icmph->icmp_cksum;
-	    click_update_in_cksum(&enc_icmph->icmp_cksum, old_hw[nhw-1], new_hw[nhw-1]);
-	    click_update_zero_in_cksum(&enc_icmph->icmp_cksum, enc_transp, p->end_data() - enc_transp);
+	    if ( _calc_checksum ) {
+		click_update_in_cksum(&enc_icmph->icmp_cksum, old_hw[nhw-1], new_hw[nhw-1]);
+		click_update_zero_in_cksum(&enc_icmph->icmp_cksum, enc_transp, p->end_data() - enc_transp);
+	    }
 	    new_hw[nhw] = enc_icmph->icmp_cksum;
 	    nhw++;
 	}
     }
 
     // patch outer ICMP checksum
-    update_in_cksum(&icmph->icmp_cksum, old_hw, new_hw, nhw);
+    if ( _calc_checksum ) {
+	update_in_cksum(&icmph->icmp_cksum, old_hw, new_hw, nhw);
+    }
 
     if (_maps[mapid]._port_offset >= 0)
 	return _maps[mapid]._port_offset + entry->output();
diff --git a/elements/icmp/icmprewriter.hh b/elements/icmp/icmprewriter.hh
index 4ae7236..598ef64 100644
--- a/elements/icmp/icmprewriter.hh
+++ b/elements/icmp/icmprewriter.hh
@@ -86,6 +86,9 @@ class ICMPRewriter : public Element { public:
     Vector<MapEntry> _maps;
     unsigned _annos;
 
+    // SNF: Make the Checksum calculation optional
+    bool _calc_checksum;
+
     void rewrite_packet(WritablePacket *, click_ip *, click_udp *,
 			const IPFlowID &, IPRewriterEntry *);
     void rewrite_ping_packet(WritablePacket *, click_ip *, click_icmp_echo *,
diff --git a/elements/ip/decipttl.cc b/elements/ip/decipttl.cc
index cdc8dca..86e1a78 100644
--- a/elements/ip/decipttl.cc
+++ b/elements/ip/decipttl.cc
@@ -24,7 +24,7 @@
 CLICK_DECLS
 
 DecIPTTL::DecIPTTL()
-    : _active(true), _multicast(true)
+    : _active(true), _multicast(true), _calc_checksum(true)
 {
     _drops = 0;
 }
@@ -37,8 +37,9 @@ int
 DecIPTTL::configure(Vector<String> &conf, ErrorHandler *errh)
 {
     return Args(conf, this, errh)
-	.read("ACTIVE", _active)
-	.read("MULTICAST", _multicast).complete();
+	.read("ACTIVE",        _active)
+	.read("CALC_CHECKSUM", _calc_checksum)
+	.read("MULTICAST",     _multicast).complete();
 }
 
 Packet *
@@ -51,6 +52,7 @@ DecIPTTL::simple_action(Packet *p)
     if (!_multicast && IPAddress(ip_in->ip_dst).is_multicast())
 	return p;
 
+    // Time to drop
     if (ip_in->ip_ttl <= 1) {
 	++_drops;
 	checked_output_push(1, p);
@@ -60,7 +62,13 @@ DecIPTTL::simple_action(Packet *p)
 	if (!q)
 	    return 0;
 	click_ip *ip = q->ip_header();
-	--ip->ip_ttl;
+
+	// Decrement
+	ip->ip_ttl --;
+
+	// SNF: Do not calculate IP checksum if you are requested to do so
+	if ( !_calc_checksum )
+		return q;
 
 	// 19.Aug.1999 - incrementally update IP checksum as suggested by SOSP
 	// reviewers, according to RFC1141, as updated by RFC1624.
@@ -81,6 +89,7 @@ DecIPTTL::add_handlers()
 {
     add_data_handlers("drops", Handler::OP_READ, &_drops);
     add_data_handlers("active", Handler::OP_READ | Handler::OP_WRITE | Handler::CHECKBOX, &_active);
+    add_data_handlers("calc_checksum", Handler::OP_READ | Handler::OP_WRITE | Handler::CHECKBOX, &_calc_checksum);
 }
 
 CLICK_ENDDECLS
diff --git a/elements/ip/decipttl.hh b/elements/ip/decipttl.hh
index b2ff703..7f5aa4a 100644
--- a/elements/ip/decipttl.hh
+++ b/elements/ip/decipttl.hh
@@ -62,6 +62,8 @@ class DecIPTTL : public Element { public:
     bool _active;
     bool _multicast;
 
+    // SNF: Make the Checksum calculation optional
+    bool _calc_checksum;
 };
 
 CLICK_ENDDECLS
diff --git a/elements/ip/ipaddrpairrewriter.cc b/elements/ip/ipaddrpairrewriter.cc
index 05ac76f..7b43032 100644
--- a/elements/ip/ipaddrpairrewriter.cc
+++ b/elements/ip/ipaddrpairrewriter.cc
@@ -27,7 +27,7 @@ CLICK_DECLS
 
 void
 IPAddrPairRewriter::IPAddrPairFlow::apply(WritablePacket *p, bool direction,
-					  unsigned annos)
+					  unsigned annos, bool calc_checksum)
 {
     assert(p->has_network_header());
     click_ip *iph = p->ip_header();
@@ -40,18 +40,29 @@ IPAddrPairRewriter::IPAddrPairFlow::apply(WritablePacket *p, bool direction,
 	p->set_dst_ip_anno(revflow.saddr());
     if (direction && (annos & 2))
 	p->set_anno_u8(annos >> 2, _reply_anno);
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+
+    // SNF: Allow to skip IP checksum calculation
+    if ( calc_checksum ) {
+	update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+    }
 
     // UDP/TCP header
     if (!IP_FIRSTFRAG(iph))
 	/* do nothing */;
     else if (iph->ip_p == IP_PROTO_TCP && p->transport_length() >= 18) {
 	click_tcp *tcph = p->tcp_header();
-	update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+	// SNF extension: Allow to skip TCP checksum calculation
+	if ( calc_checksum ) {
+		update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+	}
     } else if (iph->ip_p == IP_PROTO_UDP && p->transport_length() >= 8) {
 	click_udp *udph = p->udp_header();
-	if (udph->uh_sum)	// 0 checksum is no checksum
-	    update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	if (udph->uh_sum) {	// 0 checksum is no checksum
+	    // SNF extension: Allow to skip UDP checksum calculation
+	    if ( calc_checksum ) {
+	    	update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	    }
+	}
     }
 }
 
@@ -155,7 +166,7 @@ IPAddrPairRewriter::push(int port, Packet *p_in)
     }
 
     IPAddrPairFlow *mf = static_cast<IPAddrPairFlow *>(m->flow());
-    mf->apply(p, m->direction(), _annos);
+    mf->apply(p, m->direction(), _annos, _calc_checksum);
     mf->change_expiry_by_timeout(_heap, click_jiffies(), _timeouts);
     output(m->output()).push(p);
 }
diff --git a/elements/ip/ipaddrpairrewriter.hh b/elements/ip/ipaddrpairrewriter.hh
index 27921a0..3289ed7 100644
--- a/elements/ip/ipaddrpairrewriter.hh
+++ b/elements/ip/ipaddrpairrewriter.hh
@@ -125,7 +125,7 @@ class IPAddrPairRewriter : public IPRewriterBase { public:
 			     0, guaranteed, expiry_j) {
 	}
 
-	void apply(WritablePacket *p, bool direction, unsigned annos);
+	void apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum);
 
 	void unparse(StringAccum &sa, bool direction, click_jiffies_t now) const;
 
diff --git a/elements/ip/ipaddrrewriter.cc b/elements/ip/ipaddrrewriter.cc
index 868513e..773f0b9 100644
--- a/elements/ip/ipaddrrewriter.cc
+++ b/elements/ip/ipaddrrewriter.cc
@@ -27,7 +27,7 @@ CLICK_DECLS
 
 void
 IPAddrRewriter::IPAddrFlow::apply(WritablePacket *p, bool direction,
-				  unsigned annos)
+				  unsigned annos, bool calc_checksum)
 {
     assert(p->has_network_header());
     click_ip *iph = p->ip_header();
@@ -43,18 +43,29 @@ IPAddrRewriter::IPAddrFlow::apply(WritablePacket *p, bool direction,
 	if (annos & 2)
 	    p->set_anno_u8(annos >> 2, _reply_anno);
     }
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+
+    // SNF: Allow to skip IP checksum calculation
+    if ( calc_checksum ) {
+	    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+    }
 
     // UDP/TCP header
     if (!IP_FIRSTFRAG(iph))
 	/* do nothing */;
     else if (iph->ip_p == IP_PROTO_TCP && p->transport_length() >= 18) {
 	click_tcp *tcph = p->tcp_header();
-	update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+	// SNF extension: Allow to skip TCP checksum calculation
+	if ( calc_checksum ) {
+		update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+	}
     } else if (iph->ip_p == IP_PROTO_UDP && p->transport_length() >= 8) {
 	click_udp *udph = p->udp_header();
-	if (udph->uh_sum)	// 0 checksum is no checksum
-	    update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	if (udph->uh_sum) {	// 0 checksum is no checksum
+	    // SNF extension: Allow to skip UDP checksum calculation
+	    if ( calc_checksum ) {
+	    	update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	    }
+	}
     }
 }
 
@@ -166,7 +177,7 @@ IPAddrRewriter::push(int port, Packet *p_in)
     }
 
     IPAddrFlow *mf = static_cast<IPAddrFlow *>(m->flow());
-    mf->apply(p, m->direction(), _annos);
+    mf->apply(p, m->direction(), _annos, _calc_checksum);
     mf->change_expiry_by_timeout(_heap, click_jiffies(), _timeouts);
     output(m->output()).push(p);
 }
diff --git a/elements/ip/ipaddrrewriter.hh b/elements/ip/ipaddrrewriter.hh
index edf6357..fe331c7 100644
--- a/elements/ip/ipaddrrewriter.hh
+++ b/elements/ip/ipaddrrewriter.hh
@@ -124,7 +124,7 @@ class IPAddrRewriter : public IPRewriterBase { public:
 			     0, guaranteed, expiry_j) {
 	}
 
-	void apply(WritablePacket *p, bool direction, unsigned annos);
+	void apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum);
 
 	void unparse(StringAccum &sa, bool direction, click_jiffies_t now) const;
 
diff --git a/elements/ip/ipfilter.cc b/elements/ip/ipfilter.cc
index beafd02..fa1a584 100644
--- a/elements/ip/ipfilter.cc
+++ b/elements/ip/ipfilter.cc
@@ -55,7 +55,10 @@ static const StaticNameDB::Entry type_entries[] = {
     { "type", IPFilter::FIELD_ICMP_TYPE },
     { "unfrag", IPFilter::TYPE_IPUNFRAG },
     { "vers", IPFilter::FIELD_VERSION },
-    { "win", IPFilter::FIELD_TCP_WIN }
+    { "win", IPFilter::FIELD_TCP_WIN },
+    /* Fields IP_SRC and IP_DST added for SNF */
+    { "src", IPFilter::FIELD_IP_SRC},
+    { "dst", IPFilter::FIELD_IP_DST}
 };
 
 static const StaticNameDB::Entry tcp_opt_entries[] = {
@@ -294,6 +297,9 @@ IPFilter::Primitive::unparse_type(int srcdst, int type)
        case FIELD_TTL: sa << "ip ttl"; break;
        case FIELD_TCP_WIN: sa << "tcp win"; break;
        case FIELD_ICMP_TYPE: sa << "icmp type"; break;
+       /* Fields IP_SRC and IP_DST added for SNF */
+       case FIELD_IP_SRC: sa << "ip src"; break;
+       case FIELD_IP_DST: sa << "ip dst"; break;
        default:
 	if (type & FIELD_PROTO_MASK)
 	  sa << unparse_transp_proto((type & FIELD_PROTO_MASK) >> FIELD_PROTO_SHIFT);
diff --git a/elements/ip/ipfilter.hh b/elements/ip/ipfilter.hh
index 25b63af..ddaffee 100644
--- a/elements/ip/ipfilter.hh
+++ b/elements/ip/ipfilter.hh
@@ -177,7 +177,10 @@ class IPFilter : public Element { public:
 	FIELD_DSCP	= (TYPE_FIELD | ((1*8) << FIELD_OFFSET_SHIFT) | 5),
 	FIELD_TTL	= (TYPE_FIELD | ((8*8) << FIELD_OFFSET_SHIFT) | 7),
 	FIELD_TCP_WIN = (TYPE_FIELD | (IP_PROTO_TCP << FIELD_PROTO_SHIFT) | ((14*8) << FIELD_OFFSET_SHIFT) | 15),
-	FIELD_ICMP_TYPE = (TYPE_FIELD | (IP_PROTO_ICMP << FIELD_PROTO_SHIFT) | (0 << FIELD_OFFSET_SHIFT) | 7)
+	FIELD_ICMP_TYPE = (TYPE_FIELD | (IP_PROTO_ICMP << FIELD_PROTO_SHIFT) | (0 << FIELD_OFFSET_SHIFT) | 7),
+        /* Fields IP_SRC and IP_DST added for SNF */
+        FIELD_IP_SRC = (TYPE_FIELD | ((12*8) << FIELD_OFFSET_SHIFT) | 31),
+        FIELD_IP_DST = (TYPE_FIELD | ((16*8) << FIELD_OFFSET_SHIFT) | 31),
     };
 
     enum {
diff --git a/elements/ip/iprewriterbase.cc b/elements/ip/iprewriterbase.cc
index 50e3f34..f002f82 100644
--- a/elements/ip/iprewriterbase.cc
+++ b/elements/ip/iprewriterbase.cc
@@ -65,10 +65,11 @@ IPMapper::rewrite_flowid(IPRewriterInput *, const IPFlowID &, IPFlowID &,
 
 //
 // IPRewriterBase
+// SNF extension: Set the checksum calculation parameter to true by default
 //
 
 IPRewriterBase::IPRewriterBase()
-    : _map(0), _heap(new IPRewriterHeap), _gc_timer(gc_timer_hook, this)
+    : _map(0), _heap(new IPRewriterHeap), _gc_timer(gc_timer_hook, this), _calc_checksum(true), _dec_ip_ttl(false)
 {
     _timeouts[0] = default_timeout;
     _timeouts[1] = default_guarantee;
@@ -158,6 +159,9 @@ IPRewriterBase::configure(Vector<String> &conf, ErrorHandler *errh)
 	.read("GUARANTEE", SecondsArg(), _timeouts[1])
 	.read("REAP_INTERVAL", SecondsArg(), _gc_interval_sec)
 	.read("REAP_TIME", Args::deprecated, SecondsArg(), _gc_interval_sec)
+	// SNF extra arguments
+	.read("CALC_CHECKSUM", _calc_checksum)
+	.read("DEC_IP_TTL", _dec_ip_ttl)
 	.consume() < 0)
 	return -1;
 
diff --git a/elements/ip/iprewriterbase.hh b/elements/ip/iprewriterbase.hh
index b7ced3a..3d68abb 100644
--- a/elements/ip/iprewriterbase.hh
+++ b/elements/ip/iprewriterbase.hh
@@ -140,6 +140,13 @@ class IPRewriterBase : public Element { public:
     uint32_t _gc_interval_sec;
     Timer _gc_timer;
 
+    // SNF extension: Read one extra input argument to allow
+    // skipping IP/TCP/UDP checksum calculation
+    bool _calc_checksum;
+
+    // SNF extension: IP Rewriter can possibly decrement IP TTL field
+    bool _dec_ip_ttl;
+
     enum {
 	default_timeout = 300,	   // 5 minutes
 	default_guarantee = 5,	   // 5 seconds
diff --git a/elements/ip/iprwmapping.cc b/elements/ip/iprwmapping.cc
index 966382c..329036a 100644
--- a/elements/ip/iprwmapping.cc
+++ b/elements/ip/iprwmapping.cc
@@ -40,6 +40,9 @@ IPRewriterFlow::IPRewriterFlow(IPRewriterInput *owner, const IPFlowID &flowid,
       _guaranteed(guaranteed), _reply_anno(0),
       _owner(owner)
 {
+    //printf("Forward Port: %d\n", owner->foutput);
+    //printf("Reverse Port: %d\n", owner->routput);
+
     _e[0].initialize(flowid, owner->foutput, false);
     _e[1].initialize(rewritten_flowid.reverse(), owner->routput, true);
 
@@ -55,7 +58,7 @@ IPRewriterFlow::IPRewriterFlow(IPRewriterInput *owner, const IPFlowID &flowid,
 }
 
 void
-IPRewriterFlow::apply(WritablePacket *p, bool direction, unsigned annos)
+IPRewriterFlow::apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum)
 {
     assert(p->has_network_header());
     click_ip *iph = p->ip_header();
@@ -68,7 +71,11 @@ IPRewriterFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 	p->set_dst_ip_anno(revflow.saddr());
     if (direction && (annos & 2))
 	p->set_anno_u8(annos >> 2, _reply_anno);
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+
+    // SNF: Allow to skip IP checksum calculation
+    if ( calc_checksum ) {
+	update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+    }
 
     // end if not first fragment
     if (!IP_FIRSTFRAG(iph))
@@ -79,13 +86,21 @@ IPRewriterFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 	click_tcp *tcph = p->tcp_header();
 	tcph->th_sport = revflow.dport();
 	tcph->th_dport = revflow.sport();
-	update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+
+	// SNF extension: Allow to skip TCP checksum calculation
+	if ( calc_checksum ) {
+		update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+	}
     } else if (iph->ip_p == IP_PROTO_UDP) {
 	click_udp *udph = p->udp_header();
 	udph->uh_sport = revflow.dport();
 	udph->uh_dport = revflow.sport();
-	if (udph->uh_sum)	// 0 checksum is no checksum
-	    update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	if (udph->uh_sum) {	// 0 checksum is no checksum
+	    // SNF extension: Allow to skip UDP checksum calculation
+	    if ( calc_checksum ) {
+	    	update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	    }
+	}
     }
 }
 
diff --git a/elements/ip/iprwmapping.hh b/elements/ip/iprwmapping.hh
index 446f95b..5ee3860 100644
--- a/elements/ip/iprwmapping.hh
+++ b/elements/ip/iprwmapping.hh
@@ -135,7 +135,7 @@ class IPRewriterFlow { public:
     static inline void update_csum(uint16_t *csum, bool direction,
 				   uint16_t csum_delta);
 
-    void apply(WritablePacket *p, bool direction, unsigned annos);
+    void apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum);
 
     void unparse(StringAccum &sa, bool direction, click_jiffies_t now) const;
     void unparse_ports(StringAccum &sa, bool direction, click_jiffies_t now) const;
diff --git a/elements/tcpudp/iprewriter.cc b/elements/tcpudp/iprewriter.cc
index 0bc909b..77fee27 100644
--- a/elements/tcpudp/iprewriter.cc
+++ b/elements/tcpudp/iprewriter.cc
@@ -16,6 +16,8 @@
  * legally binding.
  */
 
+//#include <stdio.h>
+
 #include <click/config.h>
 #include "iprewriter.hh"
 #include <clicknet/ip.h>
@@ -28,6 +30,10 @@
 #include <click/router.hh>
 CLICK_DECLS
 
+// SNF: A statically-specified byte position in the packet annotation area
+//           used by SNF to encode the path of a flow across several NATs
+#define SNF_LABEL_POS 47
+
 IPRewriter::IPRewriter()
     : _udp_map(0)
 {
@@ -85,14 +91,15 @@ IPRewriter::get_entry(int ip_p, const IPFlowID &flowid, int input)
 	IPRewriterInput &is = _input_specs[input];
 	IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
 	if (is.rewrite_flowid(flowid, rewritten_flowid, 0, IPRewriterInput::mapid_iprewriter_udp) == rw_addmap)
-	    m = IPRewriter::add_flow(0, flowid, rewritten_flowid, input);
+	    m = IPRewriter::add_flow(0, flowid, rewritten_flowid, input, -1);
     }
+
     return m;
 }
 
 IPRewriterEntry *
 IPRewriter::add_flow(int ip_p, const IPFlowID &flowid,
-		     const IPFlowID &rewritten_flowid, int input)
+		     const IPFlowID &rewritten_flowid, int input, int snf_label)
 {
     if (ip_p == IP_PROTO_TCP)
 	return TCPRewriter::add_flow(ip_p, flowid, rewritten_flowid, input);
@@ -101,7 +108,18 @@ IPRewriter::add_flow(int ip_p, const IPFlowID &flowid,
     if (!(data = _udp_allocator.allocate()))
 	return 0;
 
+    // SNF: If your packet has been arrived annotated, snf_label is zero or positive.
+    // This means that the reverse output to be installed in the map table must get the value of
+    // snf_label.
     IPRewriterInput *rwinput = &_input_specs[input];
+
+    // We have something to give you!!! A different reverse port
+    if ( snf_label != -1 ) {
+	//printf("---->  ROUTPUT before: %d\n", rwinput->routput);
+	rwinput->routput = snf_label;
+	//printf("---->  ROUTPUT  after: %d\n", rwinput->routput);
+    }
+
     IPRewriterFlow *flow = new(data) IPRewriterFlow
 	(rwinput, flowid, rewritten_flowid, ip_p,
 	 !!_udp_timeouts[1], click_jiffies() + relevant_timeout(_udp_timeouts));
@@ -127,41 +145,96 @@ IPRewriter::push(int port, Packet *p_in)
 	return;
     }
 
+    // SNF: Decrement IP TTL!
+    // Do it here, before jumping to either UDP or TCP
+    if ( _dec_ip_ttl ) {
+	// Safe decrement
+	if ( iph->ip_ttl > 1 ) {
+		iph->ip_ttl --;
+		// Checksum is not mandatory anymore
+		if ( _calc_checksum ) {
+			unsigned long sum = (~ntohs(iph->ip_sum) & 0xFFFF) + 0xFEFF;
+			iph->ip_sum = ~htons(sum + (sum >> 16));
+		}
+	}
+	// End flow if TTL is 0
+	else {
+		return;
+	}
+    }
+
+    // SNF: Read a specific position in the annotation area
+    // If set, this position tells you how to route the packet on
+    // the reverse outport specified by the value (the NAT's table
+    // routput must be set accordingly in method IPRewriter::add_flow)
+    // If not set, it must have a value 255 in order to use the standard
+    // port allocation of this element
+    int snf_label = (uint8_t) p->anno_u8(SNF_LABEL_POS);
+    // There is no annotation, behave normally
+    if ( snf_label == 255 ) {
+	snf_label = -1;
+    }
+    else {
+	//printf("\n----> Routing annotation: %d\n", snf_label);
+	// Check whether the given label is in the range of ports of this element
+	if ( this->noutputs() < (snf_label+1) ) {
+		//printf("----> Invalid routing annotation: %d. Element has only %d output ports\n", snf_label, this->noutputs());
+		return;
+	}
+    }
+
     IPFlowID flowid(p);
     HashContainer<IPRewriterEntry> *map = (iph->ip_p == IP_PROTO_TCP ? &_map : &_udp_map);
     IPRewriterEntry *m = map->get(flowid);
 
+    // This is a fresh flow, store the annotation
     if (!m) {			// create new mapping
+	//printf("----> NEW FLOW \n");
 	IPRewriterInput &is = _input_specs.unchecked_at(port);
 	IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
+
 	int result = is.rewrite_flowid(flowid, rewritten_flowid, p, iph->ip_p == IP_PROTO_TCP ? 0 : IPRewriterInput::mapid_iprewriter_udp);
-	if (result == rw_addmap)
-	    m = IPRewriter::add_flow(iph->ip_p, flowid, rewritten_flowid, port);
+	if (result == rw_addmap) {
+	    m = IPRewriter::add_flow(iph->ip_p, flowid, rewritten_flowid, port, snf_label);
+	    /*printf("---->        IP Proto: %d\n", iph->ip_p);
+	    printf("---->        Src   IP: %s\n", m->flowid().saddr().s().c_str());
+	    printf("---->        Src Port: %d\n", htons(m->flowid().sport()));
+	    printf("---->        Dst   IP: %s\n", m->flowid().daddr().s().c_str());
+	    printf("---->        Dst Port: %d\n", htons(m->flowid().dport()));
+	    printf("---->       Direction: %s\n", m->direction()? "Response":"Forward");
+	    printf("----> Forward Outport: %d\n", m->output());
+	    printf("----> Reverse Outport: %d\n", snf_label);*/
+	}
 	if (!m) {
 	    checked_output_push(result, p);
 	    return;
-	} else if (_annos & 2)
+	} else if (_annos & 2) {
 	    m->flow()->set_reply_anno(p->anno_u8(_annos >> 2));
+	}
     }
 
+    // Flow exists for sure now, go to transport header
     click_jiffies_t now_j = click_jiffies();
     IPRewriterFlow *mf = m->flow();
     if (iph->ip_p == IP_PROTO_TCP) {
 	TCPFlow *tcpmf = static_cast<TCPFlow *>(mf);
-	tcpmf->apply(p, m->direction(), _annos);
+	tcpmf->apply(p, m->direction(), _annos, _calc_checksum);
 	if (_timeouts[1])
 	    tcpmf->change_expiry(_heap, true, now_j + _timeouts[1]);
 	else
 	    tcpmf->change_expiry(_heap, false, now_j + tcp_flow_timeout(tcpmf));
     } else {
 	UDPFlow *udpmf = static_cast<UDPFlow *>(mf);
-	udpmf->apply(p, m->direction(), _annos);
+	udpmf->apply(p, m->direction(), _annos, _calc_checksum);
 	if (_udp_timeouts[1])
 	    udpmf->change_expiry(_heap, true, now_j + _udp_timeouts[1]);
 	else
 	    udpmf->change_expiry(_heap, false, now_j + udp_flow_timeout(udpmf));
     }
 
+    // SNF: Check the output port before the final push
+    //printf("----> Output Port: %d\n", m->output());
+
     output(m->output()).push(p);
 }
 
diff --git a/elements/tcpudp/iprewriter.hh b/elements/tcpudp/iprewriter.hh
index 50fb742..c9f2e95 100644
--- a/elements/tcpudp/iprewriter.hh
+++ b/elements/tcpudp/iprewriter.hh
@@ -237,8 +237,11 @@ class IPRewriter : public TCPRewriter { public:
 	else
 	    return 0;
     }
+
+    // SNF: Interface for add flow changed to accommodate label-based lookup in the map table
     IPRewriterEntry *add_flow(int ip_p, const IPFlowID &flowid,
-			      const IPFlowID &rewritten_flowid, int input);
+			      const IPFlowID &rewritten_flowid, int input, int snf_label);
+
     void destroy_flow(IPRewriterFlow *flow);
     click_jiffies_t best_effort_expiry(const IPRewriterFlow *flow) {
 	if (flow->ip_p() == IP_PROTO_TCP)
diff --git a/elements/tcpudp/tcprewriter.cc b/elements/tcpudp/tcprewriter.cc
index 6e10003..242a384 100644
--- a/elements/tcpudp/tcprewriter.cc
+++ b/elements/tcpudp/tcprewriter.cc
@@ -84,7 +84,7 @@ TCPRewriter::TCPFlow::update_seqno_delta(bool direction,
 }
 
 void
-TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len)
+TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len, bool calc_checksum)
 {
     if ((int)(tcph->th_off << 2) < len)
 	len = tcph->th_off << 2;
@@ -106,10 +106,14 @@ TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len)
 	      } else {
 		  uint8_t *end_sack = opt + opt[1];
 
-		  // develop initial checksum value
-		  uint16_t *csum_begin = reinterpret_cast<uint16_t *>(begin_opt + ((opt + 2 - begin_opt) & ~1));
-		  for (uint16_t *csum = csum_begin; reinterpret_cast<uint8_t *>(csum) < end_sack; csum++)
-		      csum_delta += ~*csum & 0xFFFF;
+		  // SNF extension: Allow to skip TCP checksum calculation
+		  uint16_t *csum_begin= 0;
+		  if ( calc_checksum ) {
+		  	// develop initial checksum value
+		  	csum_begin = reinterpret_cast<uint16_t *>(begin_opt + ((opt + 2 - begin_opt) & ~1));
+		  	for (uint16_t *csum = csum_begin; reinterpret_cast<uint8_t *>(csum) < end_sack; csum++)
+		  	    csum_delta += ~*csum & 0xFFFF;
+		  }
 
 		  for (opt += 2; opt < end_sack; opt += 8) {
 #if HAVE_INDIFFERENT_ALIGNMENT
@@ -125,10 +129,13 @@ TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len)
 #endif
 		  }
 
-		  // finish off csum_delta calculation
-		  for (uint16_t *csum = csum_begin; reinterpret_cast<uint8_t *>(csum) < end_sack; csum++)
-		      csum_delta += *csum;
-		  break;
+		  // SNF extension: Allow to skip TCP checksum calculation
+		  if ( calc_checksum ) {
+			  // finish off csum_delta calculation
+			  for (uint16_t *csum = csum_begin; reinterpret_cast<uint8_t *>(csum) < end_sack; csum++)
+			      csum_delta += *csum;
+			  break;
+		  }
 	      }
 	  default:
 	    if (opt[1] < 2)
@@ -138,7 +145,8 @@ TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len)
 	}
 
   done:
-    if (csum_delta) {
+    // SNF extension: Allow to skip TCP checksum calculation
+    if (csum_delta && !calc_checksum) {
 	uint32_t sum = (~tcph->th_sum & 0xFFFF) + csum_delta;
 	sum = (sum & 0xFFFF) + (sum >> 16);
 	tcph->th_sum = ~(sum + (sum >> 16));
@@ -146,7 +154,7 @@ TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len)
 }
 
 void
-TCPRewriter::TCPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
+TCPRewriter::TCPFlow::apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum)
 {
     assert(p->has_network_header());
     click_ip *iph = p->ip_header();
@@ -159,7 +167,11 @@ TCPRewriter::TCPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 	p->set_dst_ip_anno(revflow.saddr());
     if (direction && (annos & 2))
 	p->set_anno_u8(annos >> 2, _reply_anno);
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+
+    // SNF extension: Allow to skip IP checksum calculation
+    if ( calc_checksum ) {
+	update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+    }
 
     // end if not first fragment
     if (!IP_FIRSTFRAG(iph) || p->transport_length() < 18)
@@ -169,7 +181,11 @@ TCPRewriter::TCPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
     click_tcp *tcph = p->tcp_header();
     tcph->th_sport = revflow.dport();
     tcph->th_dport = revflow.sport();
-    update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+
+    // SNF extension: Allow to skip TCP checksum calculation
+    if ( calc_checksum ) {
+	update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+    }
 
     // track connection state
     bool have_payload = ((iph->ip_hl + tcph->th_off) << 2) < ntohs(iph->ip_len);
@@ -203,22 +219,28 @@ TCPRewriter::TCPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 
     if (_dt->delta[direction] || _dt->has_trigger(direction)) {
 	uint32_t newval = htonl(new_seq(direction, ntohl(tcph->th_seq)));
-	click_update_in_cksum(&tcph->th_sum, tcph->th_seq >> 16, newval >> 16);
-	click_update_in_cksum(&tcph->th_sum, tcph->th_seq, newval);
+	// SNF extension: Allow to skip TCP checksum calculation
+	if ( calc_checksum ) {
+		click_update_in_cksum(&tcph->th_sum, tcph->th_seq >> 16, newval >> 16);
+		click_update_in_cksum(&tcph->th_sum, tcph->th_seq, newval);
+	}
 	tcph->th_seq = newval;
     }
 
     if (_dt->delta[!direction] || _dt->has_trigger(!direction)) {
 	uint32_t newval = htonl(new_ack(direction, ntohl(tcph->th_ack)));
-	click_update_in_cksum(&tcph->th_sum, tcph->th_ack >> 16, newval >> 16);
-	click_update_in_cksum(&tcph->th_sum, tcph->th_ack, newval);
+	// SNF extension: Allow to skip TCP checksum calculation
+	if ( calc_checksum ) {
+		click_update_in_cksum(&tcph->th_sum, tcph->th_ack >> 16, newval >> 16);
+		click_update_in_cksum(&tcph->th_sum, tcph->th_ack, newval);
+	}
 	tcph->th_ack = newval;
 
 	// update SACK sequence numbers
 	if (tcph->th_off > 8
 	    || (tcph->th_off == 8
 		&& *(reinterpret_cast<const uint32_t *>(tcph + 1)) != htonl(0x0101080A)))
-	    apply_sack(direction, tcph, p->transport_length());
+	    apply_sack(direction, tcph, p->transport_length(), calc_checksum);
     }
 }
 
@@ -331,7 +353,7 @@ TCPRewriter::push(int port, Packet *p_in)
     }
 
     TCPFlow *mf = static_cast<TCPFlow *>(m->flow());
-    mf->apply(p, m->direction(), _annos);
+    mf->apply(p, m->direction(), _annos, _calc_checksum);
 
     click_jiffies_t now_j = click_jiffies();
     if (_timeouts[1])
diff --git a/elements/tcpudp/tcprewriter.hh b/elements/tcpudp/tcprewriter.hh
index bcae3fc..2bb8a6c 100644
--- a/elements/tcpudp/tcprewriter.hh
+++ b/elements/tcpudp/tcprewriter.hh
@@ -127,7 +127,7 @@ class TCPRewriter : public IPRewriterBase { public:
 	tcp_seq_t new_seq(bool direction, tcp_seq_t seqno) const;
 	tcp_seq_t new_ack(bool direction, tcp_seq_t seqno) const;
 
-	void apply(WritablePacket *p, bool direction, unsigned annos);
+	void apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum);
 
 	void unparse(StringAccum &sa, bool direction, click_jiffies_t now) const;
 
@@ -150,7 +150,7 @@ class TCPRewriter : public IPRewriterBase { public:
 
 	delta_transition *_dt;
 
-	void apply_sack(bool direction, click_tcp *tcp, int transport_len);
+	void apply_sack(bool direction, click_tcp *tcp, int transport_len, bool calc_checksum);
 
     };
 
diff --git a/elements/tcpudp/udprewriter.cc b/elements/tcpudp/udprewriter.cc
index b3d0f62..5033e07 100644
--- a/elements/tcpudp/udprewriter.cc
+++ b/elements/tcpudp/udprewriter.cc
@@ -27,7 +27,7 @@
 CLICK_DECLS
 
 void
-UDPRewriter::UDPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
+UDPRewriter::UDPFlow::apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum)
 {
     assert(p->has_network_header());
     click_ip *iph = p->ip_header();
@@ -40,7 +40,11 @@ UDPRewriter::UDPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 	p->set_dst_ip_anno(revflow.saddr());
     if (direction && (annos & 2))
 	p->set_anno_u8(annos >> 2, _reply_anno);
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+
+    // SNF: Allow to skip IP checksum calculation
+    if ( calc_checksum ) {
+    	update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+    }
 
     // end if not first fragment
     if (!IP_FIRSTFRAG(iph))
@@ -51,12 +55,20 @@ UDPRewriter::UDPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
     udph->uh_sport = revflow.dport(); // TCP ports in the same place
     udph->uh_dport = revflow.sport();
     if (iph->ip_p == IP_PROTO_TCP) {
-	if (p->transport_length() >= 18)
-	    update_csum(&reinterpret_cast<click_tcp *>(udph)->th_sum, direction, _udp_csum_delta);
+	if (p->transport_length() >= 18) {
+	    // SNF: Allow to skip UDP checksum calculation
+	    if ( calc_checksum ) {
+	    	update_csum(&reinterpret_cast<click_tcp *>(udph)->th_sum, direction, _udp_csum_delta);
+	    }
+	}
     } else if (iph->ip_p == IP_PROTO_UDP) {
-	if (p->transport_length() >= 8 && udph->uh_sum)
-	    // 0 checksum is no checksum
-	    update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	if (p->transport_length() >= 8 && udph->uh_sum) {
+	    // SNF: Allow to skip UDP checksum calculation
+	    if ( calc_checksum ) {
+	    	// 0 checksum is no checksum
+	    	update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	    }
+	}
     }
 
     // track connection state
@@ -165,7 +177,7 @@ UDPRewriter::push(int port, Packet *p_in)
     }
 
     UDPFlow *mf = static_cast<UDPFlow *>(m->flow());
-    mf->apply(p, m->direction(), _annos);
+    mf->apply(p, m->direction(), _annos, _calc_checksum);
 
     click_jiffies_t now_j = click_jiffies();
     if (_timeouts[1])
diff --git a/elements/tcpudp/udprewriter.hh b/elements/tcpudp/udprewriter.hh
index 4246624..6cd0caa 100644
--- a/elements/tcpudp/udprewriter.hh
+++ b/elements/tcpudp/udprewriter.hh
@@ -175,7 +175,7 @@ class UDPRewriter : public IPRewriterBase { public:
 	    return _tflags > 6;
 	}
 
-	void apply(WritablePacket *p, bool direction, unsigned annos);
+	void apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum);
 
     };
 
diff --git a/include/click/router.hh b/include/click/router.hh
index dc83606..87a7b68 100644
--- a/include/click/router.hh
+++ b/include/click/router.hh
@@ -129,7 +129,14 @@ class Router { public:
     inline Router* hotswap_router() const;
     void set_hotswap_router(Router* router);
 
-    int initialize(ErrorHandler* errh);
+    /*
+     * SNF Modification to prevent Click from initializing the elements in this call.
+     * We simply want to have the Click DAG populated with all the elements and connections.
+     * The 2nd argument is set to false by default. This is how normal Click calls the function
+     * so it does not affect normal Click executions.
+     */
+    int initialize(ErrorHandler* errh, bool initialize_only_dag=false);
+
     void activate(bool foreground, ErrorHandler* errh);
     inline void activate(ErrorHandler* errh);
     inline void set_foreground(bool foreground);
@@ -296,6 +303,10 @@ class Router { public:
 
     Router* _next_router;
 
+    // SNF extension: If set to true, the router's elements are not initialized
+    // Router::initialize() and ~Router() use this field to properly set and reset the router
+    bool _do_not_initialize;
+
 #if CLICK_LINUXMODULE
     Vector<struct module*> _modules;
 #endif
diff --git a/lib/driver.cc b/lib/driver.cc
index 0b4ac0f..01a8b70 100644
--- a/lib/driver.cc
+++ b/lib/driver.cc
@@ -527,8 +527,9 @@ click_read_router(String filename, bool is_expr, ErrorHandler *errh, bool initia
     l->end_parse(cookie);
 
     // initialize if requested
+    bool initialize_only_dag = false;
     if (initialize)
-	if (errh->nerrors() > before || router->initialize(errh) < 0) {
+	if (errh->nerrors() > before || router->initialize(errh, initialize_only_dag) < 0) {
 	    delete router;
 	    return 0;
 	}
diff --git a/lib/router.cc b/lib/router.cc
index d345236..cd11e0d 100644
--- a/lib/router.cc
+++ b/lib/router.cc
@@ -83,7 +83,8 @@ Router::Router(const String &configuration, Master *master)
       _configuration(configuration),
       _notifier_signals(0),
       _arena_factory(new HashMap_ArenaFactory),
-      _hotswap_router(0), _thread_sched(0), _name_info(0), _next_router(0)
+      _hotswap_router(0), _thread_sched(0), _name_info(0), _next_router(0),
+      _do_not_initialize(false)
 {
     _refcount = 0;
     _runcount = 0;
@@ -117,7 +118,8 @@ Router::~Router()
 	for (int ord = _elements.size() - 1; ord >= 0; ord--)
 	    _elements[ _element_configure_order[ord] ]->cleanup(Element::CLEANUP_ROUTER_INITIALIZED);
     } else if (_state != ROUTER_DEAD) {
-	assert(_element_configure_order.size() == 0 && _state <= ROUTER_PRECONFIGURE);
+        // We do not follow all the Click states thus this assertion must be commented
+	//assert(_element_configure_order.size() == 0 && _state <= ROUTER_PRECONFIGURE);
 	for (int i = _elements.size() - 1; i >= 0; i--)
 	    _elements[i]->cleanup(Element::CLEANUP_NO_ROUTER);
     }
@@ -151,6 +153,12 @@ Router::~Router()
 	delete ns;
     }
     delete _name_info;
+
+    // Return here in case that the router has been constructed by setting this member to true.
+    // In this case we haven't registered our Router in the first place.
+    if ( _do_not_initialize )
+    	return;
+
     if (_master)
 	_master->unregister_router(this);
 }
@@ -1085,7 +1093,7 @@ Router::initialize_handlers(bool defaults, bool specifics)
 }
 
 int
-Router::initialize(ErrorHandler *errh)
+Router::initialize(ErrorHandler *errh, bool do_not_initialize)
 {
     if (_state != ROUTER_NEW)
 	return errh->error("second attempt to initialize router");
@@ -1165,6 +1173,18 @@ Router::initialize(ErrorHandler *errh)
 	}
     }
 
+    //////////////////////////////////////////////////////////////////////////////
+    /*
+     * SNF modification to prevent the initialization of Click elements
+     * It happens only when the boolean argument is true. Default is false.
+     */
+    //////////////////////////////////////////////////////////////////////////////
+    if ( do_not_initialize ) {
+	// This field is useful in the destructor
+	_do_not_initialize = true;
+	return 0;
+    }
+
 #if CLICK_DMALLOC
     CLICK_DMALLOC_REG("iHoo");
 #endif
diff --git a/userlevel/click.cc b/userlevel/click.cc
index a5e01cc..63f1cbb 100644
--- a/userlevel/click.cc
+++ b/userlevel/click.cc
@@ -388,8 +388,9 @@ parse_configuration(const String &text, bool text_is_expr, bool hotswap,
   if (hotswap && click_router && click_router->initialized())
       router->set_hotswap_router(click_router);
 
+  bool initialize_only_dag = false;
   if (errh->nerrors() == before_errors
-      && router->initialize(errh) >= 0)
+      && router->initialize(errh, initialize_only_dag) >= 0)
     return router;
   else {
     delete router;
