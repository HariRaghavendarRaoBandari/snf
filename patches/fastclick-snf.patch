diff --git a/elements/icmp/icmppingrewriter.cc b/elements/icmp/icmppingrewriter.cc
index 9222cfd..bbf0d8a 100644
--- a/elements/icmp/icmppingrewriter.cc
+++ b/elements/icmp/icmppingrewriter.cc
@@ -71,10 +71,19 @@ ICMPPingRewriter::ICMPPingFlow::unparse(StringAccum &sa, bool direction,
 
 ICMPPingRewriter::ICMPPingRewriter()
 {
+#if HAVE_USER_MULTITHREAD
+    _maps_no = ( click_max_cpu_ids() == 0 )? 1 : click_max_cpu_ids();
+    _allocator = new SizedHashAllocator<sizeof(ICMPPingFlow)>[_maps_no];
+    //click_chatter("[%s]: Allocated %d ICMP flow maps", class_name(), _maps_no);
+#endif
 }
 
 ICMPPingRewriter::~ICMPPingRewriter()
 {
+#if HAVE_USER_MULTITHREAD
+    if ( _allocator )
+        delete [] _allocator;
+#endif
 }
 
 void *
@@ -91,8 +100,10 @@ ICMPPingRewriter::cast(const char *n)
 int
 ICMPPingRewriter::configure(Vector<String> &conf, ErrorHandler *errh)
 {
-    // numbers in seconds
-    _timeouts[0] = 5 * 60;	// best effort: 5 minutes
+    for (unsigned i=0; i<_mem_units_no; i++) {
+        // numbers in seconds
+        _timeouts[i][0] = 5 * 60;	// best effort: 5 minutes
+    }
     bool dst_anno = true, has_reply_anno = false;
     int reply_anno;
 
@@ -114,7 +125,7 @@ ICMPPingRewriter::get_entry(int ip_p, const IPFlowID &xflowid, int input)
     bool echo = (input != get_entry_reply);
     IPFlowID flowid(xflowid.saddr(), xflowid.sport() + !echo,
 		    xflowid.daddr(), xflowid.sport() + echo);
-    IPRewriterEntry *m = _map.get(flowid);
+    IPRewriterEntry *m = _map[click_current_cpu_id()].get(flowid);
     if (!m && (unsigned) input < (unsigned) _input_specs.size()) {
 	IPRewriterInput &is = _input_specs[input];
 	IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
@@ -133,14 +144,15 @@ ICMPPingRewriter::add_flow(int, const IPFlowID &flowid,
     void *data;
     if ((uint16_t) (flowid.sport() + 1) != flowid.dport()
 	|| (uint16_t) (rewritten_flowid.sport() + 1) != rewritten_flowid.dport()
-	|| !(data = _allocator.allocate()))
+	|| !(data = _allocator[click_current_cpu_id()].allocate()))
 	return 0;
 
     ICMPPingFlow *flow = new(data) ICMPPingFlow
 	(&_input_specs[input], flowid, rewritten_flowid,
-	 !!_timeouts[1], click_jiffies() + relevant_timeout(_timeouts));
+	 !!_timeouts[click_current_cpu_id()][1], click_jiffies() +
+     relevant_timeout(_timeouts[click_current_cpu_id()]));
 
-    return store_flow(flow, input, _map);
+    return store_flow(flow, input, _map[click_current_cpu_id()]);
 }
 
 void
@@ -168,7 +180,7 @@ ICMPPingRewriter::push(int port, Packet *p_in)
     IPFlowID flowid(iph->ip_src, icmph->icmp_identifier + !echo,
 		    iph->ip_dst, icmph->icmp_identifier + echo);
 
-    IPRewriterEntry *m = _map.get(flowid);
+    IPRewriterEntry *m = _map[click_current_cpu_id()].get(flowid);
 
     if (!m && !echo)
 	goto mapping_fail;
@@ -189,7 +201,10 @@ ICMPPingRewriter::push(int port, Packet *p_in)
 
     ICMPPingFlow *mf = static_cast<ICMPPingFlow *>(m->flow());
     mf->apply(p, m->direction(), _annos);
-    mf->change_expiry_by_timeout(_heap, click_jiffies(), _timeouts);
+    mf->change_expiry_by_timeout(
+        _heap[click_current_cpu_id()], click_jiffies(),
+        _timeouts[click_current_cpu_id()]
+    );
 
     output(m->output()).push(p);
 }
@@ -198,10 +213,10 @@ ICMPPingRewriter::push(int port, Packet *p_in)
 String
 ICMPPingRewriter::dump_mappings_handler(Element *e, void *)
 {
-    ICMPPingRewriter *rw = (ICMPPingRewriter *)e;
+    ICMPPingRewriter *rw = static_cast<ICMPPingRewriter *> (e);
     StringAccum sa;
     click_jiffies_t now = click_jiffies();
-    for (Map::iterator iter = rw->_map.begin(); iter.live(); ++iter) {
+    for (Map::iterator iter = rw->_map[click_current_cpu_id()].begin(); iter.live(); ++iter) {
 	ICMPPingFlow *f = static_cast<ICMPPingFlow *>(iter->flow());
 	f->unparse(sa, iter->direction(), now);
 	sa << '\n';
diff --git a/elements/icmp/icmppingrewriter.hh b/elements/icmp/icmppingrewriter.hh
index e09dce6..3a02c36 100644
--- a/elements/icmp/icmppingrewriter.hh
+++ b/elements/icmp/icmppingrewriter.hh
@@ -97,10 +97,10 @@ class ICMPPingRewriter : public IPRewriterBase { public:
 
     };
 
-    ICMPPingRewriter() CLICK_COLD;
+    ICMPPingRewriter()  CLICK_COLD;
     ~ICMPPingRewriter() CLICK_COLD;
 
-    const char *class_name() const	{ return "ICMPPingRewriter"; }
+    const char *class_name() const { return "ICMPPingRewriter"; }
     void *cast(const char *);
 
     int configure(Vector<String> &, ErrorHandler *) CLICK_COLD;
@@ -115,21 +115,25 @@ class ICMPPingRewriter : public IPRewriterBase { public:
     void add_handlers() CLICK_COLD;
 
   private:
+#if HAVE_USER_MULTITHREAD
+    unsigned _maps_no;
+    SizedHashAllocator<sizeof(ICMPPingFlow)> *_allocator;
+#else
+    SizedHashAllocator<sizeof(ICMPPingFlow)> _allocator[CLICK_CPU_MAX];
+#endif
 
-    SizedHashAllocator<sizeof(ICMPPingFlow)> _allocator;
     unsigned _annos;
 
     static String dump_mappings_handler(Element *, void *);
-
 };
 
 
 inline void
 ICMPPingRewriter::destroy_flow(IPRewriterFlow *flow)
 {
-    unmap_flow(flow, _map);
+    unmap_flow(flow, _map[click_current_cpu_id()]);
     static_cast<ICMPPingFlow *>(flow)->~ICMPPingFlow();
-    _allocator.deallocate(flow);
+    _allocator[click_current_cpu_id()].deallocate(flow);
 }
 
 CLICK_ENDDECLS
diff --git a/elements/ip/decipttl.cc b/elements/ip/decipttl.cc
index fd04649..74809ec 100644
--- a/elements/ip/decipttl.cc
+++ b/elements/ip/decipttl.cc
@@ -2,7 +2,7 @@
  * decipttl.{cc,hh} -- element decrements IP packet's time-to-live
  * Eddie Kohler, Robert Morris
  *
- * Computational batching support
+ * Computational batching support and optional checksum calculation
  * by Georgios Katsikas
  *
  * Copyright (c) 1999-2000 Massachusetts Institute of Technology
@@ -28,7 +28,7 @@
 CLICK_DECLS
 
 DecIPTTL::DecIPTTL()
-    : _active(true), _multicast(true)
+    : _active(true), _multicast(true), _calc_checksum(true)
 {
     _drops = 0;
 }
@@ -42,6 +42,7 @@ DecIPTTL::configure(Vector<String> &conf, ErrorHandler *errh)
 {
     return Args(conf, this, errh)
 	.read("ACTIVE", _active)
+	.read("CALC_CHECKSUM", _calc_checksum)
 	.read("MULTICAST", _multicast).complete();
 }
 
@@ -66,6 +67,10 @@ DecIPTTL::simple_action(Packet *p)
 	click_ip *ip = q->ip_header();
 	--ip->ip_ttl;
 
+	// Do not calculate IP checksum if you are requested to do so
+	if (!_calc_checksum)
+	    return q;
+
 	// 19.Aug.1999 - incrementally update IP checksum as suggested by SOSP
 	// reviewers, according to RFC1141, as updated by RFC1624.
 	// new_sum = ~(~old_sum + ~old_halfword + new_halfword)
@@ -94,6 +99,7 @@ DecIPTTL::add_handlers()
 {
     add_data_handlers("drops", Handler::OP_READ, &_drops);
     add_data_handlers("active", Handler::OP_READ | Handler::OP_WRITE | Handler::CHECKBOX, &_active);
+    add_data_handlers("calc_checksum", Handler::OP_READ | Handler::OP_WRITE | Handler::CHECKBOX, &_calc_checksum);
 }
 
 CLICK_ENDDECLS
diff --git a/elements/ip/decipttl.hh b/elements/ip/decipttl.hh
index 876c689..e6efee7 100644
--- a/elements/ip/decipttl.hh
+++ b/elements/ip/decipttl.hh
@@ -31,6 +31,11 @@ CLICK_DECLS
  * Boolean.  If false, do not decrement the TTLs for multicast packets.
  * Defaults to true.
  *
+ * =item CALC_CHECKSUM
+ * Boolean. If true, the element does not calculate the IP checksum,
+ * since it is assumed that a subsequent element will do so.
+ * Defaults to true.
+ *
  * =back
  *
  * =e
@@ -64,6 +69,7 @@ class DecIPTTL : public BatchElement { public:
     atomic_uint32_t _drops;
     bool _active;
     bool _multicast;
+    bool _calc_checksum;    // Make the checksum calculation optional
 };
 
 CLICK_ENDDECLS
diff --git a/elements/ip/ipaddrpairrewriter.cc b/elements/ip/ipaddrpairrewriter.cc
index 05ac76f..e428eca 100644
--- a/elements/ip/ipaddrpairrewriter.cc
+++ b/elements/ip/ipaddrpairrewriter.cc
@@ -2,8 +2,12 @@
  * ipaddrpairrewriter.{cc,hh} -- rewrites packet source and destination
  * Eddie Kohler
  *
+ * Computational batching support
+ * by Georgios Katsikas
+ *
  * Copyright (c) 2004 Regents of the University of California
  * Copyright (c) 2009-2010 Meraki, Inc.
+ * Copyright (c) 2016 KTH Royal Institute of Technology
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -27,160 +31,255 @@ CLICK_DECLS
 
 void
 IPAddrPairRewriter::IPAddrPairFlow::apply(WritablePacket *p, bool direction,
-					  unsigned annos)
+						unsigned annos)
 {
-    assert(p->has_network_header());
-    click_ip *iph = p->ip_header();
-
-    // IP header
-    const IPFlowID &revflow = _e[!direction].flowid();
-    iph->ip_src = revflow.daddr();
-    iph->ip_dst = revflow.saddr();
-    if (annos & 1)
-	p->set_dst_ip_anno(revflow.saddr());
-    if (direction && (annos & 2))
-	p->set_anno_u8(annos >> 2, _reply_anno);
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
-
-    // UDP/TCP header
-    if (!IP_FIRSTFRAG(iph))
-	/* do nothing */;
-    else if (iph->ip_p == IP_PROTO_TCP && p->transport_length() >= 18) {
-	click_tcp *tcph = p->tcp_header();
-	update_csum(&tcph->th_sum, direction, _udp_csum_delta);
-    } else if (iph->ip_p == IP_PROTO_UDP && p->transport_length() >= 8) {
-	click_udp *udph = p->udp_header();
-	if (udph->uh_sum)	// 0 checksum is no checksum
-	    update_csum(&udph->uh_sum, direction, _udp_csum_delta);
-    }
+	assert(p->has_network_header());
+	click_ip *iph = p->ip_header();
+
+	// IP header
+	const IPFlowID &revflow = _e[!direction].flowid();
+	iph->ip_src = revflow.daddr();
+	iph->ip_dst = revflow.saddr();
+	if (annos & 1)
+		p->set_dst_ip_anno(revflow.saddr());
+	if (direction && (annos & 2))
+		p->set_anno_u8(annos >> 2, _reply_anno);
+	update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+
+	// UDP/TCP header
+	if (!IP_FIRSTFRAG(iph))
+		/* do nothing */;
+	else if (iph->ip_p == IP_PROTO_TCP && p->transport_length() >= 18) {
+		click_tcp *tcph = p->tcp_header();
+		update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+	}
+	else if (iph->ip_p == IP_PROTO_UDP && p->transport_length() >= 8) {
+		click_udp *udph = p->udp_header();
+		if (udph->uh_sum)	// 0 checksum is no checksum
+			update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	}
 }
 
 void
 IPAddrPairRewriter::IPAddrPairFlow::unparse(StringAccum &sa, bool direction,
-					    click_jiffies_t now) const
+											click_jiffies_t now) const
 {
-    const IPFlowID &flow = _e[direction].flowid();
-    const IPFlowID &reply_flow = _e[!direction].flowid();
-    sa << '(' << flow.saddr() << ", " << flow.daddr() << ") => ("
-       << reply_flow.daddr() << ", " << reply_flow.saddr() << ')';
-    unparse_ports(sa, direction, now);
+	const IPFlowID &flow = _e[direction].flowid();
+	const IPFlowID &reply_flow = _e[!direction].flowid();
+	sa 	<< '(' << flow.saddr() << ", " << flow.daddr() << ") => ("
+		<< reply_flow.daddr() << ", " << reply_flow.saddr() << ')';
+	unparse_ports(sa, direction, now);
 }
 
 IPAddrPairRewriter::IPAddrPairRewriter()
 {
+#if HAVE_USER_MULTITHREAD
+	_maps_no = ( click_max_cpu_ids() == 0 )? 1 : click_max_cpu_ids();
+	_allocator = new SizedHashAllocator<sizeof(IPAddrPairFlow)>[_maps_no];
+	//click_chatter("[%s]: Allocated %d flow maps", class_name(), _maps_no);
+#endif
 }
 
 IPAddrPairRewriter::~IPAddrPairRewriter()
 {
+#if HAVE_USER_MULTITHREAD
+	if ( _allocator )
+		delete [] _allocator;
+#endif
 }
 
 void *
 IPAddrPairRewriter::cast(const char *n)
 {
-    if (strcmp(n, "IPRewriterBase") == 0)
-	return (IPRewriterBase *)this;
-    else if (strcmp(n, "IPAddrPairRewriter") == 0)
-	return (IPAddrPairRewriter *)this;
-    else
-	return 0;
+	if (strcmp(n, "IPRewriterBase") == 0)
+		return static_cast<IPRewriterBase *> (this);
+	else if (strcmp(n, "IPAddrPairRewriter") == 0)
+		return static_cast<IPAddrPairRewriter *> (this);
+	else
+		return 0;
 }
 
 int
 IPAddrPairRewriter::configure(Vector<String> &conf, ErrorHandler *errh)
 {
-    bool has_reply_anno = false;
-    int reply_anno;
-    _timeouts[0] = 60 * 120;	// 2 hours
+	bool has_reply_anno = false;
+	int reply_anno;
+	for (unsigned i=0; i<_mem_units_no; i++) {
+		_timeouts[i][0] = 60 * 120;	// 2 hours
+	}
 
-    if (Args(this, errh).bind(conf)
-	.read("REPLY_ANNO", has_reply_anno, AnnoArg(1), reply_anno)
-	.consume() < 0)
-	return -1;
+	if (Args(this, errh).bind(conf)
+		.read("REPLY_ANNO", has_reply_anno, AnnoArg(1), reply_anno)
+		.consume() < 0)
+		return -1;
 
-    _annos = 1 + (has_reply_anno ? 2 + (reply_anno << 2) : 0);
-    return IPRewriterBase::configure(conf, errh);
+	_annos = 1 + (has_reply_anno ? 2 + (reply_anno << 2) : 0);
+
+	return IPRewriterBase::configure(conf, errh);
 }
 
 IPRewriterEntry *
 IPAddrPairRewriter::get_entry(int, const IPFlowID &xflowid, int input)
 {
-    IPFlowID flowid(xflowid.saddr(), 0, xflowid.daddr(), 0);
-    IPRewriterEntry *m = _map.get(flowid);
-    if (!m && (unsigned) input < (unsigned) _input_specs.size()) {
-	IPRewriterInput &is = _input_specs[input];
-	IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
-	if (is.rewrite_flowid(flowid, rewritten_flowid, 0) == rw_addmap)
-	    m = IPAddrPairRewriter::add_flow(0, flowid, rewritten_flowid, input);
-    }
-    return m;
+	IPFlowID flowid(xflowid.saddr(), 0, xflowid.daddr(), 0);
+	IPRewriterEntry *m = _map[click_current_cpu_id()].get(flowid);
+	if (!m && (unsigned) input < (unsigned) _input_specs.size()) {
+		IPRewriterInput &is = _input_specs[input];
+		IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
+		if (is.rewrite_flowid(flowid, rewritten_flowid, 0) == rw_addmap)
+			m = IPAddrPairRewriter::add_flow(0, flowid, rewritten_flowid, input);
+	}
+
+	return m;
 }
 
 IPRewriterEntry *
 IPAddrPairRewriter::add_flow(int, const IPFlowID &flowid,
-			     const IPFlowID &rewritten_flowid, int input)
+								const IPFlowID &rewritten_flowid, int input)
 {
-    void *data;
-    if (rewritten_flowid.sport()
-	|| rewritten_flowid.dport()
-	|| !(data = _allocator.allocate()))
-	return 0;
+	void *data;
+	if (	rewritten_flowid.sport() ||
+			rewritten_flowid.dport() ||
+			!(data = _allocator[click_current_cpu_id()].allocate()))
+		return 0;
 
-    IPAddrPairFlow *flow = new(data) IPAddrPairFlow
-	(&_input_specs[input], flowid, rewritten_flowid,
-	 !!_timeouts[1], click_jiffies() + relevant_timeout(_timeouts));
+	IPAddrPairFlow *flow = new(data) IPAddrPairFlow
+		(&_input_specs[input], flowid, rewritten_flowid,
+		 !!_timeouts[click_current_cpu_id()][1], click_jiffies() + 
+		 relevant_timeout(_timeouts[click_current_cpu_id()]));
 
-    return store_flow(flow, input, _map);
+	return store_flow(flow, input, _map[click_current_cpu_id()]);
+}
+
+int
+IPAddrPairRewriter::process(int port, Packet *p_in) {
+	WritablePacket *p = p_in->uniqueify();
+	if (!p)
+		return -1;
+
+	click_ip *iph = p->ip_header();
+
+	IPFlowID flowid(iph->ip_src, 0, iph->ip_dst, 0);
+	IPRewriterEntry *m = _map[click_current_cpu_id()].get(flowid);
+
+	if (!m) {                   // create new mapping
+		IPRewriterInput &is = _input_specs.unchecked_at(port);
+		IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
+		int result = is.rewrite_flowid(flowid, rewritten_flowid, p);
+		if (result == rw_addmap)
+			m = IPAddrPairRewriter::add_flow(0, flowid, rewritten_flowid, port);
+		if (!m)
+			return result;
+		else if (_annos & 2)
+			m->flow()->set_reply_anno(p->anno_u8(_annos >> 2));
+	}
+
+	IPAddrPairFlow *mf = static_cast<IPAddrPairFlow *>(m->flow());
+	mf->apply(p, m->direction(), _annos);
+	mf->change_expiry_by_timeout(
+		_heap[click_current_cpu_id()], click_jiffies(),
+		_timeouts[click_current_cpu_id()]
+	);
+
+	return m->output();
 }
 
 void
-IPAddrPairRewriter::push(int port, Packet *p_in)
+IPAddrPairRewriter::push(int port, Packet *p)
 {
-    WritablePacket *p = p_in->uniqueify();
-    click_ip *iph = p->ip_header();
-
-    IPFlowID flowid(iph->ip_src, 0, iph->ip_dst, 0);
-    IPRewriterEntry *m = _map.get(flowid);
-
-    if (!m) {			// create new mapping
-	IPRewriterInput &is = _input_specs.unchecked_at(port);
-	IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
-	int result = is.rewrite_flowid(flowid, rewritten_flowid, p);
-	if (result == rw_addmap)
-	    m = IPAddrPairRewriter::add_flow(0, flowid, rewritten_flowid, port);
-	if (!m) {
-	    checked_output_push(result, p);
-	    return;
-	} else if (_annos & 2)
-	    m->flow()->set_reply_anno(p->anno_u8(_annos >> 2));
-    }
-
-    IPAddrPairFlow *mf = static_cast<IPAddrPairFlow *>(m->flow());
-    mf->apply(p, m->direction(), _annos);
-    mf->change_expiry_by_timeout(_heap, click_jiffies(), _timeouts);
-    output(m->output()).push(p);
+	int output_port = process(port, p);
+	if ( output_port < 0 ) {
+		p->kill();
+		return;
+	}
+
+	output(output_port).push(p);
 }
 
+#if HAVE_BATCH
+void
+IPAddrPairRewriter::push_batch(int port, PacketBatch *batch)
+{
+	unsigned short outports = noutputs();
+	PacketBatch* out[outports];
+	bzero(out,sizeof(PacketBatch*)*outports);
+	PacketBatch* next = ((batch != NULL)? static_cast<PacketBatch*>(batch->next()) : NULL );
+	PacketBatch* p = batch;
+	PacketBatch* last = NULL;
+	int last_o = -1;
+	int passed = 0;
+	int count  = 0;
+
+	for (;p != NULL;p=next,next=(p==0?0:static_cast<PacketBatch*>(p->next()))) {
+		// The actual job of this element
+		int o = process(port, p);
+
+		if (o < 0 || o>=(outports)) o = (outports - 1);
+
+		if (o == last_o) {
+			passed ++;
+		}
+		else {
+			if (last == NULL) {
+				out[o] = p;
+				p->set_count(1);
+				p->set_tail(p);
+			}
+			else {
+				out[last_o]->set_tail(last);
+				out[last_o]->set_count(out[last_o]->count() + passed);
+				if (!out[o]) {
+					out[o] = p;
+					out[o]->set_count(1);
+					out[o]->set_tail(p);
+				}
+				else {
+					out[o]->append_packet(p);
+				}
+				passed = 0;
+			}
+		}
+		last = p;
+		last_o = o;
+		count++;
+	}
+
+	if (passed) {
+		out[last_o]->set_tail(last);
+		out[last_o]->set_count(out[last_o]->count() + passed);
+	}
+
+	int i = 0;
+	for (; i < outports; i++) {
+		if (out[i]) {
+			out[i]->tail()->set_next(NULL);
+			checked_output_push_batch(i, out[i]);
+		}
+	}
+}
+#endif
 
 String
 IPAddrPairRewriter::dump_mappings_handler(Element *e, void *)
 {
-    IPAddrPairRewriter *rw = (IPAddrPairRewriter *)e;
-    click_jiffies_t now = click_jiffies();
-    StringAccum sa;
-    for (Map::iterator iter = rw->_map.begin(); iter.live(); iter++) {
-	IPAddrPairFlow *f = static_cast<IPAddrPairFlow *>(iter->flow());
-	f->unparse(sa, iter->direction(), now);
-	sa << '\n';
-    }
-    return sa.take_string();
+	IPAddrPairRewriter *rw = static_cast<IPAddrPairRewriter *> (e);
+
+	click_jiffies_t now = click_jiffies();
+	StringAccum sa;
+	for (Map::iterator iter = rw->_map[click_current_cpu_id()].begin(); iter.live(); iter++) {
+		IPAddrPairFlow *f = static_cast<IPAddrPairFlow *>(iter->flow());
+		f->unparse(sa, iter->direction(), now);
+		sa << '\n';
+	}
+	return sa.take_string();
 }
 
 void
 IPAddrPairRewriter::add_handlers()
 {
-    add_read_handler("table", dump_mappings_handler);
-    add_read_handler("mappings", dump_mappings_handler, 0, Handler::h_deprecated);
-    add_rewriter_handlers(true);
+	add_read_handler("table", dump_mappings_handler);
+	add_read_handler("mappings", dump_mappings_handler, 0, Handler::h_deprecated);
+	add_rewriter_handlers(true);
 }
 
 ELEMENT_REQUIRES(IPRewriterBase)
diff --git a/elements/ip/ipaddrpairrewriter.hh b/elements/ip/ipaddrpairrewriter.hh
index 27921a0..c344f34 100644
--- a/elements/ip/ipaddrpairrewriter.hh
+++ b/elements/ip/ipaddrpairrewriter.hh
@@ -53,8 +53,8 @@ the range, as in '1.0.0.1-1.255.255.254#'.
 Say a packet with address pair (SA, DA) is received, and the corresponding new
 addresses are (SA', DA').  Then two mappings are installed:
 
-    (SA, DA) => (SA', DA') [FOUTPUT]
-    (DA', SA') => (DA, SA) [ROUTPUT]
+	(SA, DA) => (SA', DA') [FOUTPUT]
+	(DA', SA') => (DA, SA) [ROUTPUT]
 
 Thus, the input packet is rewritten and sent to FOUTPUT, and packets from the
 reply flow are rewritten to look like part of the original flow and sent to
@@ -114,57 +114,68 @@ IPAddrRewriter.
 RoundRobinIPMapper, FTPPortMapper, ICMPRewriter, ICMPPingRewriter,
 StoreIPAddress (for simple uses) */
 
-class IPAddrPairRewriter : public IPRewriterBase { public:
+class IPAddrPairRewriter : public IPRewriterBase {
 
-    class IPAddrPairFlow : public IPRewriterFlow { public:
+	public:
+		class IPAddrPairFlow : public IPRewriterFlow {
 
-	IPAddrPairFlow(IPRewriterInput *owner, const IPFlowID &flowid,
-		       const IPFlowID &rewritten_flowid,
-		       bool guaranteed, click_jiffies_t expiry_j)
-	    : IPRewriterFlow(owner, flowid, rewritten_flowid,
-			     0, guaranteed, expiry_j) {
-	}
+			public:
+				IPAddrPairFlow(IPRewriterInput *owner, const IPFlowID &flowid,
+						   const IPFlowID &rewritten_flowid,
+						   bool guaranteed, click_jiffies_t expiry_j)
+					: IPRewriterFlow(owner, flowid, rewritten_flowid,
+							 0, guaranteed, expiry_j) {
+				}
 
-	void apply(WritablePacket *p, bool direction, unsigned annos);
+				void apply(WritablePacket *p, bool direction, unsigned annos);
+				void unparse(StringAccum &sa, bool direction, click_jiffies_t now) const;
+		};
 
-	void unparse(StringAccum &sa, bool direction, click_jiffies_t now) const;
+		IPAddrPairRewriter () CLICK_COLD;
+		~IPAddrPairRewriter() CLICK_COLD;
 
-    };
+		const char *class_name() const { return "IPAddrPairRewriter"; }
+		void *cast(const char *);
 
-    IPAddrPairRewriter() CLICK_COLD;
-    ~IPAddrPairRewriter() CLICK_COLD;
+		int configure(Vector<String> &conf, ErrorHandler *errh) CLICK_COLD;
+		//void take_state(Element *, ErrorHandler *);
 
-    const char *class_name() const		{ return "IPAddrPairRewriter"; }
-    void *cast(const char *);
+		IPRewriterEntry *get_entry(int ip_p, const IPFlowID &xflowid, int input);
+		IPRewriterEntry *add_flow(int ip_p, const IPFlowID &flowid,
+									const IPFlowID &rewritten_flowid, int input);
+		void destroy_flow(IPRewriterFlow *flow);
 
-    int configure(Vector<String> &conf, ErrorHandler *errh) CLICK_COLD;
-    //void take_state(Element *, ErrorHandler *);
+		void push      (int port, Packet      *p);
+	#if HAVE_BATCH
+		void push_batch(int port, PacketBatch *batch);
+	#endif
 
-    IPRewriterEntry *get_entry(int ip_p, const IPFlowID &xflowid, int input);
-    IPRewriterEntry *add_flow(int ip_p, const IPFlowID &flowid,
-			      const IPFlowID &rewritten_flowid, int input);
-    void destroy_flow(IPRewriterFlow *flow);
+		void add_handlers() CLICK_COLD;
 
-    void push(int, Packet *);
+	private:
+	#if HAVE_USER_MULTITHREAD
+		unsigned _maps_no;
+		SizedHashAllocator<sizeof(IPAddrPairFlow)> *_allocator;
+	#else
+		SizedHashAllocator<sizeof(IPAddrPairFlow)> _allocator[CLICK_CPU_MAX];
+	#endif
 
-    void add_handlers() CLICK_COLD;
+		unsigned _annos;
 
-  private:
+		// The actual processing of this element is abstracted from the push operation.
+		// This allows both push and push_batch to exploit the same processing
+		int process(int port, Packet *p_in);
 
-    SizedHashAllocator<sizeof(IPAddrPairFlow)> _allocator;
-    unsigned _annos;
-
-    static String dump_mappings_handler(Element *, void *);
+		static String dump_mappings_handler(Element *, void *);
 
 };
 
-
 inline void
 IPAddrPairRewriter::destroy_flow(IPRewriterFlow *flow)
 {
-    unmap_flow(flow, _map);
-    static_cast<IPAddrPairFlow *>(flow)->~IPAddrPairFlow();
-    _allocator.deallocate(flow);
+	unmap_flow(flow, _map[click_current_cpu_id()]);
+	static_cast<IPAddrPairFlow *>(flow)->~IPAddrPairFlow();
+	_allocator[click_current_cpu_id()].deallocate(flow);
 }
 
 CLICK_ENDDECLS
diff --git a/elements/ip/ipaddrrewriter.cc b/elements/ip/ipaddrrewriter.cc
index 868513e..ccae227 100644
--- a/elements/ip/ipaddrrewriter.cc
+++ b/elements/ip/ipaddrrewriter.cc
@@ -2,8 +2,12 @@
  * ipaddrrewriter.{cc,hh} -- rewrites packet source and destination
  * Eddie Kohler
  *
+ * Computational batching support
+ * by Georgios Katsikas
+ *
  * Copyright (c) 2000 Massachusetts Institute of Technology
  * Copyright (c) 2009-2010 Meraki, Inc.
+ * Copyright (c) 2016 KTH Royal Institute of Technology
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -29,169 +33,264 @@ void
 IPAddrRewriter::IPAddrFlow::apply(WritablePacket *p, bool direction,
 				  unsigned annos)
 {
-    assert(p->has_network_header());
-    click_ip *iph = p->ip_header();
-
-    // IP header
-    const IPFlowID &revflow = _e[!direction].flowid();
-    if (!direction)
-	iph->ip_src = revflow.daddr();
-    else {
-	iph->ip_dst = revflow.saddr();
-	if (annos & 1)
-	    p->set_dst_ip_anno(revflow.saddr());
-	if (annos & 2)
-	    p->set_anno_u8(annos >> 2, _reply_anno);
-    }
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
-
-    // UDP/TCP header
-    if (!IP_FIRSTFRAG(iph))
-	/* do nothing */;
-    else if (iph->ip_p == IP_PROTO_TCP && p->transport_length() >= 18) {
-	click_tcp *tcph = p->tcp_header();
-	update_csum(&tcph->th_sum, direction, _udp_csum_delta);
-    } else if (iph->ip_p == IP_PROTO_UDP && p->transport_length() >= 8) {
-	click_udp *udph = p->udp_header();
-	if (udph->uh_sum)	// 0 checksum is no checksum
-	    update_csum(&udph->uh_sum, direction, _udp_csum_delta);
-    }
+	assert(p->has_network_header());
+	click_ip *iph = p->ip_header();
+
+	// IP header
+	const IPFlowID &revflow = _e[!direction].flowid();
+	if (!direction)
+		iph->ip_src = revflow.daddr();
+	else {
+		iph->ip_dst = revflow.saddr();
+		if (annos & 1)
+			p->set_dst_ip_anno(revflow.saddr());
+		if (annos & 2)
+			p->set_anno_u8(annos >> 2, _reply_anno);
+	}
+	update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+
+	// UDP/TCP header
+	if (!IP_FIRSTFRAG(iph))
+		/* do nothing */;
+	else if (iph->ip_p == IP_PROTO_TCP && p->transport_length() >= 18) {
+		click_tcp *tcph = p->tcp_header();
+		update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+	}
+	else if (iph->ip_p == IP_PROTO_UDP && p->transport_length() >= 8) {
+		click_udp *udph = p->udp_header();
+		if (udph->uh_sum)	// 0 checksum is no checksum
+			update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	}
 }
 
 void
 IPAddrRewriter::IPAddrFlow::unparse(StringAccum &sa, bool direction,
-				    click_jiffies_t now) const
+					click_jiffies_t now) const
 {
-    sa << _e[direction].flowid().saddr() << " => "
-       << _e[!direction].flowid().daddr();
-    unparse_ports(sa, direction, now);
+	sa 	<< _e[direction].flowid().saddr() << " => "
+		<< _e[!direction].flowid().daddr();
+	unparse_ports(sa, direction, now);
 }
 
 IPAddrRewriter::IPAddrRewriter()
 {
+#if HAVE_USER_MULTITHREAD
+	_maps_no = ( click_max_cpu_ids() == 0 )? 1 : click_max_cpu_ids();
+	_allocator = new SizedHashAllocator<sizeof(IPAddrFlow)>[_maps_no];
+	//click_chatter("[%s]: Allocated %d flow maps", class_name(), _maps_no);
+#endif
 }
 
 IPAddrRewriter::~IPAddrRewriter()
 {
+#if HAVE_USER_MULTITHREAD
+	if ( _allocator )
+		delete [] _allocator;
+#endif
 }
 
 void *
 IPAddrRewriter::cast(const char *n)
 {
-    if (strcmp(n, "IPRewriterBase") == 0)
-	return (IPRewriterBase *)this;
-    else if (strcmp(n, "IPAddrRewriter") == 0)
-	return (IPAddrRewriter *)this;
-    else
-	return 0;
+	if (strcmp(n, "IPRewriterBase") == 0)
+		return static_cast<IPRewriterBase *> (this);
+	else if (strcmp(n, "IPAddrRewriter") == 0)
+		return static_cast<IPAddrRewriter *> (this);
+	else
+		return 0;
 }
 
 int
 IPAddrRewriter::configure(Vector<String> &conf, ErrorHandler *errh)
 {
-    bool has_reply_anno = false;
-    int reply_anno;
-    _timeouts[0] = 60 * 120;	// 2 hours
+	bool has_reply_anno = false;
+	int reply_anno;
+	for (unsigned i=0; i<_mem_units_no; i++) {
+		_timeouts[i][0] = 60 * 120;	// 2 hours
+	}
+
+	if (Args(this, errh).bind(conf)
+		.read("REPLY_ANNO", has_reply_anno, AnnoArg(1), reply_anno)
+		.consume() < 0)
+		return -1;
 
-    if (Args(this, errh).bind(conf)
-	.read("REPLY_ANNO", has_reply_anno, AnnoArg(1), reply_anno)
-	.consume() < 0)
-	return -1;
+	_annos = 1 + (has_reply_anno ? 2 + (reply_anno << 2) : 0);
 
-    _annos = 1 + (has_reply_anno ? 2 + (reply_anno << 2) : 0);
-    return IPRewriterBase::configure(conf, errh);
+	return IPRewriterBase::configure(conf, errh);
 }
 
 IPRewriterEntry *
 IPAddrRewriter::get_entry(int, const IPFlowID &xflowid, int input)
 {
-    IPFlowID flowid(xflowid.saddr(), 0, IPAddress(), 0);
-    IPRewriterEntry *m = _map.get(flowid);
-    if (!m) {
-	IPFlowID rflowid(IPAddress(), 0, xflowid.daddr(), 0);
-	m = _map.get(rflowid);
-    }
-    if (!m && (unsigned) input < (unsigned) _input_specs.size()) {
-	IPRewriterInput &is = _input_specs[input];
-	IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
-	if (is.rewrite_flowid(flowid, rewritten_flowid, 0) == rw_addmap)
-	    m = add_flow(0, flowid, rewritten_flowid, input);
-    }
-    return m;
+	IPFlowID flowid(xflowid.saddr(), 0, IPAddress(), 0);
+	IPRewriterEntry *m = _map[click_current_cpu_id()].get(flowid);
+	if (!m) {
+		IPFlowID rflowid(IPAddress(), 0, xflowid.daddr(), 0);
+		m = _map[click_current_cpu_id()].get(rflowid);
+	}
+
+	if (!m && (unsigned) input < (unsigned) _input_specs.size()) {
+		IPRewriterInput &is = _input_specs[input];
+		IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
+		if (is.rewrite_flowid(flowid, rewritten_flowid, 0) == rw_addmap)
+			m = add_flow(0, flowid, rewritten_flowid, input);
+	}
+
+	return m;
 }
 
 IPRewriterEntry *
 IPAddrRewriter::add_flow(int, const IPFlowID &flowid,
-			 const IPFlowID &rewritten_flowid, int input)
+			const IPFlowID &rewritten_flowid, int input)
 {
-    void *data;
-    if (rewritten_flowid.sport()
-	|| rewritten_flowid.dport()
-	|| rewritten_flowid.daddr()
-	|| !(data = _allocator.allocate()))
-	return 0;
-
-    IPAddrFlow *flow = new(data) IPAddrFlow
-	(&_input_specs[input], flowid, rewritten_flowid,
-	 !!_timeouts[1], click_jiffies() + relevant_timeout(_timeouts));
-
-    return store_flow(flow, input, _map);
+	void *data;
+	if (	rewritten_flowid.sport() ||
+			rewritten_flowid.dport() ||
+			rewritten_flowid.daddr() ||
+			!(data = _allocator[click_current_cpu_id()].allocate()))
+		return 0;
+
+	IPAddrFlow *flow = new(data) IPAddrFlow
+		(&_input_specs[input], flowid, rewritten_flowid,
+		 !!_timeouts[click_current_cpu_id()][1], click_jiffies() + 
+		 relevant_timeout(_timeouts[click_current_cpu_id()]));
+
+	return store_flow(flow, input, _map[click_current_cpu_id()]);
+}
+
+int
+IPAddrRewriter::process(int port, Packet *p_in) {
+	WritablePacket *p = p_in->uniqueify();
+	if (!p)
+		return -1;
+	click_ip *iph = p->ip_header();
+
+	IPFlowID flowid(iph->ip_src, 0, IPAddress(), 0);
+	IPRewriterEntry *m = _map[click_current_cpu_id()].get(flowid);
+
+	if (!m) {
+		IPFlowID rflowid = IPFlowID(IPAddress(), 0, iph->ip_dst, 0);
+		m = _map[click_current_cpu_id()].get(rflowid);
+	}
+
+	if (!m) {			// create new mapping
+		IPRewriterInput &is = _input_specs.unchecked_at(port);
+		IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
+		int result = is.rewrite_flowid(flowid, rewritten_flowid, p);
+		if (result == rw_addmap)
+			m = IPAddrRewriter::add_flow(0, flowid, rewritten_flowid, port);
+		if (!m)
+			return result;
+		else if (_annos & 2)
+			m->flow()->set_reply_anno(p->anno_u8(_annos >> 2));
+	}
+
+	IPAddrFlow *mf = static_cast<IPAddrFlow *>(m->flow());
+	mf->apply(p, m->direction(), _annos);
+	mf->change_expiry_by_timeout(
+		_heap[click_current_cpu_id()], click_jiffies(),
+		_timeouts[click_current_cpu_id()]
+	);
+
+	return m->output();
 }
 
 void
-IPAddrRewriter::push(int port, Packet *p_in)
+IPAddrRewriter::push(int port, Packet *p)
 {
-    WritablePacket *p = p_in->uniqueify();
-    click_ip *iph = p->ip_header();
-
-    IPFlowID flowid(iph->ip_src, 0, IPAddress(), 0);
-    IPRewriterEntry *m = _map.get(flowid);
-
-    if (!m) {
-	IPFlowID rflowid = IPFlowID(IPAddress(), 0, iph->ip_dst, 0);
-	m = _map.get(rflowid);
-    }
-
-    if (!m) {			// create new mapping
-	IPRewriterInput &is = _input_specs.unchecked_at(port);
-	IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
-	int result = is.rewrite_flowid(flowid, rewritten_flowid, p);
-	if (result == rw_addmap)
-	    m = IPAddrRewriter::add_flow(0, flowid, rewritten_flowid, port);
-	if (!m) {
-	    checked_output_push(result, p);
-	    return;
-	} else if (_annos & 2)
-	    m->flow()->set_reply_anno(p->anno_u8(_annos >> 2));
-    }
-
-    IPAddrFlow *mf = static_cast<IPAddrFlow *>(m->flow());
-    mf->apply(p, m->direction(), _annos);
-    mf->change_expiry_by_timeout(_heap, click_jiffies(), _timeouts);
-    output(m->output()).push(p);
+	int output_port = process(port, p);
+	if ( output_port < 0 ) {
+		p->kill();
+		return;
+	}
+
+	output(output_port).push(p);
 }
 
+#if HAVE_BATCH
+void
+IPAddrRewriter::push_batch(int port, PacketBatch *batch)
+{
+	unsigned short outports = noutputs();
+	PacketBatch* out[outports];
+	bzero(out,sizeof(PacketBatch*)*outports);
+	PacketBatch* next = ((batch != NULL)? static_cast<PacketBatch*>(batch->next()) : NULL );
+	PacketBatch* p = batch;
+	PacketBatch* last = NULL;
+	int last_o = -1;
+	int passed = 0;
+	int count  = 0;
+
+	for (;p != NULL;p=next,next=(p==0?0:static_cast<PacketBatch*>(p->next()))) {
+		// The actual job of this element
+		int o = process(port, p);
+
+		if (o < 0 || o>=(outports)) o = (outports - 1);
+
+		if (o == last_o) {
+			passed ++;
+		}
+		else {
+			if (last == NULL) {
+				out[o] = p;
+				p->set_count(1);
+				p->set_tail(p);
+			}
+			else {
+				out[last_o]->set_tail(last);
+				out[last_o]->set_count(out[last_o]->count() + passed);
+				if (!out[o]) {
+					out[o] = p;
+					out[o]->set_count(1);
+					out[o]->set_tail(p);
+				}
+				else {
+					out[o]->append_packet(p);
+				}
+				passed = 0;
+			}
+		}
+		last = p;
+		last_o = o;
+		count++;
+	}
+
+	if (passed) {
+		out[last_o]->set_tail(last);
+		out[last_o]->set_count(out[last_o]->count() + passed);
+	}
+
+	int i = 0;
+	for (; i < outports; i++) {
+		if (out[i]) {
+			out[i]->tail()->set_next(NULL);
+			checked_output_push_batch(i, out[i]);
+		}
+	}
+}
+#endif
 
 String
 IPAddrRewriter::dump_mappings_handler(Element *e, void *)
 {
-    IPAddrRewriter *rw = (IPAddrRewriter *)e;
-    StringAccum sa;
-    click_jiffies_t now = click_jiffies();
-    for (Map::iterator iter = rw->_map.begin(); iter.live(); iter++) {
-	IPAddrFlow *f = static_cast<IPAddrFlow *>(iter->flow());
-	f->unparse(sa, iter->direction(), now);
-	sa << '\n';
-    }
-    return sa.take_string();
+	IPAddrRewriter *rw = static_cast<IPAddrRewriter *> (e);
+	StringAccum sa;
+	click_jiffies_t now = click_jiffies();
+	for (Map::iterator iter = rw->_map[click_current_cpu_id()].begin(); iter.live(); iter++) {
+		IPAddrFlow *f = static_cast<IPAddrFlow *>(iter->flow());
+		f->unparse(sa, iter->direction(), now);
+		sa << '\n';
+	}
+
+	return sa.take_string();
 }
 
 void
 IPAddrRewriter::add_handlers()
 {
-    add_read_handler("table", dump_mappings_handler);
-    add_read_handler("mappings", dump_mappings_handler, 0, Handler::h_deprecated);
-    add_rewriter_handlers(true);
+	add_read_handler("table", dump_mappings_handler);
+	add_read_handler("mappings", dump_mappings_handler, 0, Handler::h_deprecated);
+	add_rewriter_handlers(true);
 }
 
 ELEMENT_REQUIRES(IPRewriterBase)
diff --git a/elements/ip/ipaddrrewriter.hh b/elements/ip/ipaddrrewriter.hh
index edf6357..71d9e76 100644
--- a/elements/ip/ipaddrrewriter.hh
+++ b/elements/ip/ipaddrrewriter.hh
@@ -113,57 +113,68 @@ IPAddrRewriter.
 RoundRobinIPMapper, FTPPortMapper, ICMPRewriter, ICMPPingRewriter,
 StoreIPAddress (for simple uses) */
 
-class IPAddrRewriter : public IPRewriterBase { public:
+class IPAddrRewriter : public IPRewriterBase {
 
-    class IPAddrFlow : public IPRewriterFlow { public:
+	public:
+		class IPAddrFlow : public IPRewriterFlow {
 
-	IPAddrFlow(IPRewriterInput *owner, const IPFlowID &flowid,
-		   const IPFlowID &rewritten_flowid,
-		   bool guaranteed, click_jiffies_t expiry_j)
-	    : IPRewriterFlow(owner, flowid, rewritten_flowid,
-			     0, guaranteed, expiry_j) {
-	}
+			public:
+				IPAddrFlow(IPRewriterInput *owner, const IPFlowID &flowid,
+					   const IPFlowID &rewritten_flowid,
+					   bool guaranteed, click_jiffies_t expiry_j)
+					: IPRewriterFlow(owner, flowid, rewritten_flowid,
+							 0, guaranteed, expiry_j) {
+				}
 
-	void apply(WritablePacket *p, bool direction, unsigned annos);
+				void apply(WritablePacket *p, bool direction, unsigned annos);
+				void unparse(StringAccum &sa, bool direction, click_jiffies_t now) const;
+		};
 
-	void unparse(StringAccum &sa, bool direction, click_jiffies_t now) const;
+		IPAddrRewriter () CLICK_COLD;
+		~IPAddrRewriter() CLICK_COLD;
 
-    };
+		const char *class_name() const { return "IPAddrRewriter"; }
+		void *cast(const char *);
 
-    IPAddrRewriter() CLICK_COLD;
-    ~IPAddrRewriter() CLICK_COLD;
+		int configure(Vector<String> &conf, ErrorHandler *errh) CLICK_COLD;
+		//void take_state(Element *, ErrorHandler *);
 
-    const char *class_name() const		{ return "IPAddrRewriter"; }
-    void *cast(const char *);
+		inline IPRewriterEntry *get_entry(int ip_p, const IPFlowID &flowid, int input);
+		IPRewriterEntry *add_flow(int ip_p, const IPFlowID &flowid,
+					  const IPFlowID &rewritten_flowid, int input);
+		void destroy_flow(IPRewriterFlow *flow);
 
-    int configure(Vector<String> &conf, ErrorHandler *errh) CLICK_COLD;
-    //void take_state(Element *, ErrorHandler *);
+		void push      (int port, Packet      *p);
+	#if HAVE_BATCH
+		void push_batch(int port, PacketBatch *batch);
+	#endif
 
-    inline IPRewriterEntry *get_entry(int ip_p, const IPFlowID &flowid, int input);
-    IPRewriterEntry *add_flow(int ip_p, const IPFlowID &flowid,
-			      const IPFlowID &rewritten_flowid, int input);
-    void destroy_flow(IPRewriterFlow *flow);
+		void add_handlers() CLICK_COLD;
 
-    void push(int, Packet *);
+	protected:
+	#if HAVE_USER_MULTITHREAD
+		unsigned _maps_no;
+		SizedHashAllocator<sizeof(IPAddrFlow)> *_allocator;
+	#else
+		SizedHashAllocator<sizeof(IPAddrFlow)> _allocator[CLICK_CPU_MAX];
+	#endif
 
-    void add_handlers() CLICK_COLD;
+		unsigned _annos;
 
-  protected:
-
-    SizedHashAllocator<sizeof(IPAddrFlow)> _allocator;
-    unsigned _annos;
-
-    static String dump_mappings_handler(Element *, void *);
+		// The actual processing of this element is abstracted from the push operation.
+		// This allows both push and push_batch to exploit the same processing
+		int process(int port, Packet *p_in);
 
+		static String dump_mappings_handler(Element *, void *);
 };
 
 
 inline void
 IPAddrRewriter::destroy_flow(IPRewriterFlow *flow)
 {
-    unmap_flow(flow, _map);
-    static_cast<IPAddrFlow *>(flow)->~IPAddrFlow();
-    _allocator.deallocate(flow);
+	unmap_flow(flow, _map[click_current_cpu_id()]);
+	static_cast<IPAddrFlow *>(flow)->~IPAddrFlow();
+	_allocator[click_current_cpu_id()].deallocate(flow);
 }
 
 CLICK_ENDDECLS
diff --git a/elements/ip/ipfilter.cc b/elements/ip/ipfilter.cc
index 15984b3..3b17c9b 100644
--- a/elements/ip/ipfilter.cc
+++ b/elements/ip/ipfilter.cc
@@ -2,9 +2,12 @@
  * ipfilter.{cc,hh} -- IP-packet filter with tcpdumplike syntax
  * Eddie Kohler
  *
+ * Additional IP address fields added by Georgios Katsikas
+ *
  * Copyright (c) 2000-2007 Mazu Networks, Inc.
  * Copyright (c) 2010 Meraki, Inc.
  * Copyright (c) 2004-2011 Regents of the University of California
+ * Copyright (c) 2016 KTH Royal Institute of Technology
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -55,7 +58,10 @@ static const StaticNameDB::Entry type_entries[] = {
     { "type", IPFilter::FIELD_ICMP_TYPE },
     { "unfrag", IPFilter::TYPE_IPUNFRAG },
     { "vers", IPFilter::FIELD_VERSION },
-    { "win", IPFilter::FIELD_TCP_WIN }
+    { "win", IPFilter::FIELD_TCP_WIN },
+    /* Fields IP_SRC and IP_DST added for SNF */
+    { "src", IPFilter::FIELD_IP_SRC},
+    { "dst", IPFilter::FIELD_IP_DST}
 };
 
 static const StaticNameDB::Entry tcp_opt_entries[] = {
@@ -294,6 +300,9 @@ IPFilter::Primitive::unparse_type(int srcdst, int type)
        case FIELD_TTL: sa << "ip ttl"; break;
        case FIELD_TCP_WIN: sa << "tcp win"; break;
        case FIELD_ICMP_TYPE: sa << "icmp type"; break;
+       /* Fields IP_SRC and IP_DST added for SNF */
+       case FIELD_IP_SRC: sa << "ip src"; break;
+       case FIELD_IP_DST: sa << "ip dst"; break;
        default:
 	if (type & FIELD_PROTO_MASK)
 	  sa << unparse_transp_proto((type & FIELD_PROTO_MASK) >> FIELD_PROTO_SHIFT);
diff --git a/elements/ip/ipfilter.hh b/elements/ip/ipfilter.hh
index 1f64fdb..80722f3 100644
--- a/elements/ip/ipfilter.hh
+++ b/elements/ip/ipfilter.hh
@@ -176,7 +176,10 @@ class IPFilter : public BatchElement { public:
 	FIELD_DSCP	= (TYPE_FIELD | ((1*8) << FIELD_OFFSET_SHIFT) | 5),
 	FIELD_TTL	= (TYPE_FIELD | ((8*8) << FIELD_OFFSET_SHIFT) | 7),
 	FIELD_TCP_WIN = (TYPE_FIELD | (IP_PROTO_TCP << FIELD_PROTO_SHIFT) | ((14*8) << FIELD_OFFSET_SHIFT) | 15),
-	FIELD_ICMP_TYPE = (TYPE_FIELD | (IP_PROTO_ICMP << FIELD_PROTO_SHIFT) | (0 << FIELD_OFFSET_SHIFT) | 7)
+	FIELD_ICMP_TYPE = (TYPE_FIELD | (IP_PROTO_ICMP << FIELD_PROTO_SHIFT) | (0 << FIELD_OFFSET_SHIFT) | 7),
+	/* Fields IP_SRC and IP_DST added for SNF */
+	FIELD_IP_SRC = (TYPE_FIELD | ((12*8) << FIELD_OFFSET_SHIFT) | 31),
+	FIELD_IP_DST = (TYPE_FIELD | ((16*8) << FIELD_OFFSET_SHIFT) | 31)
     };
 
     enum {
diff --git a/elements/ip/ipoutputcombo.cc b/elements/ip/ipoutputcombo.cc
index f319381..8e3acfb 100644
--- a/elements/ip/ipoutputcombo.cc
+++ b/elements/ip/ipoutputcombo.cc
@@ -2,7 +2,11 @@
  * ipoutputcombo.{cc,hh} -- IP router output combination element
  * Eddie Kohler
  *
+ * Computational batching support and optional checksum calculation
+ * by Georgios Katsikas
+ *
  * Copyright (c) 1999-2000 Massachusetts Institute of Technology
+ * Copyright (c) 2016 KTH Royal Institute of Technology
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -24,6 +28,7 @@
 CLICK_DECLS
 
 IPOutputCombo::IPOutputCombo()
+    : _calc_checksum(true)
 {
 }
 
@@ -37,6 +42,7 @@ IPOutputCombo::configure(Vector<String> &conf, ErrorHandler *errh)
     return Args(conf, this, errh)
 	.read_mp("COLOR", _color)
 	.read_mp("IPADDR", _my_ip)
+	.read("CALC_CHECKSUM", _calc_checksum)
 	.read_mp("MTU", _mtu).complete();
 }
 
@@ -173,7 +179,7 @@ inline int IPOutputCombo::action(Packet* &p_in, bool color) {
 	  }
 
 	  // IPGWOptions / FixIPSrc
-	  if (do_cksum) {
+	  if (do_cksum && _calc_checksum) {
 	    ip->ip_sum = 0;
 	    ip->ip_sum = click_in_cksum(p->data(), hlen);
 	  }
@@ -185,8 +191,11 @@ inline int IPOutputCombo::action(Packet* &p_in, bool color) {
 	    ip->ip_ttl--;
 	    // 19.Aug.1999 - incrementally update IP checksum as suggested by SOSP
 	    // reviewers, according to RFC1141 and RFC1624
-	    unsigned long sum = (~ntohs(ip->ip_sum) & 0xFFFF) + 0xFEFF;
-	    ip->ip_sum = ~htons(sum + (sum >> 16));
+	    // Do not calculate IP checksum if you are requested to do so
+	    if (_calc_checksum) {
+		unsigned long sum = (~ntohs(ip->ip_sum) & 0xFFFF) + 0xFEFF;
+		ip->ip_sum = ~htons(sum + (sum >> 16));
+	    }
 	  }
 
 	  // Fragmenter
@@ -254,6 +263,7 @@ void IPOutputCombo::push_batch(int, PacketBatch * head) {
 	}
 }
 #endif
+
 inline void
 IPOutputCombo::push(int, Packet *p_in)
 {
@@ -270,6 +280,12 @@ IPOutputCombo::push(int, Packet *p_in)
 	}
 }
 
+void
+IPOutputCombo::add_handlers()
+{
+    add_data_handlers("calc_checksum", Handler::OP_READ | Handler::OP_WRITE | Handler::CHECKBOX, &_calc_checksum);
+}
+
 CLICK_ENDDECLS
 EXPORT_ELEMENT(IPOutputCombo)
 ELEMENT_MT_SAFE(IPOutputCombo)
diff --git a/elements/ip/ipoutputcombo.hh b/elements/ip/ipoutputcombo.hh
index 1cdcd39..65a13ba 100644
--- a/elements/ip/ipoutputcombo.hh
+++ b/elements/ip/ipoutputcombo.hh
@@ -7,7 +7,7 @@ CLICK_DECLS
 
 /*
  * =c
- * IPOutputCombo(COLOR, IPADDR, MTU)
+ * IPOutputCombo(COLOR, IPADDR, MTU, CALC_CHECKSUM)
  * =s ip
  * output combo for IP routing
  * =d
@@ -32,6 +32,11 @@ CLICK_DECLS
  * outputs for PaintTee, IPGWOptions, and DecIPTTL, respectively; and
  * output 4 is for packets longer than MTU.
  *
+ * =item CALC_CHECKSUM
+ * Boolean. If true, the element does not calculate the IP checksum,
+ * since it is assumed that a subsequent element will do so.
+ * Defaults to true.
+ *
  * =n
  *
  * IPOutputCombo does no fragmentation. You'll still need an IPFragmenter for
@@ -52,7 +57,7 @@ class IPOutputCombo : public BatchElement {
   const char *processing() const		{ return PUSH; }
 
   int configure(Vector<String> &, ErrorHandler *) CLICK_COLD;
-
+  void add_handlers() CLICK_COLD;
 
 
 #if HAVE_BATCH
@@ -65,6 +70,7 @@ class IPOutputCombo : public BatchElement {
   int _color;			// PaintTee
   struct in_addr _my_ip;	// IPGWOptions, FixIPSrc
   unsigned _mtu;		// Fragmenter
+  bool _calc_checksum;          // Make the checksum calculation optional
 
   inline int action(Packet* &p_in, bool color);
 };
diff --git a/elements/ip/iprewriterbase.cc b/elements/ip/iprewriterbase.cc
index 50e3f34..1a21290 100644
--- a/elements/ip/iprewriterbase.cc
+++ b/elements/ip/iprewriterbase.cc
@@ -4,9 +4,12 @@
  * Eddie Kohler
  * original versions by Eddie Kohler and Max Poletto
  *
+ * Per-core, thread safe data structures by Georgios Katsikas
+ *
  * Copyright (c) 2000 Massachusetts Institute of Technology
  * Copyright (c) 2001 International Computer Science Institute
  * Copyright (c) 2008-2010 Meraki, Inc.
+ * Copyright (c) 2016 KTH Royal Institute of Technology
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -50,451 +53,544 @@ CLICK_DECLS
 //
 // IPMapper
 //
-
 void
 IPMapper::notify_rewriter(IPRewriterBase *, IPRewriterInput *, ErrorHandler *)
 {
 }
 
 int
-IPMapper::rewrite_flowid(IPRewriterInput *, const IPFlowID &, IPFlowID &,
-			 Packet *, int)
+IPMapper::rewrite_flowid(IPRewriterInput *, const IPFlowID &, IPFlowID &, Packet *, int)
 {
-    return IPRewriterBase::rw_drop;
+	return IPRewriterBase::rw_drop;
 }
 
 //
 // IPRewriterBase
 //
-
 IPRewriterBase::IPRewriterBase()
-    : _map(0), _heap(new IPRewriterHeap), _gc_timer(gc_timer_hook, this)
+	: _gc_timer(gc_timer_hook, this),
+	_drop_bcast(false), _ipgw_opt(false), _fix_ip_src(false),
+	_ip_fragment(false), _dec_ip_ttl(false), _calc_checksum(true),
+	_my_ip(), _mtu(1500), _headroom(Packet::default_headroom),
+	_honor_df(true), _verbose(false)
 {
-    _timeouts[0] = default_timeout;
-    _timeouts[1] = default_guarantee;
-    _gc_interval_sec = default_gc_interval;
+	_gc_interval_sec = default_gc_interval;
+
+	_mem_units_no = ( click_max_cpu_ids() == 0 )? 1 : click_max_cpu_ids();
+
+	// One heap and map per core
+	_map  = new Map[_mem_units_no];
+	_heap = new IPRewriterHeap*[_mem_units_no];
+	_timeouts  = new uint32_t*[_mem_units_no];
+	for (unsigned i=0; i<_mem_units_no; i++) {
+		_heap[i] = new IPRewriterHeap;
+		_timeouts[i] = new uint32_t[2];
+		_timeouts[i][0] = default_timeout;
+		_timeouts[i][1] = default_guarantee;
+	}
+	//click_chatter("[IPRewriterBase]: Allocated %d heaps", _mem_units_no);
 }
 
 IPRewriterBase::~IPRewriterBase()
 {
-    if (_heap)
-	_heap->unuse();
+	delete [] _heap;
+	delete [] _timeouts;
+	delete [] _map;
+	//click_chatter("[IPRewriterBase]: Deleted %d memory units", _mem_units_no);
 }
 
-
 int
 IPRewriterBase::parse_input_spec(const String &line, IPRewriterInput &is,
-				 int input_number, ErrorHandler *errh)
+								int input_number, ErrorHandler *errh)
 {
-    PrefixErrorHandler cerrh(errh, "input spec " + String(input_number) + ": ");
-    String word, rest;
-    if (!cp_word(line, &word, &rest))
-	return cerrh.error("empty argument");
-    cp_eat_space(rest);
-
-    is.kind = IPRewriterInput::i_drop;
-    is.owner = this;
-    is.owner_input = input_number;
-    is.reply_element = this;
-
-    if (word == "pass" || word == "passthrough" || word == "nochange") {
-	int32_t outnum = 0;
-	if (rest && !IntArg().parse(rest, outnum))
-	    return cerrh.error("syntax error, expected %<nochange [OUTPUT]%>");
-	else if ((unsigned) outnum >= (unsigned) noutputs())
-	    return cerrh.error("output port out of range");
-	is.kind = IPRewriterInput::i_nochange;
-	is.foutput = outnum;
-
-    } else if (word == "keep") {
-	Vector<String> words;
-	cp_spacevec(rest, words);
-	if (!IPRewriterPattern::parse_ports(words, &is, this, &cerrh))
-	    return -1;
-	if ((unsigned) is.foutput >= (unsigned) noutputs()
-	    || (unsigned) is.routput >= (unsigned) is.reply_element->noutputs())
-	    return cerrh.error("output port out of range");
-	is.kind = IPRewriterInput::i_keep;
-
-    } else if (word == "drop" || word == "discard") {
-	if (rest)
-	    return cerrh.error("syntax error, expected %<%s%>", word.c_str());
-
-    } else if (word == "pattern" || word == "xpattern") {
-	if (!IPRewriterPattern::parse_with_ports(rest, &is, this, &cerrh))
-	    return -1;
-	if ((unsigned) is.foutput >= (unsigned) noutputs()
-	    || (unsigned) is.routput >= (unsigned) is.reply_element->noutputs())
-	    return cerrh.error("output port out of range");
-	is.u.pattern->use();
-	is.kind = IPRewriterInput::i_pattern;
-
-    } else if (Element *e = cp_element(word, this, 0)) {
-	IPMapper *mapper = (IPMapper *)e->cast("IPMapper");
-	if (rest)
-	    return cerrh.error("syntax error, expected element name");
-	else if (!mapper)
-	    return cerrh.error("element is not an IPMapper");
-	else {
-	    is.kind = IPRewriterInput::i_mapper;
-	    is.u.mapper = mapper;
+	PrefixErrorHandler cerrh(errh, "Input spec " + String(input_number) + ": ");
+	String word, rest;
+	if (!cp_word(line, &word, &rest))
+		return cerrh.error("Empty argument");
+	cp_eat_space(rest);
+
+	is.kind = IPRewriterInput::i_drop;
+	is.owner = this;
+	is.owner_input = input_number;
+	is.reply_element = this;
+
+	if (word == "pass" || word == "passthrough" || word == "nochange") {
+		int32_t outnum = 0;
+		if (rest && !IntArg().parse(rest, outnum))
+			return cerrh.error("Syntax error, expected %<nochange [OUTPUT]%>");
+		else if ((unsigned) outnum >= (unsigned) noutputs())
+			return cerrh.error("Output port out of range");
+		is.kind = IPRewriterInput::i_nochange;
+		is.foutput = outnum;
 	}
+	else if (word == "keep") {
+		Vector<String> words;
+		cp_spacevec(rest, words);
+		if (!IPRewriterPattern::parse_ports(words, &is, this, &cerrh))
+			return -1;
+		if ((unsigned) is.foutput >= (unsigned) noutputs()
+			|| (unsigned) is.routput >= (unsigned) is.reply_element->noutputs())
+			return cerrh.error("Output port out of range");
+		is.kind = IPRewriterInput::i_keep;
+	}
+	else if (word == "drop" || word == "discard") {
+		if (rest)
+			return cerrh.error("Syntax error, expected %<%s%>", word.c_str());
+	}
+	else if (word == "pattern" || word == "xpattern") {
+		if (!IPRewriterPattern::parse_with_ports(rest, &is, this, &cerrh))
+			return -1;
+		if ((unsigned) is.foutput >= (unsigned) noutputs()
+			|| (unsigned) is.routput >= (unsigned) is.reply_element->noutputs())
+			return cerrh.error("Output port out of range");
+		is.u.pattern->use();
+		is.kind = IPRewriterInput::i_pattern;
+	}
+	else if (Element *e = cp_element(word, this, 0)) {
+		IPMapper *mapper = static_cast<IPMapper *> (e->cast("IPMapper"));
+		if (rest)
+			return cerrh.error("Syntax error, expected element name");
+		else if (!mapper)
+			return cerrh.error("Element is not an IPMapper");
+		else {
+			is.kind = IPRewriterInput::i_mapper;
+			is.u.mapper = mapper;
+		}
+	}
+	else
+		return cerrh.error("Unknown specification");
 
-    } else
-	return cerrh.error("unknown specification");
-
-    return 0;
+	return 0;
 }
 
 int
 IPRewriterBase::configure(Vector<String> &conf, ErrorHandler *errh)
 {
-    String capacity_word;
-
-    if (Args(this, errh).bind(conf)
-	.read("CAPACITY", AnyArg(), capacity_word)
-	.read("MAPPING_CAPACITY", AnyArg(), capacity_word)
-	.read("TIMEOUT", SecondsArg(), _timeouts[0])
-	.read("GUARANTEE", SecondsArg(), _timeouts[1])
-	.read("REAP_INTERVAL", SecondsArg(), _gc_interval_sec)
-	.read("REAP_TIME", Args::deprecated, SecondsArg(), _gc_interval_sec)
-	.consume() < 0)
-	return -1;
+	String capacity_word;
+	uint32_t timeouts[2];
+
+	if (Args(this, errh).bind(conf)
+		.read("CAPACITY", AnyArg(), capacity_word)
+		.read("MAPPING_CAPACITY", AnyArg(), capacity_word)
+		.read("TIMEOUT", SecondsArg(), timeouts[0])
+		.read("GUARANTEE", SecondsArg(), timeouts[1])
+		.read("REAP_INTERVAL", SecondsArg(), _gc_interval_sec)
+		.read("REAP_TIME", Args::deprecated, SecondsArg(), _gc_interval_sec)
+		.read("DROP_BCAST", _drop_bcast)
+		.read("IPGW_OPTIONS", _ipgw_opt)
+		.read("FIX_IP_SRC", _fix_ip_src)
+		.read("DEC_IP_TTL", _dec_ip_ttl)
+		.read("IP_FRAGMENT", _ip_fragment)
+		.read("IP_OUT_COMBO", _ip_out_combo)
+		.read("CALC_CHECKSUM", _calc_checksum)
+		.read("MTU", _mtu)
+		.read("HEADROOM", _headroom)
+		.read("HONOR_DF", _honor_df)
+		.read("VERBOSE", _verbose)
+		.consume() < 0)
+		return -1;
+
+	// Combines all these elements
+	if ( _ip_out_combo ) {
+		_dec_ip_ttl = _fix_ip_src = _ipgw_opt = _drop_bcast = true;
+	}
 
-    if (capacity_word) {
-	Element *e;
-	IPRewriterBase *rwb;
-	if (IntArg().parse(capacity_word, _heap->_capacity))
-	    /* OK */;
-	else if ((e = cp_element(capacity_word, this))
-		 && (rwb = (IPRewriterBase *) e->cast("IPRewriterBase"))) {
-	    rwb->_heap->use();
-	    _heap->unuse();
-	    _heap = rwb->_heap;
-	} else
-	    return errh->error("bad MAPPING_CAPACITY");
-    }
-
-    if (conf.size() != ninputs())
-	return errh->error("need %d arguments, one per input port", ninputs());
-
-    _timeouts[0] *= CLICK_HZ;	// _timeouts is measured in jiffies
-    _timeouts[1] *= CLICK_HZ;
-
-    for (int i = 0; i < conf.size(); ++i) {
-	IPRewriterInput is;
-	if (parse_input_spec(conf[i], is, i, errh) >= 0)
-	    _input_specs.push_back(is);
-    }
+	// These elements modify parts of header space
+	if ( _ipgw_opt || _fix_ip_src || _dec_ip_ttl || _ip_out_combo ) {
+		_calc_checksum = true;
+	}
+
+	if (capacity_word) {
+		Element *e;
+		IPRewriterBase *rwb;
+		if (IntArg().parse(capacity_word, _heap[click_current_cpu_id()]->_capacity))
+			/* OK */;
+		else if ((e = cp_element(capacity_word, this)) &&
+				(rwb = static_cast<IPRewriterBase *> (e->cast("IPRewriterBase")))) {
+			rwb->_heap[click_current_cpu_id()]->use();
+			_heap[click_current_cpu_id()]->unuse();
+			_heap[click_current_cpu_id()] = rwb->_heap[click_current_cpu_id()];
+		}
+		else
+			return errh->error("bad MAPPING_CAPACITY");
+	}
 
-    return _input_specs.size() == ninputs() ? 0 : -1;
+	timeouts[0] *= CLICK_HZ;	// timeouts is measured in jiffies
+	timeouts[1] *= CLICK_HZ;
+
+	for (unsigned i=0; i<_mem_units_no; i++) {
+		_timeouts[i] = timeouts;
+	}
+
+	bool has_ipaddr = false;
+	String ipaddr_pat = String("IPADDR");
+	for (int i = 0; i < conf.size(); ++i) {
+
+		// IPADDR argument not handled above
+		int start_pos = conf[i].find_left(ipaddr_pat, 0);
+		if ( start_pos >= 0 ) {
+			has_ipaddr = true;
+			String ip = conf[i].substring(start_pos+ipaddr_pat.length()+1, -1);
+			_my_ip = IPAddress(ip).in_addr();
+			continue;
+		}
+
+		IPRewriterInput is;
+		if (parse_input_spec(conf[i], is, i, errh) >= 0)
+			_input_specs.push_back(is);
+	}
+
+	int extra_params = has_ipaddr? 1:0;
+	if ( conf.size()-extra_params != ninputs() )
+		return errh->error("Need %d arguments, one per input port", ninputs());
+
+	if ( (_ip_fragment) && (_mtu < 8) )
+		return errh->error("MTU must be at least 8");
+
+	if ( (_ipgw_opt || _fix_ip_src) && (_my_ip != 0) )
+		return errh->error("IPGWOptions and/or FixIPSrc operations require IPADDR to be set");
+
+	return _input_specs.size() == ninputs() ? 0 : -1;
 }
 
 int
 IPRewriterBase::initialize(ErrorHandler *errh)
 {
-    for (int i = 0; i < _input_specs.size(); ++i) {
-	PrefixErrorHandler cerrh(errh, "input spec " + String(i) + ": ");
-	if (_input_specs[i].reply_element->_heap != _heap)
-	    cerrh.error("reply element %<%s%> must share this MAPPING_CAPACITY", i, _input_specs[i].reply_element->name().c_str());
-	if (_input_specs[i].kind == IPRewriterInput::i_mapper)
-	    _input_specs[i].u.mapper->notify_rewriter(this, &_input_specs[i], &cerrh);
-    }
-    _gc_timer.initialize(this);
-    if (_gc_interval_sec)
-	_gc_timer.schedule_after_sec(_gc_interval_sec);
-    return errh->nerrors() ? -1 : 0;
+	for (int i = 0; i < _input_specs.size(); ++i) {
+		PrefixErrorHandler cerrh(errh, "input spec " + String(i) + ": ");
+		if (_input_specs[i].reply_element->_heap != _heap)
+			cerrh.error("reply element %<%s%> must share this MAPPING_CAPACITY",
+						i, _input_specs[i].reply_element->name().c_str());
+		if (_input_specs[i].kind == IPRewriterInput::i_mapper)
+			_input_specs[i].u.mapper->notify_rewriter(this, &_input_specs[i], &cerrh);
+	}
+
+	_gc_timer.initialize(this);
+	if (_gc_interval_sec)
+		_gc_timer.schedule_after_sec(_gc_interval_sec);
+
+	return errh->nerrors() ? -1 : 0;
 }
 
 void
 IPRewriterBase::cleanup(CleanupStage)
 {
-    shrink_heap(true);
-    for (int i = 0; i < _input_specs.size(); ++i)
-	if (_input_specs[i].kind == IPRewriterInput::i_pattern)
-	    _input_specs[i].u.pattern->unuse();
-    _input_specs.clear();
+	shrink_heap(true);
+	for (int i = 0; i < _input_specs.size(); ++i)
+		if (_input_specs[i].kind == IPRewriterInput::i_pattern)
+			_input_specs[i].u.pattern->unuse();
+	_input_specs.clear();
 }
 
 IPRewriterEntry *
 IPRewriterBase::get_entry(int ip_p, const IPFlowID &flowid, int input)
 {
-    IPRewriterEntry *m = _map.get(flowid);
-    if (m && ip_p && m->flow()->ip_p() && m->flow()->ip_p() != ip_p)
-	return 0;
-    if (!m && (unsigned) input < (unsigned) _input_specs.size()) {
-	IPRewriterInput &is = _input_specs[input];
-	IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
-	if (is.rewrite_flowid(flowid, rewritten_flowid, 0) == rw_addmap)
-	    m = add_flow(ip_p, flowid, rewritten_flowid, input);
-    }
-    return m;
+	IPRewriterEntry *m = _map[click_current_cpu_id()].get(flowid);
+
+	if (m && ip_p && m->flow()->ip_p() && m->flow()->ip_p() != ip_p)
+		return 0;
+	if (!m && (unsigned) input < (unsigned) _input_specs.size()) {
+		IPRewriterInput &is = _input_specs[input];
+		IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
+		if (is.rewrite_flowid(flowid, rewritten_flowid, 0) == rw_addmap)
+			m = add_flow(ip_p, flowid, rewritten_flowid, input);
+	}
+
+	return m;
 }
 
 IPRewriterEntry *
 IPRewriterBase::store_flow(IPRewriterFlow *flow, int input,
-			   Map &map, Map *reply_map_ptr)
+				Map &map, Map *reply_map_ptr)
 {
-    IPRewriterBase *reply_element = _input_specs[input].reply_element;
-    if ((unsigned) flow->entry(false).output() >= (unsigned) noutputs()
-	|| (unsigned) flow->entry(true).output() >= (unsigned) reply_element->noutputs()) {
-	flow->owner()->owner->destroy_flow(flow);
-	return 0;
-    }
-
-    IPRewriterEntry *old = map.set(&flow->entry(false));
-    assert(!old);
-
-    if (!reply_map_ptr)
-	reply_map_ptr = &reply_element->_map;
-    old = reply_map_ptr->set(&flow->entry(true));
-    if (unlikely(old)) {		// Assume every map has the same heap.
-	if (likely(old->flow() != flow))
-	    old->flow()->destroy(_heap);
-    }
-
-    Vector<IPRewriterFlow *> &myheap = _heap->_heaps[flow->guaranteed()];
-    myheap.push_back(flow);
-    push_heap(myheap.begin(), myheap.end(),
-	      IPRewriterFlow::heap_less(), IPRewriterFlow::heap_place());
-    ++_input_specs[input].count;
-
-    if (unlikely(_heap->size() > _heap->capacity())) {
-	// This may destroy the newly added mapping, if it has the lowest
-	// expiration time.  How can we tell?  If (1) flows are added to the
-	// heap one at a time, so the heap was formerly no bigger than the
-	// capacity, and (2) 'flow' expires in the future, then we will only
-	// destroy 'flow' if it's the top of the heap.
-	click_jiffies_t now_j = click_jiffies();
-	assert(click_jiffies_less(now_j, flow->expiry())
-	       && _heap->size() == _heap->capacity() + 1);
-	if (shrink_heap_for_new_flow(flow, now_j)) {
-	    ++_input_specs[input].failures;
-	    return 0;
+	IPRewriterBase *reply_element = _input_specs[input].reply_element;
+	if (	(unsigned) flow->entry(false).output() >= (unsigned) noutputs() ||
+			(unsigned) flow->entry(true).output() >= (unsigned) reply_element->noutputs()) {
+		flow->owner()->owner->destroy_flow(flow);
+		return 0;
 	}
-    }
 
-    if (map.unbalanced())
-	map.rehash(map.bucket_count() + 1);
-    if (reply_map_ptr != &map && reply_map_ptr->unbalanced())
-	reply_map_ptr->rehash(reply_map_ptr->bucket_count() + 1);
-    return &flow->entry(false);
+	IPRewriterEntry *old = map.set(&flow->entry(false));
+	assert(!old);
+
+	if (!reply_map_ptr)
+		reply_map_ptr = &reply_element->_map[click_current_cpu_id()];
+
+	old = reply_map_ptr->set(&flow->entry(true));
+	if (unlikely(old)) {		// Assume every map has the same heap.
+		if (likely(old->flow() != flow))
+			old->flow()->destroy(_heap[click_current_cpu_id()]);
+	}
+
+	Vector<IPRewriterFlow *> &myheap = _heap[click_current_cpu_id()]->_heaps[flow->guaranteed()];
+	myheap.push_back(flow);
+	push_heap(myheap.begin(), myheap.end(),
+		IPRewriterFlow::heap_less(), IPRewriterFlow::heap_place());
+	++_input_specs[input].count;
+
+	if (unlikely(_heap[click_current_cpu_id()]->size() > _heap[click_current_cpu_id()]->capacity())) {
+		// This may destroy the newly added mapping, if it has the lowest
+		// expiration time.  How can we tell?  If (1) flows are added to the
+		// heap one at a time, so the heap was formerly no bigger than the
+		// capacity, and (2) 'flow' expires in the future, then we will only
+		// destroy 'flow' if it's the top of the heap.
+		click_jiffies_t now_j = click_jiffies();
+		assert(click_jiffies_less(now_j, flow->expiry()) &&
+				_heap[click_current_cpu_id()]->size() == _heap[click_current_cpu_id()]->capacity() + 1);
+		if (shrink_heap_for_new_flow(flow, now_j)) {
+			++_input_specs[input].failures;
+			return 0;
+		}
+	}
+
+	if (map.unbalanced())
+		map.rehash(map.bucket_count() + 1);
+	if (reply_map_ptr != &map && reply_map_ptr->unbalanced())
+		reply_map_ptr->rehash(reply_map_ptr->bucket_count() + 1);
+
+	return &flow->entry(false);
 }
 
 void
 IPRewriterBase::shift_heap_best_effort(click_jiffies_t now_j)
 {
-    // Shift flows with expired guarantees to the best-effort heap.
-    Vector<IPRewriterFlow *> &guaranteed_heap = _heap->_heaps[1];
-    while (guaranteed_heap.size() && guaranteed_heap[0]->expired(now_j)) {
-	IPRewriterFlow *mf = guaranteed_heap[0];
-	click_jiffies_t new_expiry = mf->owner()->owner->best_effort_expiry(mf);
-	mf->change_expiry(_heap, false, new_expiry);
-    }
+	// Shift flows with expired guarantees to the best-effort heap.
+	Vector<IPRewriterFlow *> &guaranteed_heap = _heap[click_current_cpu_id()]->_heaps[1];
+	while (guaranteed_heap.size() && guaranteed_heap[0]->expired(now_j)) {
+		IPRewriterFlow *mf = guaranteed_heap[0];
+		click_jiffies_t new_expiry = mf->owner()->owner->best_effort_expiry(mf);
+		mf->change_expiry(_heap[click_current_cpu_id()], false, new_expiry);
+	}
 }
 
 bool
 IPRewriterBase::shrink_heap_for_new_flow(IPRewriterFlow *flow,
 					 click_jiffies_t now_j)
 {
-    shift_heap_best_effort(now_j);
-    // At this point, all flows in the guarantee heap expire in the future.
-    // So remove the next-to-expire best-effort flow, unless there are none.
-    // In that case we always remove the current flow to honor previous
-    // guarantees (= admission control).
-    IPRewriterFlow *deadf;
-    if (_heap->_heaps[0].empty()) {
-	assert(flow->guaranteed());
-	deadf = flow;
-    } else
-	deadf = _heap->_heaps[0][0];
-    deadf->destroy(_heap);
-    return deadf == flow;
+	shift_heap_best_effort(now_j);
+
+	// At this point, all flows in the guarantee heap expire in the future.
+	// So remove the next-to-expire best-effort flow, unless there are none.
+	// In that case we always remove the current flow to honor previous
+	// guarantees (= admission control).
+	IPRewriterFlow *deadf;
+	if (_heap[click_current_cpu_id()]->_heaps[0].empty()) {
+		assert(flow->guaranteed());
+		deadf = flow;
+	}
+	else
+		deadf = _heap[click_current_cpu_id()]->_heaps[0][0];
+	deadf->destroy(_heap[click_current_cpu_id()]);
+
+	return deadf == flow;
 }
 
 void
 IPRewriterBase::shrink_heap(bool clear_all)
 {
-    click_jiffies_t now_j = click_jiffies();
-    shift_heap_best_effort(now_j);
-    Vector<IPRewriterFlow *> &best_effort_heap = _heap->_heaps[0];
-    while (best_effort_heap.size() && best_effort_heap[0]->expired(now_j))
-	best_effort_heap[0]->destroy(_heap);
-
-    int32_t capacity = clear_all ? 0 : _heap->_capacity;
-    while (_heap->size() > capacity) {
-	IPRewriterFlow *deadf = _heap->_heaps[_heap->_heaps[0].empty()][0];
-	deadf->destroy(_heap);
-    }
+	click_jiffies_t now_j = click_jiffies();
+	shift_heap_best_effort(now_j);
+	Vector<IPRewriterFlow *> &best_effort_heap = _heap[click_current_cpu_id()]->_heaps[0];
+	while (best_effort_heap.size() && best_effort_heap[0]->expired(now_j))
+		best_effort_heap[0]->destroy(_heap[click_current_cpu_id()]);
+
+	int32_t capacity = clear_all ? 0 : _heap[click_current_cpu_id()]->_capacity;
+	while (_heap[click_current_cpu_id()]->size() > capacity) {
+		IPRewriterFlow *deadf = _heap[click_current_cpu_id()]->_heaps[_heap[click_current_cpu_id()]->_heaps[0].empty()][0];
+		deadf->destroy(_heap[click_current_cpu_id()]);
+	}
 }
 
 void
 IPRewriterBase::gc_timer_hook(Timer *t, void *user_data)
 {
-    IPRewriterBase *rw = static_cast<IPRewriterBase *>(user_data);
-    rw->shrink_heap(false);
-    if (rw->_gc_interval_sec)
-	t->reschedule_after_sec(rw->_gc_interval_sec);
+	IPRewriterBase *rw = static_cast<IPRewriterBase *>(user_data);
+	rw->shrink_heap(false);
+	if (rw->_gc_interval_sec)
+		t->reschedule_after_sec(rw->_gc_interval_sec);
 }
 
 String
 IPRewriterBase::read_handler(Element *e, void *user_data)
 {
-    IPRewriterBase *rw = static_cast<IPRewriterBase *>(e);
-    intptr_t what = reinterpret_cast<intptr_t>(user_data);
-    StringAccum sa;
-
-    switch (what) {
-    case h_nmappings: {
-	uint32_t count = 0;
-	for (int i = 0; i < rw->_input_specs.size(); ++i)
-	    count += rw->_input_specs[i].count;
-	sa << count;
-	break;
-    }
-    case h_mapping_failures: {
-	uint32_t count = 0;
-	for (int i = 0; i < rw->_input_specs.size(); ++i)
-	    count += rw->_input_specs[i].failures;
-	sa << count;
-	break;
-    }
-    case h_size:
-	sa << rw->_heap->size();
-	break;
-    case h_capacity:
-	sa << rw->_heap->_capacity;
-	break;
-    default:
-	for (int i = 0; i < rw->_input_specs.size(); ++i) {
-	    if (what != h_patterns && what != i)
-		continue;
-	    switch (rw->_input_specs[i].kind) {
-	    case IPRewriterInput::i_drop:
-		sa << "<drop>";
-		break;
-	    case IPRewriterInput::i_nochange:
-		sa << "<nochange>";
-		break;
-	    case IPRewriterInput::i_keep:
-		sa << "<keep>";
-		break;
-	    case IPRewriterInput::i_pattern:
-		sa << rw->_input_specs[i].u.pattern->unparse();
-		break;
-	    case IPRewriterInput::i_mapper:
-		sa << "<mapper>";
-		break;
-	    }
-	    if (rw->_input_specs[i].count)
-		sa << " [" << rw->_input_specs[i].count << ']';
-	    sa << '\n';
+	IPRewriterBase *rw = static_cast<IPRewriterBase *>(e);
+	intptr_t what = reinterpret_cast<intptr_t>(user_data);
+	StringAccum sa;
+
+	switch (what) {
+		case h_nmappings: {
+			uint32_t count = 0;
+			for (int i = 0; i < rw->_input_specs.size(); ++i)
+				count += rw->_input_specs[i].count;
+			sa << count;
+			break;
+		}
+		case h_mapping_failures: {
+			uint32_t count = 0;
+			for (int i = 0; i < rw->_input_specs.size(); ++i)
+				count += rw->_input_specs[i].failures;
+			sa << count;
+			break;
+		}
+		case h_size:
+			sa << rw->_heap[click_current_cpu_id()]->size();
+			break;
+		case h_capacity:
+			sa << rw->_heap[click_current_cpu_id()]->_capacity;
+			break;
+		default:
+			for (int i = 0; i < rw->_input_specs.size(); ++i) {
+				if (what != h_patterns && what != i)
+					continue;
+
+				switch (rw->_input_specs[i].kind) {
+					case IPRewriterInput::i_drop:
+						sa << "<drop>";
+						break;
+					case IPRewriterInput::i_nochange:
+						sa << "<nochange>";
+						break;
+					case IPRewriterInput::i_keep:
+						sa << "<keep>";
+						break;
+					case IPRewriterInput::i_pattern:
+						sa << rw->_input_specs[i].u.pattern->unparse();
+						break;
+					case IPRewriterInput::i_mapper:
+						sa << "<mapper>";
+						break;
+				}
+				if (rw->_input_specs[i].count)
+					sa << " [" << rw->_input_specs[i].count << ']';
+				sa << '\n';
+			}
+			break;
 	}
-	break;
-    }
-    return sa.take_string();
+
+	return sa.take_string();
 }
 
 int
 IPRewriterBase::write_handler(const String &str, Element *e, void *user_data, ErrorHandler *errh)
 {
-    IPRewriterBase *rw = static_cast<IPRewriterBase *>(e);
-    intptr_t what = reinterpret_cast<intptr_t>(user_data);
-    if (what == h_capacity) {
-	if (Args(e, errh).push_back_words(str)
-	    .read_mp("CAPACITY", rw->_heap->_capacity)
-	    .complete() < 0)
-	    return -1;
-	rw->shrink_heap(false);
-	return 0;
-    } else if (what == h_clear) {
-	rw->shrink_heap(true);
-	return 0;
-    } else
+	IPRewriterBase *rw = static_cast<IPRewriterBase *>(e);
+	intptr_t what = reinterpret_cast<intptr_t>(user_data);
+	if (what == h_capacity) {
+		if (Args(e, errh).push_back_words(str)
+			.read_mp("CAPACITY", rw->_heap[click_current_cpu_id()]->_capacity)
+			.complete() < 0)
+			return -1;
+		rw->shrink_heap(false);
+		return 0;
+	}
+	else if (what == h_clear) {
+		rw->shrink_heap(true);
+		return 0;
+	}
+
 	return -1;
 }
 
 int
 IPRewriterBase::pattern_write_handler(const String &str, Element *e, void *user_data, ErrorHandler *errh)
 {
-    IPRewriterBase *rw = static_cast<IPRewriterBase *>(e);
-    intptr_t what = reinterpret_cast<intptr_t>(user_data);
-    IPRewriterInput is;
-    int r = rw->parse_input_spec(str, is, what, errh);
-    if (r >= 0) {
-	IPRewriterInput *spec = &rw->_input_specs[what];
-
-	// remove all existing flows created by this input
-	for (int which_heap = 0; which_heap < 2; ++which_heap) {
-	    Vector<IPRewriterFlow *> &myheap = rw->_heap->_heaps[which_heap];
-	    for (int i = myheap.size() - 1; i >= 0; --i)
-		if (myheap[i]->owner() == spec) {
-		    myheap[i]->destroy(rw->_heap);
-		    if (i < myheap.size())
-			++i;
+	IPRewriterBase *rw = static_cast<IPRewriterBase *>(e);
+	intptr_t what = reinterpret_cast<intptr_t>(user_data);
+	IPRewriterInput is;
+
+	int r = rw->parse_input_spec(str, is, what, errh);
+	if (r >= 0) {
+		IPRewriterInput *spec = &rw->_input_specs[what];
+
+		// remove all existing flows created by this input
+		for (int which_heap = 0; which_heap < 2; ++which_heap) {
+			Vector<IPRewriterFlow *> &myheap = rw->_heap[click_current_cpu_id()]->_heaps[which_heap];
+			for (int i = myheap.size() - 1; i >= 0; --i)
+				if (myheap[i]->owner() == spec) {
+					myheap[i]->destroy(rw->_heap[click_current_cpu_id()]);
+					if (i < myheap.size())
+					++i;
+				}
 		}
+
+		// change pattern
+		if (spec->kind == IPRewriterInput::i_pattern)
+			spec->u.pattern->unuse();
+		*spec = is;
 	}
 
-	// change pattern
-	if (spec->kind == IPRewriterInput::i_pattern)
-	    spec->u.pattern->unuse();
-	*spec = is;
-    }
-    return 0;
+	return 0;
 }
 
 void
 IPRewriterBase::add_rewriter_handlers(bool writable_patterns)
 {
-    add_read_handler("table_size", read_handler, h_nmappings);
-    add_read_handler("nmappings", read_handler, h_nmappings, Handler::h_deprecated);
-    add_read_handler("mapping_failures", read_handler, h_mapping_failures);
-    add_read_handler("patterns", read_handler, h_patterns);
-    add_read_handler("size", read_handler, h_size);
-    add_read_handler("capacity", read_handler, h_capacity);
-    add_write_handler("capacity", write_handler, h_capacity);
-    add_write_handler("clear", write_handler, h_clear);
-    for (int i = 0; i < ninputs(); ++i) {
-	String name = "pattern" + String(i);
-	add_read_handler(name, read_handler, i);
-	if (writable_patterns)
-	    add_write_handler(name, pattern_write_handler, i);
-    }
+	add_read_handler ("table_size", read_handler, h_nmappings);
+	add_read_handler ("nmappings", read_handler, h_nmappings, Handler::h_deprecated);
+	add_read_handler ("mapping_failures", read_handler, h_mapping_failures);
+	add_read_handler ("patterns", read_handler, h_patterns);
+	add_read_handler ("size", read_handler, h_size);
+	add_read_handler ("capacity", read_handler, h_capacity);
+	add_write_handler("capacity", write_handler, h_capacity);
+	add_write_handler("clear", write_handler, h_clear);
+
+	for (int i = 0; i < ninputs(); ++i) {
+		String name = "pattern" + String(i);
+		add_read_handler(name, read_handler, i);
+		if (writable_patterns)
+			add_write_handler(name, pattern_write_handler, i);
+	}
 }
 
 int
 IPRewriterBase::llrpc(unsigned command, void *data)
 {
-    if (command == CLICK_LLRPC_IPREWRITER_MAP_TCP) {
-	// Data	: unsigned saddr, daddr; unsigned short sport, dport
-	// Incoming : the flow ID
-	// Outgoing : If there is a mapping for that flow ID, then stores the
-	//	      mapping into 'data' and returns zero. Otherwise, returns
-	//	      -EAGAIN.
-
-	IPFlowID *val = reinterpret_cast<IPFlowID *>(data);
-	IPRewriterEntry *m = get_entry(IP_PROTO_TCP, *val, -1);
-	if (!m)
-	    return -EAGAIN;
-	*val = m->rewritten_flowid();
-	return 0;
-
-    } else if (command == CLICK_LLRPC_IPREWRITER_MAP_UDP) {
-	// Data	: unsigned saddr, daddr; unsigned short sport, dport
-	// Incoming : the flow ID
-	// Outgoing : If there is a mapping for that flow ID, then stores the
-	//	      mapping into 'data' and returns zero. Otherwise, returns
-	//	      -EAGAIN.
-
-	IPFlowID *val = reinterpret_cast<IPFlowID *>(data);
-	IPRewriterEntry *m = get_entry(IP_PROTO_UDP, *val, -1);
-	if (!m)
-	    return -EAGAIN;
-	*val = m->rewritten_flowid();
-	return 0;
+	if (command == CLICK_LLRPC_IPREWRITER_MAP_TCP) {
+		// Data	: unsigned saddr, daddr; unsigned short sport, dport
+		// Incoming : the flow ID
+		// Outgoing : If there is a mapping for that flow ID, then stores the
+		//	      mapping into 'data' and returns zero. Otherwise, returns
+		//	      -EAGAIN.
+
+		IPFlowID *val = reinterpret_cast<IPFlowID *>(data);
+		IPRewriterEntry *m = get_entry(IP_PROTO_TCP, *val, -1);
+		if (!m)
+			return -EAGAIN;
+		*val = m->rewritten_flowid();
+		return 0;
+	}
+	else if (command == CLICK_LLRPC_IPREWRITER_MAP_UDP) {
+		// Data	: unsigned saddr, daddr; unsigned short sport, dport
+		// Incoming : the flow ID
+		// Outgoing : If there is a mapping for that flow ID, then stores the
+		//	      mapping into 'data' and returns zero. Otherwise, returns
+		//	      -EAGAIN.
+
+		IPFlowID *val = reinterpret_cast<IPFlowID *>(data);
+		IPRewriterEntry *m = get_entry(IP_PROTO_UDP, *val, -1);
+		if (!m)
+			return -EAGAIN;
+		*val = m->rewritten_flowid();
+		return 0;
+	}
+	else
+		return Element::llrpc(command, data);
+}
 
-    } else
-	return Element::llrpc(command, data);
+void
+IPRewriterBase::print_flow_info(IPRewriterEntry *m, click_ip *iph)
+{
+	if (!m || !iph)
+		return;
+
+	click_chatter("---->        IP Proto: %d\n", iph->ip_p);
+	click_chatter("---->        Src   IP: %s\n", m->flowid().saddr().s().c_str());
+	click_chatter("---->        Src Port: %d\n", htons(m->flowid().sport()));
+	click_chatter("---->        Dst   IP: %s\n", m->flowid().daddr().s().c_str());
+	click_chatter("---->        Dst Port: %d\n", htons(m->flowid().dport()));
+	click_chatter("---->       Direction: %s\n", m->direction()? "Response":"Forward");
+	click_chatter("----> Forward Outport: %d\n", m->output());
+	click_chatter("\n");
 }
 
 ELEMENT_REQUIRES(IPRewriterMapping IPRewriterPattern)
diff --git a/elements/ip/iprewriterbase.hh b/elements/ip/iprewriterbase.hh
index b7ced3a..94e4efc 100644
--- a/elements/ip/iprewriterbase.hh
+++ b/elements/ip/iprewriterbase.hh
@@ -3,246 +3,281 @@
 #define CLICK_IPREWRITERBASE_HH
 #include <click/timer.hh>
 #include "elements/ip/iprwmapping.hh"
+#include <click/batchelement.hh>
 #include <click/bitvector.hh>
 CLICK_DECLS
 class IPMapper;
 class IPRewriterPattern;
 
-class IPRewriterInput { public:
-    enum {
-	i_drop, i_nochange, i_keep, i_pattern, i_mapper
-    };
-    IPRewriterBase *owner;
-    int owner_input;
-    int kind;
-    int foutput;
-    IPRewriterBase *reply_element;
-    int routput;
-    uint32_t count;
-    uint32_t failures;
-    union {
-	IPRewriterPattern *pattern;
-	IPMapper *mapper;
-    } u;
-
-    IPRewriterInput()
-	: kind(i_drop), foutput(-1), routput(-1), count(0), failures(0) {
-	u.pattern = 0;
-    }
-
-    enum {
-	mapid_default = 0, mapid_iprewriter_udp = 1
-    };
-
-    inline int rewrite_flowid(const IPFlowID &flowid,
-			      IPFlowID &rewritten_flowid,
-			      Packet *p, int mapid = mapid_default);
+class IPRewriterInput {
+	public:
+		enum {
+			i_drop, i_nochange, i_keep, i_pattern, i_mapper
+		};
+
+		IPRewriterBase *owner;
+		int owner_input;
+		int kind;
+		int foutput;
+		IPRewriterBase *reply_element;
+		int routput;
+		uint32_t count;
+		uint32_t failures;
+		union {
+			IPRewriterPattern *pattern;
+			IPMapper *mapper;
+		} u;
+
+		IPRewriterInput()
+			: kind(i_drop), foutput(-1), routput(-1), count(0), failures(0) {
+			u.pattern = 0;
+		}
+
+		enum {
+			mapid_default = 0, mapid_iprewriter_udp = 1
+		};
+
+		inline int rewrite_flowid(
+			const IPFlowID &flowid,
+			IPFlowID &rewritten_flowid,
+			Packet *p, int mapid = mapid_default
+		);
 };
 
-class IPRewriterHeap { public:
-
-    IPRewriterHeap()
-	: _capacity(0x7FFFFFFF), _use_count(1) {
-    }
-    ~IPRewriterHeap() {
-	assert(size() == 0);
-    }
-
-    void use() {
-	++_use_count;
-    }
-    void unuse() {
-	assert(_use_count > 0);
-	if (--_use_count == 0)
-	    delete this;
-    }
-
-    Vector<IPRewriterFlow *>::size_type size() const {
-	return _heaps[0].size() + _heaps[1].size();
-    }
-    int32_t capacity() const {
-	return _capacity;
-    }
-
-  private:
-
-    enum {
-	h_best_effort = 0, h_guarantee = 1
-    };
-    Vector<IPRewriterFlow *> _heaps[2];
-    int32_t _capacity;
-    uint32_t _use_count;
-
-    friend class IPRewriterBase;
-    friend class IPRewriterFlow;
-
+class IPRewriterHeap {
+	public:
+
+		IPRewriterHeap()
+			: _capacity(0x7FFFFFFF), _use_count(1) {
+		}
+		~IPRewriterHeap() {
+			assert(size() == 0);
+		}
+
+		void use() {
+			++_use_count;
+		}
+
+		void unuse() {
+			assert(_use_count > 0);
+			if (--_use_count == 0)
+				delete this;
+		}
+
+		Vector<IPRewriterFlow *>::size_type size() const {
+			return _heaps[0].size() + _heaps[1].size();
+		}
+
+		int32_t capacity() const {
+			return _capacity;
+		}
+
+	private:
+		enum {
+			h_best_effort = 0, h_guarantee = 1
+		};
+
+		Vector<IPRewriterFlow *> _heaps[2];
+		int32_t  _capacity;
+		uint32_t _use_count;
+
+		friend class IPRewriterBase;
+		friend class IPRewriterFlow;
 };
 
-class IPRewriterBase : public Element { public:
-
-    typedef HashContainer<IPRewriterEntry> Map;
-    enum {
-	rw_drop = -1, rw_addmap = -2
-    };
-
-    IPRewriterBase() CLICK_COLD;
-    ~IPRewriterBase() CLICK_COLD;
-
-    enum ConfigurePhase {
-	CONFIGURE_PHASE_PATTERNS = CONFIGURE_PHASE_INFO,
-	CONFIGURE_PHASE_REWRITER = CONFIGURE_PHASE_DEFAULT,
-	CONFIGURE_PHASE_MAPPER = CONFIGURE_PHASE_REWRITER - 1,
-	CONFIGURE_PHASE_USER = CONFIGURE_PHASE_REWRITER + 1
-    };
-
-    const char *port_count() const	{ return "1-/1-"; }
-    const char *processing() const	{ return PUSH; }
-
-    int configure_phase() const		{ return CONFIGURE_PHASE_REWRITER; }
-    int configure(Vector<String> &conf, ErrorHandler *errh) CLICK_COLD;
-    int initialize(ErrorHandler *errh) CLICK_COLD;
-    void add_rewriter_handlers(bool writable_patterns);
-    void cleanup(CleanupStage) CLICK_COLD;
-
-    const IPRewriterHeap *flow_heap() const {
-	return _heap;
-    }
-    IPRewriterBase *reply_element(int input) const {
-	return _input_specs[input].reply_element;
-    }
-    virtual HashContainer<IPRewriterEntry> *get_map(int mapid) {
-	return likely(mapid == IPRewriterInput::mapid_default) ? &_map : 0;
-    }
-
-    enum {
-	get_entry_check = -1, get_entry_reply = -2
-    };
-    virtual IPRewriterEntry *get_entry(int ip_p, const IPFlowID &flowid,
-				       int input);
-    virtual IPRewriterEntry *add_flow(int ip_p, const IPFlowID &flowid,
-				      const IPFlowID &rewritten_flowid,
-				      int input) = 0;
-    virtual void destroy_flow(IPRewriterFlow *flow) = 0;
-    virtual click_jiffies_t best_effort_expiry(const IPRewriterFlow *flow) {
-	return flow->expiry() + _timeouts[0] - _timeouts[1];
-    }
-
-    int llrpc(unsigned command, void *data);
-
-  protected:
-
-    Map _map;
-
-    Vector<IPRewriterInput> _input_specs;
-
-    IPRewriterHeap *_heap;
-    uint32_t _timeouts[2];
-    uint32_t _gc_interval_sec;
-    Timer _gc_timer;
-
-    enum {
-	default_timeout = 300,	   // 5 minutes
-	default_guarantee = 5,	   // 5 seconds
-	default_gc_interval = 60 * 15 // 15 minutes
-    };
-
-    static uint32_t relevant_timeout(const uint32_t timeouts[2]) {
-	return timeouts[1] ? timeouts[1] : timeouts[0];
-    }
-
-    IPRewriterEntry *store_flow(IPRewriterFlow *flow, int input,
-				Map &map, Map *reply_map_ptr = 0);
-    inline void unmap_flow(IPRewriterFlow *flow,
-			   Map &map, Map *reply_map_ptr = 0);
-
-    static void gc_timer_hook(Timer *t, void *user_data);
-
-    int parse_input_spec(const String &str, IPRewriterInput &is,
-			 int input_number, ErrorHandler *errh);
-
-    enum {			// < 0 because individual patterns are >= 0
-	h_nmappings = -1, h_mapping_failures = -2, h_patterns = -3,
-	h_size = -4, h_capacity = -5, h_clear = -6
-    };
-    static String read_handler(Element *e, void *user_data) CLICK_COLD;
-    static int write_handler(const String &str, Element *e, void *user_data, ErrorHandler *errh) CLICK_COLD;
-    static int pattern_write_handler(const String &str, Element *e, void *user_data, ErrorHandler *errh) CLICK_COLD;
-
-    friend int IPRewriterInput::rewrite_flowid(const IPFlowID &flowid,
-			IPFlowID &rewritten_flowid, Packet *p, int mapid);
-
-  private:
-
-    void shift_heap_best_effort(click_jiffies_t now_j);
-    bool shrink_heap_for_new_flow(IPRewriterFlow *flow, click_jiffies_t now_j);
-    void shrink_heap(bool clear_all);
-
-    friend class IPRewriterFlow;
-
+class IPRewriterBase : public BatchElement {
+	public:
+		typedef HashContainer<IPRewriterEntry> Map;
+		enum {
+			rw_drop = -1, rw_addmap = -2
+		};
+
+		IPRewriterBase () CLICK_COLD;
+		~IPRewriterBase() CLICK_COLD;
+
+		enum ConfigurePhase {
+			CONFIGURE_PHASE_PATTERNS = CONFIGURE_PHASE_INFO,
+			CONFIGURE_PHASE_REWRITER = CONFIGURE_PHASE_DEFAULT,
+			CONFIGURE_PHASE_MAPPER = CONFIGURE_PHASE_REWRITER - 1,
+			CONFIGURE_PHASE_USER = CONFIGURE_PHASE_REWRITER + 1
+		};
+
+		const char *port_count() const	{ return "1-/1-"; }
+		const char *processing() const	{ return PUSH; }
+
+		int configure_phase() const { return CONFIGURE_PHASE_REWRITER; }
+		int configure(Vector<String> &conf, ErrorHandler *errh) CLICK_COLD;
+		int initialize(ErrorHandler *errh) CLICK_COLD;
+		void add_rewriter_handlers(bool writable_patterns);
+		void cleanup(CleanupStage) CLICK_COLD;
+
+		const IPRewriterHeap *flow_heap() const {
+			return _heap[click_current_cpu_id()];
+		}
+
+		IPRewriterBase *reply_element(int input) const {
+			return _input_specs[input].reply_element;
+		}
+		virtual HashContainer<IPRewriterEntry> *get_map(int mapid) {
+			return likely(mapid == IPRewriterInput::mapid_default) ?
+				&_map[click_current_cpu_id()] : 0;
+		}
+
+		enum {
+			get_entry_check = -1, get_entry_reply = -2
+		};
+
+		virtual IPRewriterEntry *get_entry(int ip_p, const IPFlowID &flowid, int input);
+		virtual IPRewriterEntry *add_flow (int ip_p, const IPFlowID &flowid,
+											const IPFlowID &rewritten_flowid,
+											int input) = 0;
+		virtual void destroy_flow(IPRewriterFlow *flow) = 0;
+		virtual click_jiffies_t best_effort_expiry(const IPRewriterFlow *flow) {
+			return flow->expiry() +
+					_timeouts[click_current_cpu_id()][0] -
+					_timeouts[click_current_cpu_id()][1];
+		}
+
+		int llrpc(unsigned command, void *data);
+
+	protected:
+		unsigned _mem_units_no;
+
+		Map *_map;
+		Vector<IPRewriterInput> _input_specs;
+		IPRewriterHeap **_heap;
+		uint32_t **_timeouts;
+
+		uint32_t _gc_interval_sec;
+		Timer _gc_timer;
+
+		// SNF extensions: Elements that derive from this class apply these operations
+		bool _drop_bcast;           // DropBroadcast
+		bool _ipgw_opt;             // IPGWOptions
+		bool _fix_ip_src;           // FixIPSrc
+		bool _ip_fragment;          // IPFragmenter
+		bool _dec_ip_ttl;           // DecIPTTL
+		bool _ip_out_combo;         // DropBroadcast + IPGWOptions + FixIPSrc + DecIPTTL
+		bool _calc_checksum;
+
+		struct in_addr _my_ip;      // For IPGWOptions, FixIPSrc
+		unsigned       _mtu;        // For IP Fragmenter
+		unsigned       _headroom;
+		bool           _honor_df;
+		bool           _verbose;
+
+		enum {
+			default_timeout     = 300,    // 5 minutes
+			default_guarantee   = 5,      // 5 seconds
+			default_gc_interval = 60 * 15 // 15 minutes
+		};
+
+		static uint32_t relevant_timeout(const uint32_t timeouts[2]) {
+			return timeouts[1] ? timeouts[1] : timeouts[0];
+		}
+
+		IPRewriterEntry *store_flow(IPRewriterFlow *flow, int input,
+									Map &map, Map *reply_map_ptr = 0);
+		inline void unmap_flow(IPRewriterFlow *flow,
+								Map &map, Map *reply_map_ptr = 0);
+
+		static void gc_timer_hook(Timer *t, void *user_data);
+
+		int parse_input_spec(const String &str, IPRewriterInput &is,
+							int input_number, ErrorHandler *errh);
+
+		enum {			// < 0 because individual patterns are >= 0
+			h_nmappings = -1, h_mapping_failures = -2, h_patterns = -3,
+			h_size = -4, h_capacity = -5, h_clear = -6
+		};
+
+		static String read_handler(Element *e, void *user_data) CLICK_COLD;
+		static int write_handler(
+			const String &str, Element *e, void *user_data, ErrorHandler *errh
+		) CLICK_COLD;
+		static int pattern_write_handler(
+			const String &str, Element *e, void *user_data, ErrorHandler *errh
+		) CLICK_COLD;
+
+		friend int IPRewriterInput::rewrite_flowid(
+			const IPFlowID &flowid,	IPFlowID &rewritten_flowid,
+			Packet *p, int mapid
+		);
+
+		void print_flow_info(IPRewriterEntry *m, click_ip *iph);
+
+	private:
+		void shift_heap_best_effort(click_jiffies_t now_j);
+		bool shrink_heap_for_new_flow(IPRewriterFlow *flow, click_jiffies_t now_j);
+		void shrink_heap(bool clear_all);
+
+		friend class IPRewriterFlow;
 };
 
 
-class IPMapper { public:
-
-    IPMapper()				{ }
-    virtual ~IPMapper()			{ }
-
-    virtual void notify_rewriter(IPRewriterBase *user, IPRewriterInput *input,
-				 ErrorHandler *errh);
-    virtual int rewrite_flowid(IPRewriterInput *input,
-			       const IPFlowID &flowid,
-			       IPFlowID &rewritten_flowid,
-			       Packet *p, int mapid);
+class IPMapper {
+	public:
+		IPMapper() { }
+		virtual ~IPMapper()	{ }
 
+		virtual void notify_rewriter(IPRewriterBase *user, IPRewriterInput *input,
+		ErrorHandler *errh);
+		virtual int rewrite_flowid(
+			IPRewriterInput *input,
+			const IPFlowID &flowid,
+			IPFlowID &rewritten_flowid,
+			Packet *p, int mapid
+		);
 };
 
 
 inline int
 IPRewriterInput::rewrite_flowid(const IPFlowID &flowid,
-				IPFlowID &rewritten_flowid,
-				Packet *p, int mapid)
+								IPFlowID &rewritten_flowid,
+								Packet *p, int mapid)
 {
-    int i;
-    switch (kind) {
-    case i_nochange:
-	return foutput;
-    case i_keep:
-	rewritten_flowid = flowid;
-	return IPRewriterBase::rw_addmap;
-    case i_pattern: {
-	HashContainer<IPRewriterEntry> *reply_map;
-	if (likely(mapid == mapid_default))
-	    reply_map = &reply_element->_map;
-	else
-	    reply_map = reply_element->get_map(mapid);
-	i = u.pattern->rewrite_flowid(flowid, rewritten_flowid, *reply_map);
-	goto check_for_failure;
-    }
-    case i_mapper:
-	i = u.mapper->rewrite_flowid(this, flowid, rewritten_flowid, p, mapid);
-	goto check_for_failure;
-    check_for_failure:
-	if (i == IPRewriterBase::rw_drop)
-	    ++failures;
-	return i;
-    default:
-	return IPRewriterBase::rw_drop;
-    }
+	int i;
+	switch (kind) {
+		case i_nochange:
+			return foutput;
+		case i_keep:
+			rewritten_flowid = flowid;
+			return IPRewriterBase::rw_addmap;
+		case i_pattern: {
+			HashContainer<IPRewriterEntry> *reply_map;
+			if (likely(mapid == mapid_default))
+				reply_map = &reply_element->_map[click_current_cpu_id()];
+			else
+				reply_map = reply_element->get_map(mapid);
+			i = u.pattern->rewrite_flowid(flowid, rewritten_flowid, *reply_map);
+			goto check_for_failure;
+		}
+		case i_mapper:
+			i = u.mapper->rewrite_flowid(this, flowid, rewritten_flowid, p, mapid);
+			goto check_for_failure;
+			check_for_failure:
+			if (i == IPRewriterBase::rw_drop)
+				++failures;
+			return i;
+		default:
+			return IPRewriterBase::rw_drop;
+	}
 }
 
 inline void
-IPRewriterBase::unmap_flow(IPRewriterFlow *flow, Map &map,
-			   Map *reply_map_ptr)
+IPRewriterBase::unmap_flow(IPRewriterFlow *flow, Map &map, Map *reply_map_ptr)
 {
-    //click_chatter("kill %s", hashkey().s().c_str());
-    if (!reply_map_ptr)
-	reply_map_ptr = &flow->owner()->reply_element->_map;
-    Map::iterator it = map.find(flow->entry(0).hashkey());
-    if (it.get() == &flow->entry(0))
-	map.erase(it);
-    it = reply_map_ptr->find(flow->entry(1).hashkey());
-    if (it.get() == &flow->entry(1))
-	reply_map_ptr->erase(it);
+	//click_chatter("kill %s", hashkey().s().c_str());
+	if (!reply_map_ptr)
+		reply_map_ptr = &flow->owner()->reply_element->_map[click_current_cpu_id()];
+
+	Map::iterator it = map.find(flow->entry(0).hashkey());
+	if (it.get() == &flow->entry(0))
+		map.erase(it);
+
+	it = reply_map_ptr->find(flow->entry(1).hashkey());
+	if (it.get() == &flow->entry(1))
+		reply_map_ptr->erase(it);
 }
 
 CLICK_ENDDECLS
diff --git a/elements/ip/iprwmapping.cc b/elements/ip/iprwmapping.cc
index 966382c..b0ff0f3 100644
--- a/elements/ip/iprwmapping.cc
+++ b/elements/ip/iprwmapping.cc
@@ -55,7 +55,7 @@ IPRewriterFlow::IPRewriterFlow(IPRewriterInput *owner, const IPFlowID &flowid,
 }
 
 void
-IPRewriterFlow::apply(WritablePacket *p, bool direction, unsigned annos)
+IPRewriterFlow::apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum)
 {
     assert(p->has_network_header());
     click_ip *iph = p->ip_header();
@@ -68,7 +68,10 @@ IPRewriterFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 	p->set_dst_ip_anno(revflow.saddr());
     if (direction && (annos & 2))
 	p->set_anno_u8(annos >> 2, _reply_anno);
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+    // SNF: Allow to skip IP checksum calculation
+    if (calc_checksum) {
+	update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+    }
 
     // end if not first fragment
     if (!IP_FIRSTFRAG(iph))
@@ -79,13 +82,20 @@ IPRewriterFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 	click_tcp *tcph = p->tcp_header();
 	tcph->th_sport = revflow.dport();
 	tcph->th_dport = revflow.sport();
-	update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+	// SNF extension: Allow to skip TCP checksum calculation
+	if ( calc_checksum ) {
+		update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+	}
     } else if (iph->ip_p == IP_PROTO_UDP) {
 	click_udp *udph = p->udp_header();
 	udph->uh_sport = revflow.dport();
 	udph->uh_dport = revflow.sport();
-	if (udph->uh_sum)	// 0 checksum is no checksum
-	    update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	if (udph->uh_sum) {	// 0 checksum is no checksum
+	    // SNF extension: Allow to skip UDP checksum calculation
+	    if (calc_checksum) {
+		update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	    }
+	}
     }
 }
 
diff --git a/elements/ip/iprwmapping.hh b/elements/ip/iprwmapping.hh
index 446f95b..5ee3860 100644
--- a/elements/ip/iprwmapping.hh
+++ b/elements/ip/iprwmapping.hh
@@ -135,7 +135,7 @@ class IPRewriterFlow { public:
     static inline void update_csum(uint16_t *csum, bool direction,
 				   uint16_t csum_delta);
 
-    void apply(WritablePacket *p, bool direction, unsigned annos);
+    void apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum);
 
     void unparse(StringAccum &sa, bool direction, click_jiffies_t now) const;
     void unparse_ports(StringAccum &sa, bool direction, click_jiffies_t now) const;
diff --git a/elements/tcpudp/iprewriter.cc b/elements/tcpudp/iprewriter.cc
index 0bc909b..84121f6 100644
--- a/elements/tcpudp/iprewriter.cc
+++ b/elements/tcpudp/iprewriter.cc
@@ -2,8 +2,12 @@
  * iprewriter.{cc,hh} -- rewrites packet source and destination
  * Max Poletto, Eddie Kohler
  *
+ * Per-core, thread safe data structures, computational batching
+ * and optional checksum calculation by Georgios Katsikas
+ *
  * Copyright (c) 2000 Massachusetts Institute of Technology
  * Copyright (c) 2008-2010 Meraki, Inc.
+ * Copyright (c) 2016 KTH Royal Institute of Technology
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -29,164 +33,302 @@
 CLICK_DECLS
 
 IPRewriter::IPRewriter()
-    : _udp_map(0)
 {
+	_mem_units_no = ( click_max_cpu_ids() == 0 )? 1 : click_max_cpu_ids();
+
+	_udp_map       = new Map[_mem_units_no];
+	_udp_allocator = new SizedHashAllocator<sizeof(UDPFlow)>[_mem_units_no];
+	_udp_timeouts  = new uint32_t*[_mem_units_no];
+	_udp_streaming_timeout = new uint32_t[_mem_units_no];
+	for (unsigned i=0; i<_mem_units_no; i++) {
+		_udp_timeouts[i] = new uint32_t[2];
+	}
+	//click_chatter("[%s]: Allocated %d memory units", class_name(), _mem_units_no);
 }
 
 IPRewriter::~IPRewriter()
 {
+	if ( _udp_map )
+		delete [] _udp_map;
+	if ( _udp_allocator )
+		delete [] _udp_allocator;
+	for (unsigned i=0; i<_mem_units_no; i++) {
+		if ( _udp_timeouts[i] ) {
+			//delete [] _udp_timeouts[i];
+		}
+	}
+	delete [] _udp_timeouts;
+	delete [] _udp_streaming_timeout;
+	//click_chatter("[%s]: Released %d memory units", class_name(), _mem_units_no);
 }
 
 void *
 IPRewriter::cast(const char *n)
 {
-    if (strcmp(n, "IPRewriterBase") == 0)
-	return (IPRewriterBase *)this;
-    else if (strcmp(n, "TCPRewriter") == 0)
-	return (TCPRewriter *)this;
-    else if (strcmp(n, "IPRewriter") == 0)
-	return this;
-    else
-	return 0;
+	if      (strcmp(n, "IPRewriterBase") == 0)
+		return static_cast<IPRewriterBase *> (this);
+	else if (strcmp(n, "TCPRewriter") == 0)
+		return static_cast<TCPRewriter *> (this);
+	else if (strcmp(n, "IPRewriter") == 0)
+		return this;
+	else
+		return 0;
 }
 
 int
 IPRewriter::configure(Vector<String> &conf, ErrorHandler *errh)
 {
-    bool has_udp_streaming_timeout = false;
-    _udp_timeouts[0] = 60 * 5;	// 5 minutes
-    _udp_timeouts[1] = 5;	// 5 seconds
-
-    if (Args(this, errh).bind(conf)
-	.read("UDP_TIMEOUT", SecondsArg(), _udp_timeouts[0])
-	.read("UDP_STREAMING_TIMEOUT", SecondsArg(), _udp_streaming_timeout).read_status(has_udp_streaming_timeout)
-	.read("UDP_GUARANTEE", SecondsArg(), _udp_timeouts[1])
-	.consume() < 0)
-	return -1;
-
-    if (!has_udp_streaming_timeout)
-	_udp_streaming_timeout = _udp_timeouts[0];
-    _udp_timeouts[0] *= CLICK_HZ; // change timeouts to jiffies
-    _udp_timeouts[1] *= CLICK_HZ;
-    _udp_streaming_timeout *= CLICK_HZ; // IPRewriterBase handles the others
-
-    return TCPRewriter::configure(conf, errh);
+	bool has_udp_streaming_timeout = false;
+	uint32_t udp_timeouts[2];
+	uint32_t udp_streaming_timeout;
+	udp_timeouts[0] = 60 * 5;	// 5 minutes
+	udp_timeouts[1] = 5;	    // 5 seconds
+
+	if (Args(this, errh).bind(conf)
+		.read("UDP_TIMEOUT", SecondsArg(), udp_timeouts[0])
+		.read("UDP_STREAMING_TIMEOUT", SecondsArg(), udp_streaming_timeout).read_status(has_udp_streaming_timeout)
+		.read("UDP_GUARANTEE", SecondsArg(), udp_timeouts[1])
+		.consume() < 0)
+		return -1;
+
+	if (!has_udp_streaming_timeout)
+		udp_streaming_timeout = udp_timeouts[0];
+	udp_timeouts[0] *= CLICK_HZ;       // Change timeouts to jiffies
+	udp_timeouts[1] *= CLICK_HZ;
+	udp_streaming_timeout *= CLICK_HZ; // IPRewriterBase handles the others
+
+	for (unsigned i=0; i<_mem_units_no; i++) {
+		_udp_timeouts[i] = udp_timeouts;
+		_udp_streaming_timeout[i] = udp_streaming_timeout;
+	}
+
+	return TCPRewriter::configure(conf, errh);
 }
 
 inline IPRewriterEntry *
 IPRewriter::get_entry(int ip_p, const IPFlowID &flowid, int input)
 {
-    if (ip_p == IP_PROTO_TCP)
-	return TCPRewriter::get_entry(ip_p, flowid, input);
-    if (ip_p != IP_PROTO_UDP)
-	return 0;
-    IPRewriterEntry *m = _udp_map.get(flowid);
-    if (!m && (unsigned) input < (unsigned) _input_specs.size()) {
-	IPRewriterInput &is = _input_specs[input];
-	IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
-	if (is.rewrite_flowid(flowid, rewritten_flowid, 0, IPRewriterInput::mapid_iprewriter_udp) == rw_addmap)
-	    m = IPRewriter::add_flow(0, flowid, rewritten_flowid, input);
-    }
-    return m;
+	if (ip_p == IP_PROTO_TCP)
+		return TCPRewriter::get_entry(ip_p, flowid, input);
+	if (ip_p != IP_PROTO_UDP)
+		return 0;
+
+	IPRewriterEntry *m = _udp_map[click_current_cpu_id()].get(flowid);
+
+	//click_chatter("[%s] [Core %d]: Got an entry", class_name(), click_current_cpu_id());
+	if (!m && (unsigned) input < (unsigned) _input_specs.size()) {
+		IPRewriterInput &is = _input_specs[input];
+		IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
+		if (is.rewrite_flowid(flowid, rewritten_flowid, 0, IPRewriterInput::mapid_iprewriter_udp) == rw_addmap)
+			m = IPRewriter::add_flow(0, flowid, rewritten_flowid, input);
+	}
+	return m;
 }
 
 IPRewriterEntry *
 IPRewriter::add_flow(int ip_p, const IPFlowID &flowid,
-		     const IPFlowID &rewritten_flowid, int input)
+	 		const IPFlowID &rewritten_flowid, int input)
 {
-    if (ip_p == IP_PROTO_TCP)
-	return TCPRewriter::add_flow(ip_p, flowid, rewritten_flowid, input);
+	if (ip_p == IP_PROTO_TCP) {
+		return TCPRewriter::add_flow(ip_p, flowid, rewritten_flowid, input);
+	}
+
+	void *data = _udp_allocator[click_current_cpu_id()].allocate();
+	if ( !data ) {
+		click_chatter("[%s] [Core %d]: UDP Allocator failed", class_name(), click_current_cpu_id());
+		return 0;
+	}
+
+	IPRewriterInput *rwinput = &_input_specs[input];
+	IPRewriterFlow *flow = new(data) IPRewriterFlow
+		(rwinput, flowid, rewritten_flowid, ip_p,
+		 !!_udp_timeouts[click_current_cpu_id()][1], click_jiffies() + relevant_timeout(_udp_timeouts[click_current_cpu_id()]));
+
+	return store_flow(flow, input, _udp_map[click_current_cpu_id()], &reply_udp_map(rwinput));
+}
+
+int
+IPRewriter::process(int port, Packet *p_in) {
+	WritablePacket *p = p_in->uniqueify();
+	if (!p) {
+		return -1;
+	}
+
+	click_ip *iph = p->ip_header();
 
-    void *data;
-    if (!(data = _udp_allocator.allocate()))
-	return 0;
+	// handle non-first fragments
+	if ((iph->ip_p != IP_PROTO_TCP && iph->ip_p != IP_PROTO_UDP)
+		|| !IP_FIRSTFRAG(iph)
+		|| p->transport_length() < 8) {
+		const IPRewriterInput &is = _input_specs[port];
+		if (is.kind == IPRewriterInput::i_nochange) {
+			return is.foutput;
+		}
+		return -1;
+	}
 
-    IPRewriterInput *rwinput = &_input_specs[input];
-    IPRewriterFlow *flow = new(data) IPRewriterFlow
-	(rwinput, flowid, rewritten_flowid, ip_p,
-	 !!_udp_timeouts[1], click_jiffies() + relevant_timeout(_udp_timeouts));
+	// SNF: Decrement IP TTL
+	// Do it here, before jumping to either UDP or TCP
+	if ( _dec_ip_ttl ) {
+		// Safe decrement
+		if ( iph->ip_ttl > 1 ) {
+			iph->ip_ttl --;
+			// Checksum is not mandatory anymore
+			if ( _calc_checksum ) {
+				unsigned long sum = (~ntohs(iph->ip_sum) & 0xFFFF) + 0xFEFF;
+				iph->ip_sum = ~htons(sum + (sum >> 16));
+			}
+		}
+		// End flow if TTL is 0
+		else {
+			return -1;
+		}
+	}
 
-    return store_flow(flow, input, _udp_map, &reply_udp_map(rwinput));
+	IPFlowID flowid(p);
+	HashContainer<IPRewriterEntry> *map = (iph->ip_p == IP_PROTO_TCP ?
+			&_map[click_current_cpu_id()] : &_udp_map[click_current_cpu_id()]);
+	if ( !map ) {
+		click_chatter("[%s] [Core %d]: UDP Map is NULL", class_name(), click_current_cpu_id());
+	}
+	IPRewriterEntry *m = map->get(flowid);
+
+	if (!m) {                   // create new mapping
+		IPRewriterInput &is = _input_specs.unchecked_at(port);
+		IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
+		int result = is.rewrite_flowid(flowid, rewritten_flowid, p, iph->ip_p == IP_PROTO_TCP ?
+					0 : IPRewriterInput::mapid_iprewriter_udp);
+		if (result == rw_addmap) {
+			m = IPRewriter::add_flow(iph->ip_p, flowid, rewritten_flowid, port);
+			//click_chatter("[%s] [Core %d]: Flow added", class_name(), click_current_cpu_id());
+			//print_flow_info(m, iph);
+		}
+		if (!m)
+			return result;
+		else if (_annos & 2)
+			m->flow()->set_reply_anno(p->anno_u8(_annos >> 2));
+	}
+
+	click_jiffies_t now_j = click_jiffies();
+	IPRewriterFlow *mf = m->flow();
+	if (iph->ip_p == IP_PROTO_TCP) {
+		TCPFlow *tcpmf = static_cast<TCPFlow *>(mf);
+		tcpmf->apply(p, m->direction(), _annos, _calc_checksum);
+		if (_timeouts[click_current_cpu_id()][1])
+			tcpmf->change_expiry(_heap[click_current_cpu_id()], true, now_j + _timeouts[click_current_cpu_id()][1]);
+		else
+			tcpmf->change_expiry(_heap[click_current_cpu_id()], false, now_j + tcp_flow_timeout(tcpmf));
+	}
+	else {
+		UDPFlow *udpmf = static_cast<UDPFlow *>(mf);
+		udpmf->apply(p, m->direction(), _annos, _calc_checksum);
+		if (_udp_timeouts[click_current_cpu_id()][1])
+			udpmf->change_expiry(_heap[click_current_cpu_id()], true, now_j + _udp_timeouts[click_current_cpu_id()][1]);
+		else
+			udpmf->change_expiry(_heap[click_current_cpu_id()], false, now_j + udp_flow_timeout(udpmf));
+	}
+
+	return m->output();
 }
 
 void
-IPRewriter::push(int port, Packet *p_in)
+IPRewriter::push(int port, Packet *p)
 {
-    WritablePacket *p = p_in->uniqueify();
-    click_ip *iph = p->ip_header();
-
-    // handle non-first fragments
-    if ((iph->ip_p != IP_PROTO_TCP && iph->ip_p != IP_PROTO_UDP)
-	|| !IP_FIRSTFRAG(iph)
-	|| p->transport_length() < 8) {
-	const IPRewriterInput &is = _input_specs[port];
-	if (is.kind == IPRewriterInput::i_nochange)
-	    output(is.foutput).push(p);
-	else
-	    p->kill();
-	return;
-    }
-
-    IPFlowID flowid(p);
-    HashContainer<IPRewriterEntry> *map = (iph->ip_p == IP_PROTO_TCP ? &_map : &_udp_map);
-    IPRewriterEntry *m = map->get(flowid);
-
-    if (!m) {			// create new mapping
-	IPRewriterInput &is = _input_specs.unchecked_at(port);
-	IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
-	int result = is.rewrite_flowid(flowid, rewritten_flowid, p, iph->ip_p == IP_PROTO_TCP ? 0 : IPRewriterInput::mapid_iprewriter_udp);
-	if (result == rw_addmap)
-	    m = IPRewriter::add_flow(iph->ip_p, flowid, rewritten_flowid, port);
-	if (!m) {
-	    checked_output_push(result, p);
-	    return;
-	} else if (_annos & 2)
-	    m->flow()->set_reply_anno(p->anno_u8(_annos >> 2));
-    }
-
-    click_jiffies_t now_j = click_jiffies();
-    IPRewriterFlow *mf = m->flow();
-    if (iph->ip_p == IP_PROTO_TCP) {
-	TCPFlow *tcpmf = static_cast<TCPFlow *>(mf);
-	tcpmf->apply(p, m->direction(), _annos);
-	if (_timeouts[1])
-	    tcpmf->change_expiry(_heap, true, now_j + _timeouts[1]);
-	else
-	    tcpmf->change_expiry(_heap, false, now_j + tcp_flow_timeout(tcpmf));
-    } else {
-	UDPFlow *udpmf = static_cast<UDPFlow *>(mf);
-	udpmf->apply(p, m->direction(), _annos);
-	if (_udp_timeouts[1])
-	    udpmf->change_expiry(_heap, true, now_j + _udp_timeouts[1]);
-	else
-	    udpmf->change_expiry(_heap, false, now_j + udp_flow_timeout(udpmf));
-    }
+	int output_port = process(port, p);
+	if ( output_port < 0 ) {
+		p->kill();
+		return;
+	}
+
+	output(output_port).push(p);
+}
 
-    output(m->output()).push(p);
+#if HAVE_BATCH
+void
+IPRewriter::push_batch(int port, PacketBatch *batch)
+{
+	unsigned short outports = noutputs();
+	PacketBatch* out[outports];
+	bzero(out,sizeof(PacketBatch*)*outports);
+	PacketBatch* next = ((batch != NULL)? static_cast<PacketBatch*>(batch->next()) : NULL );
+	PacketBatch* p = batch;
+	PacketBatch* last = NULL;
+	int last_o = -1;
+	int passed = 0;
+	int count  = 0;
+
+	for ( ; p != NULL;p=next,next=(p==0?0:static_cast<PacketBatch*>(p->next())) ) {
+		// The actual job of this element
+		int o = process(port, p);
+
+		if (o < 0 || o>=(outports)) o = (outports - 1);
+
+		if (o == last_o) {
+			passed ++;
+		}
+		else {
+			if ( !last ) {
+				out[o] = p;
+				p->set_count(1);
+				p->set_tail(p);
+			}
+			else {
+				out[last_o]->set_tail(last);
+				out[last_o]->set_count(out[last_o]->count() + passed);
+				if (!out[o]) {
+					out[o] = p;
+					out[o]->set_count(1);
+					out[o]->set_tail(p);
+				}
+				else {
+					out[o]->append_packet(p);
+				}
+				passed = 0;
+			}
+		}
+		last = p;
+		last_o = o;
+		count++;
+	}
+
+	if (passed) {
+		out[last_o]->set_tail(last);
+		out[last_o]->set_count(out[last_o]->count() + passed);
+	}
+
+	int i = 0;
+	for (; i < outports; i++) {
+		if (out[i]) {
+			out[i]->tail()->set_next(NULL);
+			checked_output_push_batch(i, out[i]);
+		}
+	}
 }
+#endif
 
 String
 IPRewriter::udp_mappings_handler(Element *e, void *)
 {
-    IPRewriter *rw = (IPRewriter *)e;
-    click_jiffies_t now = click_jiffies();
-    StringAccum sa;
-    for (Map::iterator iter = rw->_udp_map.begin(); iter.live(); ++iter) {
-	iter->flow()->unparse(sa, iter->direction(), now);
-	sa << '\n';
-    }
-    return sa.take_string();
+	IPRewriter *rw = static_cast<IPRewriter *> (e);
+
+	click_jiffies_t now = click_jiffies();
+	StringAccum sa;
+	for (Map::iterator iter = rw->_udp_map[click_current_cpu_id()].begin(); iter.live(); ++iter) {
+		iter->flow()->unparse(sa, iter->direction(), now);
+		sa << '\n';
+	}
+	return sa.take_string();
 }
 
 void
 IPRewriter::add_handlers()
 {
-    add_read_handler("tcp_table", tcp_mappings_handler);
-    add_read_handler("udp_table", udp_mappings_handler);
-    add_read_handler("tcp_mappings", tcp_mappings_handler, 0, Handler::h_deprecated);
-    add_read_handler("udp_mappings", udp_mappings_handler, 0, Handler::h_deprecated);
-    set_handler("tcp_lookup", Handler::OP_READ | Handler::READ_PARAM, tcp_lookup_handler, 0);
-    add_rewriter_handlers(true);
+	add_read_handler("tcp_table", tcp_mappings_handler);
+	add_read_handler("udp_table", udp_mappings_handler);
+	add_read_handler("tcp_mappings", tcp_mappings_handler, 0, Handler::h_deprecated);
+	add_read_handler("udp_mappings", udp_mappings_handler, 0, Handler::h_deprecated);
+	set_handler("tcp_lookup", Handler::OP_READ | Handler::READ_PARAM, tcp_lookup_handler, 0);
+	add_rewriter_handlers(true);
 }
 
 CLICK_ENDDECLS
diff --git a/elements/tcpudp/iprewriter.hh b/elements/tcpudp/iprewriter.hh
index 50fb742..0afc233 100644
--- a/elements/tcpudp/iprewriter.hh
+++ b/elements/tcpudp/iprewriter.hh
@@ -31,7 +31,7 @@ output port.  Input packets with the indexed flow identifier are rewritten to
 use the new flow identifier, then emitted on the output port.  A mapping is
 written as follows:
 
-    (SA, SP, DA, DP, PROTO) => (SA', SP', DA', DP') [*OUTPUT]
+	(SA, SP, DA, DP, PROTO) => (SA', SP', DA', DP') [*OUTPUT]
 
 When IPRewriter receives a packet, it first looks up that packet in the
 mapping table by flow identifier.  If the table contains a mapping for the
@@ -59,8 +59,8 @@ Installs mappings that preserve the input packet's flow ID.  Specifically,
 given an input packet with flow ID (SA, SP, DA, DP, PROTO), two mappings are
 installed:
 
-    (SA, SP, DA, DP, PROTO) => (SA, SP, DA, DP) [*FOUTPUT]
-    (DA, DP, SA, SP, PROTO) => (DA, DP, SA, SP) [*ROUTPUT]
+	(SA, SP, DA, DP, PROTO) => (SA, SP, DA, DP) [*FOUTPUT]
+	(DA, DP, SA, SP, PROTO) => (DA, DP, SA, SP) [*ROUTPUT]
 
 Thus, the input packet is emitted on output port FOUTPUT unchanged, and
 packets from the reply flow are emitted on output port ROUTPUT unchanged.
@@ -84,8 +84,8 @@ Say a packet with flow ID (SA, SP, DA, DP, PROTO) is received, and the
 corresponding new flow ID is (SA', SP', DA', DP').  Then two mappings are
 installed:
 
-    (SA, SP, DA, DP, PROTO) => (SA', SP', DA', DP') [*FOUTPUT]
-    (DA', DP', SA', SP', PROTO) => (DA, DP, SA, SP) [*ROUTPUT]
+	(SA, SP, DA, DP, PROTO) => (SA', SP', DA', DP') [*FOUTPUT]
+	(DA', DP', SA', SP', PROTO) => (DA, DP, SA, SP) [*ROUTPUT]
 
 Thus, the input packet is rewritten and sent to FOUTPUT, and packets from the
 reply flow are rewritten to look like part of the original flow and sent to
@@ -208,7 +208,7 @@ table.
 
 Takes a TCP flow as a space-separated
 
-    saddr sport daddr dport
+	saddr sport daddr dport
 
 and attempts to find a forward mapping for that flow. If found, rewrites the
 flow and returns in the same format.  Otherwise, returns nothing.
@@ -216,74 +216,92 @@ flow and returns in the same format.  Otherwise, returns nothing.
 =a TCPRewriter, IPAddrRewriter, IPAddrPairRewriter, IPRewriterPatterns,
 RoundRobinIPMapper, FTPPortMapper, ICMPRewriter, ICMPPingRewriter */
 
-class IPRewriter : public TCPRewriter { public:
-
-    typedef UDPRewriter::UDPFlow UDPFlow;
-
-    IPRewriter() CLICK_COLD;
-    ~IPRewriter() CLICK_COLD;
-
-    const char *class_name() const		{ return "IPRewriter"; }
-    void *cast(const char *);
-
-    int configure(Vector<String> &, ErrorHandler *) CLICK_COLD;
-
-    IPRewriterEntry *get_entry(int ip_p, const IPFlowID &flowid, int input);
-    HashContainer<IPRewriterEntry> *get_map(int mapid) {
-	if (mapid == IPRewriterInput::mapid_default)
-	    return &_map;
-	else if (mapid == IPRewriterInput::mapid_iprewriter_udp)
-	    return &_udp_map;
-	else
-	    return 0;
-    }
-    IPRewriterEntry *add_flow(int ip_p, const IPFlowID &flowid,
-			      const IPFlowID &rewritten_flowid, int input);
-    void destroy_flow(IPRewriterFlow *flow);
-    click_jiffies_t best_effort_expiry(const IPRewriterFlow *flow) {
-	if (flow->ip_p() == IP_PROTO_TCP)
-	    return TCPRewriter::best_effort_expiry(flow);
-	else
-	    return flow->expiry() + udp_flow_timeout(static_cast<const UDPFlow *>(flow)) - _udp_timeouts[1];
-    }
-
-    void push(int, Packet *);
-
-    void add_handlers() CLICK_COLD;
-
-  private:
-
-    Map _udp_map;
-    SizedHashAllocator<sizeof(UDPFlow)> _udp_allocator;
-    uint32_t _udp_timeouts[2];
-    uint32_t _udp_streaming_timeout;
-
-    int udp_flow_timeout(const UDPFlow *mf) const {
-	if (mf->streaming())
-	    return _udp_streaming_timeout;
-	else
-	    return _udp_timeouts[0];
-    }
-
-    static inline Map &reply_udp_map(IPRewriterInput *rwinput) {
-	IPRewriter *x = static_cast<IPRewriter *>(rwinput->reply_element);
-	return x->_udp_map;
-    }
-    static String udp_mappings_handler(Element *e, void *user_data);
-
+class IPRewriter : public TCPRewriter {
+
+	public:
+		typedef UDPRewriter::UDPFlow UDPFlow;
+
+		IPRewriter () CLICK_COLD;
+		~IPRewriter() CLICK_COLD;
+
+		const char *class_name() const { return "IPRewriter"; }
+		void *cast(const char *);
+
+		int configure(Vector<String> &, ErrorHandler *) CLICK_COLD;
+
+		IPRewriterEntry *get_entry(int ip_p, const IPFlowID &flowid, int input);
+		HashContainer<IPRewriterEntry> *get_map(int mapid) {
+		if (mapid == IPRewriterInput::mapid_default)
+			return &_map[click_current_cpu_id()];
+		else if (mapid == IPRewriterInput::mapid_iprewriter_udp)
+			return &_udp_map[click_current_cpu_id()];
+		else
+			return 0;
+		}
+		IPRewriterEntry *add_flow(int ip_p, const IPFlowID &flowid,
+					  const IPFlowID &rewritten_flowid, int input);
+		void destroy_flow(IPRewriterFlow *flow);
+			click_jiffies_t best_effort_expiry(const IPRewriterFlow *flow) {
+			if (flow->ip_p() == IP_PROTO_TCP)
+				return TCPRewriter::best_effort_expiry(flow);
+			else
+				return flow->expiry() +
+					udp_flow_timeout(static_cast<const UDPFlow *>(flow)) -
+					_udp_timeouts[click_current_cpu_id()][1];
+		}
+
+		void push      (int, Packet      *p);
+	#if HAVE_BATCH
+		void push_batch(int, PacketBatch *batch);
+	#endif
+
+		void add_handlers() CLICK_COLD;
+
+	private:
+		// In multi-threaded mode, each core has its own cache.
+		// Since IPSynthesizer is stateful, a per-core table of connections
+		// might cause state inconsistencies (e.g., bi-directional flows that
+		// need to pass through the same table).
+		// To solve this conundrum and apply minimal modifications to the memory
+		// management of IPRewriter, we assume that you will instantiate a
+		// symmetric RSS scheme in your NIC.
+		// This guarantees that bidirectional flows get handled by  the same
+		// CPU core, thus the same cache.
+		unsigned _mem_units_no;
+		Map                                 *_udp_map;
+		SizedHashAllocator<sizeof(UDPFlow)> *_udp_allocator;
+		uint32_t                            **_udp_timeouts;
+		uint32_t                            *_udp_streaming_timeout;
+
+		// The actual processing of this element is abstracted from the push operation.
+		// This allows both push and push_batch to exploit the same processing
+		int process(int port, Packet *p_in);
+
+		int udp_flow_timeout(const UDPFlow *mf) const {
+			if (mf->streaming())
+				return _udp_streaming_timeout[click_current_cpu_id()];
+			else
+				return _udp_timeouts[click_current_cpu_id()][0];
+		}
+
+		static inline Map &reply_udp_map(IPRewriterInput *rwinput) {
+		IPRewriter *x = static_cast<IPRewriter *>(rwinput->reply_element);
+			return x->_udp_map[click_current_cpu_id()];
+		}
+		static String udp_mappings_handler(Element *e, void *user_data);
 };
 
 
 inline void
 IPRewriter::destroy_flow(IPRewriterFlow *flow)
 {
-    if (flow->ip_p() == IP_PROTO_TCP)
-	TCPRewriter::destroy_flow(flow);
-    else {
-	unmap_flow(flow, _udp_map, &reply_udp_map(flow->owner()));
-	flow->~IPRewriterFlow();
-	_udp_allocator.deallocate(flow);
-    }
+	if (flow->ip_p() == IP_PROTO_TCP)
+		TCPRewriter::destroy_flow(flow);
+	else {
+		unmap_flow(flow, _udp_map[click_current_cpu_id()], &reply_udp_map(flow->owner()));
+		flow->~IPRewriterFlow();
+		_udp_allocator[click_current_cpu_id()].deallocate(flow);
+	}
 }
 
 CLICK_ENDDECLS
diff --git a/elements/tcpudp/ipsynthesizer.cc b/elements/tcpudp/ipsynthesizer.cc
new file mode 100644
index 0000000..f3875ce
--- /dev/null
+++ b/elements/tcpudp/ipsynthesizer.cc
@@ -0,0 +1,612 @@
+/*
+ * ipsynthesizer.{cc,hh} -- rewrites TCP/UDP packet source and destination
+ * while (optionally) applying post-routing operations
+ * Extends IPRewriter written by Max Poletto, Eddie Kohler
+ * Per-core, thread safe data structures, batching and post-routing operations
+ * by Georgios Katsikas
+ *
+ * Copyright (c) 2000 Massachusetts Institute of Technology
+ * Copyright (c) 2008-2010 Meraki, Inc.
+ * Copyright (c) 2016 KTH Royal Institute of Technology
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, subject to the conditions
+ * listed in the Click LICENSE file. These conditions include: you must
+ * preserve this copyright notice, and you cannot mention the copyright
+ * holders in advertising related to the Software without their permission.
+ * The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
+ * notice is a summary of the Click LICENSE file; the license in that file is
+ * legally binding.
+ */
+
+#include <click/config.h>
+#include "ipsynthesizer.hh"
+#include <clicknet/ip.h>
+#include <clicknet/tcp.h>
+#include <clicknet/udp.h>
+#include <click/args.hh>
+#include <click/straccum.hh>
+#include <click/error.hh>
+#include <click/timer.hh>
+#include <click/router.hh>
+#include <click/packet_anno.hh>
+CLICK_DECLS
+
+IPSynthesizer::IPSynthesizer()
+{
+	_mem_units_no = ( click_max_cpu_ids() == 0 )? 1 : click_max_cpu_ids();
+
+	_udp_map       = new Map[_mem_units_no];
+	_udp_allocator = new SizedHashAllocator<sizeof(UDPFlow)>[_mem_units_no];
+	_udp_timeouts  = new uint32_t*[_mem_units_no];
+	_udp_streaming_timeout = new uint32_t[_mem_units_no];
+	for (unsigned i=0; i<_mem_units_no; i++) {
+		_udp_timeouts[i] = new uint32_t[2];
+	}
+	//click_chatter("[%s]: Allocated %d memory units", class_name(), _mem_units_no);
+}
+
+IPSynthesizer::~IPSynthesizer()
+{
+	if ( _udp_map )
+		delete [] _udp_map;
+	if ( _udp_allocator )
+		delete [] _udp_allocator;
+	for (unsigned i=0; i<_mem_units_no; i++) {
+		if ( _udp_timeouts[i] ) {
+			//delete [] _udp_timeouts[i];
+		}
+	}
+	delete [] _udp_timeouts;
+	delete [] _udp_streaming_timeout;
+	//click_chatter("[%s]: Released %d memory units", class_name(), _mem_units_no);
+}
+
+void *
+IPSynthesizer::cast(const char *n)
+{
+	if      (strcmp(n, "IPRewriterBase") == 0)
+		return static_cast<IPRewriterBase *> (this);
+	else if (strcmp(n, "TCPRewriter") == 0)
+		return static_cast<TCPRewriter *> (this);
+	else if (strcmp(n, "IPSynthesizer") == 0)
+		return this;
+	else
+		return 0;
+}
+
+int
+IPSynthesizer::configure(Vector<String> &conf, ErrorHandler *errh)
+{
+	bool has_udp_streaming_timeout = false;
+	uint32_t udp_timeouts[2];
+	uint32_t udp_streaming_timeout;
+	udp_timeouts[0] = 60 * 5;	// 5 minutes
+	udp_timeouts[1] = 5;	    // 5 seconds
+
+	if (Args(this, errh).bind(conf)
+		.read("UDP_TIMEOUT", SecondsArg(), udp_timeouts[0])
+		.read("UDP_STREAMING_TIMEOUT", SecondsArg(), udp_streaming_timeout).read_status(has_udp_streaming_timeout)
+		.read("UDP_GUARANTEE", SecondsArg(), udp_timeouts[1])
+		.consume() < 0)
+		return -1;
+
+	if (!has_udp_streaming_timeout)
+		udp_streaming_timeout = udp_timeouts[0];
+	udp_timeouts[0] *= CLICK_HZ;       // Change timeouts to jiffies
+	udp_timeouts[1] *= CLICK_HZ;
+	udp_streaming_timeout *= CLICK_HZ; // IPRewriterBase handles the others
+
+	for (unsigned i=0; i<_mem_units_no; i++) {
+		_udp_timeouts[i] = udp_timeouts;
+		_udp_streaming_timeout[i] = udp_streaming_timeout;
+	}
+
+	return TCPRewriter::configure(conf, errh);
+}
+
+inline IPRewriterEntry *
+IPSynthesizer::get_entry(int ip_p, const IPFlowID &flowid, int input)
+{
+	if (ip_p == IP_PROTO_TCP)
+		return TCPRewriter::get_entry(ip_p, flowid, input);
+	if (ip_p != IP_PROTO_UDP)
+		return 0;
+
+	IPRewriterEntry *m = _udp_map[click_current_cpu_id()].get(flowid);
+
+	if (!m && (unsigned) input < (unsigned) _input_specs.size()) {
+		IPRewriterInput &is = _input_specs[input];
+		IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
+		if (is.rewrite_flowid(flowid, rewritten_flowid, 0, IPRewriterInput::mapid_iprewriter_udp) == rw_addmap)
+			m = IPSynthesizer::add_flow(0, flowid, rewritten_flowid, input);
+	}
+
+	return m;
+}
+
+IPRewriterEntry *
+IPSynthesizer::add_flow(int ip_p, const IPFlowID &flowid,
+						 const IPFlowID &rewritten_flowid, int input)
+{
+	if (ip_p == IP_PROTO_TCP)
+		return TCPRewriter::add_flow(ip_p, flowid, rewritten_flowid, input);
+
+	void *data = _udp_allocator[click_current_cpu_id()].allocate();
+	if ( !data ) {
+		click_chatter("[%s] [Core %d]: UDP Allocator failed", class_name(), click_current_cpu_id());
+		return 0;
+	}
+
+	IPRewriterInput *rwinput = &_input_specs[input];
+	IPRewriterFlow  *flow    = new(data) IPRewriterFlow
+		(rwinput, flowid, rewritten_flowid, ip_p,
+		 !!_udp_timeouts[click_current_cpu_id()][1], click_jiffies() + relevant_timeout(_udp_timeouts[click_current_cpu_id()]));
+
+	return store_flow(flow, input, _udp_map[click_current_cpu_id()], &reply_udp_map(rwinput));
+}
+
+int
+IPSynthesizer::process(int port, Packet *p_in)
+{
+	WritablePacket *p = p_in->uniqueify();
+	if (!p) {
+		return -1;
+	}
+
+	click_ip *iph = p->ip_header();
+
+	// handle non-first fragments
+	if ((iph->ip_p != IP_PROTO_TCP && iph->ip_p != IP_PROTO_UDP)
+		|| !IP_FIRSTFRAG(iph)
+		|| p->transport_length() < 8) {
+		const IPRewriterInput &is = _input_specs[port];
+		if (is.kind == IPRewriterInput::i_nochange) {
+			return is.foutput;
+		}
+		return -1;
+	}
+
+	// SNF: Apply post-routing elements
+	// such as DropBroadcasts, FixIPSrc, DecIPTTL, ect.
+	if ( !combine_ip_elements(p_in) ) {
+		return -1;
+	}
+
+	IPFlowID flowid(p);
+	HashContainer<IPRewriterEntry> *map = (iph->ip_p == IP_PROTO_TCP ?
+			&_map[click_current_cpu_id()] : &_udp_map[click_current_cpu_id()]);
+	if ( !map ) {
+		click_chatter("[%s] [Core %d]: UDP Map is NULL", class_name(), click_current_cpu_id());
+	}
+	IPRewriterEntry *m = map->get(flowid);
+
+	if (!m) {                   // create new mapping
+		IPRewriterInput &is = _input_specs.unchecked_at(port);
+		IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
+		int result = is.rewrite_flowid(flowid, rewritten_flowid, p, iph->ip_p == IP_PROTO_TCP ?
+					0 : IPRewriterInput::mapid_iprewriter_udp);
+		if (result == rw_addmap) {
+			m = IPSynthesizer::add_flow(iph->ip_p, flowid, rewritten_flowid, port);
+			//click_chatter("[%s] [Core %d]: Flow added", class_name(), click_current_cpu_id());
+			//print_flow_info(m, iph);
+		}
+		if (!m)
+			return result;
+		else if (_annos & 2)
+			m->flow()->set_reply_anno(p->anno_u8(_annos >> 2));
+	}
+
+	click_jiffies_t now_j = click_jiffies();
+	IPRewriterFlow *mf = m->flow();
+	if (iph->ip_p == IP_PROTO_TCP) {
+		TCPFlow *tcpmf = static_cast<TCPFlow *>(mf);
+		tcpmf->apply(p, m->direction(), _annos, _calc_checksum);
+		if (_timeouts[click_current_cpu_id()][1])
+			tcpmf->change_expiry(_heap[click_current_cpu_id()], true, now_j + _timeouts[click_current_cpu_id()][1]);
+		else
+			tcpmf->change_expiry(_heap[click_current_cpu_id()], false, now_j + tcp_flow_timeout(tcpmf));
+	}
+	else {
+		UDPFlow *udpmf = static_cast<UDPFlow *>(mf);
+		udpmf->apply(p, m->direction(), _annos, _calc_checksum);
+		if (_udp_timeouts[click_current_cpu_id()][1])
+			udpmf->change_expiry(_heap[click_current_cpu_id()], true, now_j + _udp_timeouts[click_current_cpu_id()][1]);
+		else
+			udpmf->change_expiry(_heap[click_current_cpu_id()], false, now_j + udp_flow_timeout(udpmf));
+	}
+
+	// Fragment IP packets if requested to do so.
+	// If fragmentation occurs, batching is disabled
+	// since the fragment function is calling the normal
+	// push method to send all the parts of the packet out.
+	if ( (p->network_length() > (int) this->_mtu) && (_ip_fragment) ) {
+		fragment(p, m->output());
+	}
+	return m->output();
+}
+
+bool
+IPSynthesizer::combine_ip_elements(Packet *p_in)
+{
+	int do_cksum = 0;
+	int problem_offset = -1;
+
+	// DropBroadcasts
+	if (  (this->_drop_bcast) &&
+		(p_in->packet_type_anno() == Packet::BROADCAST || p_in->packet_type_anno() == Packet::MULTICAST) ) {
+		return false;
+	}
+
+	// IPGWOptions
+	WritablePacket *p = p_in->uniqueify();
+	assert(p->has_network_header());
+	click_ip *ip = p->ip_header();
+	unsigned hlen = (ip->ip_hl << 2);
+
+	if ( (this->_ipgw_opt) && (hlen > sizeof(click_ip)) ) {
+		uint8_t *woa = p->network_header();
+		int hlen = p->network_header_length();
+
+		int oi;
+		for (oi = sizeof(click_ip); oi < hlen; ) {
+			// handle one-byte options
+			unsigned type = woa[oi];
+			if (type == IPOPT_NOP) {
+				oi++;
+				continue;
+			} else if (type == IPOPT_EOL)
+				/* end of option list */
+				break;
+
+			// otherwise, get option length
+			int xlen = woa[oi + 1];
+			if (xlen < 2 || oi + xlen > hlen) {
+				// bad length
+				problem_offset = oi + 1; // to point at length
+				goto ipgw_send_error;
+			} else if (type != IPOPT_RR && type != IPOPT_TS) {
+				// not for us to process
+				oi += xlen;
+				continue;
+			}
+
+			// Have a writable packet already
+			if(type == IPOPT_RR){
+				/*
+				 * Record Route.
+				 * Apparently the pointer (oa[oi+2]) is 1-origin.
+				 */
+				int p = woa[oi+2] - 1;
+				if (p >= 3 && p + 4 <= xlen) {
+					memcpy(woa + oi + p, &_my_ip, 4);
+					woa[oi+2] += 4;
+					do_cksum = 1;
+				} else if (p != xlen) {
+					problem_offset = oi + 2;
+					goto ipgw_send_error;
+				}
+			}
+			else if(type == IPOPT_TS){
+				/*
+				 * Timestamp Option.
+				 * We can't do a good job with the pre-specified mode (flg=3),
+				 * since we don't know all our i/f addresses.
+				 */
+				int p = woa[oi+2] - 1;
+				int oflw = woa[oi+3] >> 4;
+				int flg = woa[oi+3] & 0xf;
+				bool overflowed = 0;
+
+				Timestamp now = Timestamp::now();
+				int ms = htonl((now.sec() % 86400)*1000 + now.msec());
+
+				if(p < 4){
+					problem_offset = oi + 2;
+					goto ipgw_send_error;
+				}
+				else if(flg == 0){
+					/* 32-bit timestamps only */
+					if(p+4 <= xlen){
+						memcpy(woa + oi + p, &ms, 4);
+						woa[oi+2] += 4;
+						do_cksum = 1;
+					}
+					else
+						overflowed = 1;
+				}
+				else if(flg == 1){
+					/* IP address followed by timestamp */
+					if(p+8 <= xlen){
+						memcpy(woa + oi + p, &_my_ip, 4);
+						memcpy(woa + oi + p + 4, &ms, 4);
+						woa[oi+2] += 8;
+						do_cksum = 1;
+					}
+					else
+						overflowed = 1;
+				}
+				else if (flg == 3 && p + 8 <= xlen) {
+					/* only if it's my address */
+					if (memcmp(woa + oi + p, &_my_ip, 4) == 0) {
+						memcpy(woa + oi + p + 4, &ms, 4);
+						woa[oi+2] += 8;
+						do_cksum = 1;
+					}
+				}
+				else {
+					problem_offset = oi + 3;
+					goto ipgw_send_error;
+				}
+				if (overflowed) {
+					if (oflw < 15) {
+						woa[oi+3] = ((oflw + 1) << 4) | flg;
+						do_cksum = 1;
+					}
+					else {
+						problem_offset = oi + 3;
+						goto ipgw_send_error;
+					}
+				}
+			}
+			oi += xlen;
+		}
+	}
+
+	// FixIPSrc
+	if ( (this->_fix_ip_src) && FIX_IP_SRC_ANNO(p) )  {
+		SET_FIX_IP_SRC_ANNO(p, 0);
+		ip->ip_src = _my_ip;
+		do_cksum = 1;
+	}
+
+	// For IPGWOptions / FixIPSrc
+	if (do_cksum) {
+		ip->ip_sum = 0;
+		ip->ip_sum = click_in_cksum(p->data(), hlen);
+	}
+
+	// DecIPTTL
+	if ( this->_dec_ip_ttl ) {
+		// Safe decrement
+		if ( ip->ip_ttl > 1 ) {
+			ip->ip_ttl --;
+			// Checksum is not mandatory anymore
+			if ( _calc_checksum ) {
+				unsigned long sum = (~ntohs(ip->ip_sum) & 0xFFFF) + 0xFEFF;
+				ip->ip_sum = ~htons(sum + (sum >> 16));
+			}
+		}
+		// End flow if TTL is 0
+		else {
+			return false;
+		}
+	}
+
+	// Everything OK!
+	return true;
+
+	// Problem from IPGWOptions
+	ipgw_send_error:
+		return false;
+}
+
+void
+IPSynthesizer::fragment(Packet *p_in, const int &output_port)
+{
+	const click_ip *ip_in = p_in->ip_header();
+	int hlen = ip_in->ip_hl << 2;
+	int first_dlen = (_mtu - hlen) & ~7;
+	int in_dlen = ntohs(ip_in->ip_len) - hlen;
+
+	if (((ip_in->ip_off & htons(IP_DF)) && _honor_df) || first_dlen < 8) {
+		if (_verbose || _drops < 5)
+			click_chatter("[%s] [Core %d]: IPFragmenter(%d) DF %p{ip_ptr} %p{ip_ptr} len=%d",
+							class_name(), click_current_cpu_id(), _mtu, &ip_in->ip_src,
+							&ip_in->ip_dst, p_in->length());
+		_drops++;
+		p_in->kill();
+		//checked_output_push(1, p_in);
+		return;
+	}
+
+	if (_verbose)
+		click_chatter(	"[%s] [Core %d]: IP fragmentation unbatches the packets to produce smaller ones."
+						"Performance will be reduced", class_name(), click_current_cpu_id());
+
+	// Make sure we can modify the packet
+	WritablePacket *p = p_in->uniqueify();
+	if (!p)
+		return;
+	click_ip *ip = p->ip_header();
+
+	// Output the first fragment
+	// If we're cheating the DF bit, we can't trust the ip_id; set to random.
+	if (ip->ip_off & htons(IP_DF)) {
+		ip->ip_id = click_random();
+		ip->ip_off &= ~htons(IP_DF);
+	}
+
+	bool had_mf = (ip->ip_off & htons(IP_MF)) != 0;
+	ip->ip_len = htons(hlen + first_dlen);
+	ip->ip_off |= htons(IP_MF);
+	ip->ip_sum = 0;
+	ip->ip_sum = click_in_cksum((const unsigned char *)ip, hlen);
+	Packet *first_fragment = p->clone();
+	first_fragment->take(p->length() - p->network_header_offset() - hlen - first_dlen);
+	output(output_port).push(first_fragment);
+	_fragments++;
+
+	// Output the remaining fragments
+	int out_hlen = sizeof(click_ip) + optcopy(ip, 0);
+
+	for (int off = first_dlen; off < in_dlen; ) {
+		// Prepare packet
+		int out_dlen = (_mtu - out_hlen) & ~7;
+		if (out_dlen + off > in_dlen)
+			out_dlen = in_dlen - off;
+
+		WritablePacket *q = Packet::make(_headroom, 0, out_hlen + out_dlen, 0);
+		if (q) {
+			q->set_network_header(q->data(), out_hlen);
+			click_ip *qip = q->ip_header();
+
+			memcpy(qip, ip, sizeof(click_ip));
+			optcopy(ip, qip);
+			memcpy(q->transport_header(), p->transport_header() + off, out_dlen);
+
+			qip->ip_hl = out_hlen >> 2;
+			qip->ip_off = htons(ntohs(ip->ip_off) + (off >> 3));
+			if (out_dlen + off >= in_dlen && !had_mf)
+				qip->ip_off &= ~htons(IP_MF);
+			qip->ip_len = htons(out_hlen + out_dlen);
+			qip->ip_sum = 0;
+			qip->ip_sum = click_in_cksum((const unsigned char *)qip, out_hlen);
+
+			q->copy_annotations(p);
+
+			output(output_port).push(q);
+			_fragments++;
+		}
+		off += out_dlen;
+	}
+
+	p->kill();
+}
+
+int
+IPSynthesizer::optcopy(const click_ip *ip1, click_ip *ip2)
+{
+	const uint8_t* oin = (const uint8_t*) (ip1 + 1);
+	const uint8_t* oin_end = oin + (ip1->ip_hl << 2) - sizeof(click_ip);
+	uint8_t *oout = (uint8_t *) (ip2 + 1);
+	int outpos = 0;
+
+	while (oin < oin_end)
+		if (*oin == IPOPT_NOP)  // don't copy NOP
+			++oin;
+		else if (*oin == IPOPT_EOL
+				|| oin + 1 == oin_end
+				|| oin[1] < 2
+				|| oin + oin[1] > oin_end)
+			break;
+		else {
+			if (*oin & 0x80) {	// copy the option
+				if (ip2)
+					memcpy(oout + outpos, oin, oin[1]);
+				outpos += oin[1];
+			}
+			oin += oin[1];
+		}
+
+	for (; (outpos & 3) != 0; outpos++)
+		if (ip2)
+			oout[outpos] = IPOPT_EOL;
+
+	return outpos;
+}
+
+void
+IPSynthesizer::push(int port, Packet *p)
+{
+	int output_port = process(port, p);
+	if ( output_port < 0 ) {
+		p->kill();
+		return;
+	}
+
+	output(output_port).push(p);
+}
+
+#if HAVE_BATCH
+void
+IPSynthesizer::push_batch(int port, PacketBatch *batch)
+{
+	unsigned short outports = noutputs();
+	PacketBatch* out[outports];
+	bzero(out,sizeof(PacketBatch*)*outports);
+	PacketBatch* next = ((batch != NULL)? static_cast<PacketBatch*>(batch->next()) : NULL );
+	PacketBatch* p = batch;
+	PacketBatch* last = NULL;
+	int last_o = -1;
+	int passed = 0;
+	int count  = 0;
+
+	for ( ;p != NULL; p=next,next=(p==0?0:static_cast<PacketBatch*>(p->next())) ) {
+		// The actual job of this element
+		int o = process(port, p);
+
+		if (o < 0 || o>=(outports)) o = (outports - 1);
+
+		if (o == last_o) {
+			passed ++;
+		}
+		else {
+			if ( !last ) {
+				out[o] = p;
+				p->set_count(1);
+				p->set_tail(p);
+			}
+			else {
+				out[last_o]->set_tail(last);
+				out[last_o]->set_count(out[last_o]->count() + passed);
+				if (!out[o]) {
+					out[o] = p;
+					out[o]->set_count(1);
+					out[o]->set_tail(p);
+				}
+				else {
+					out[o]->append_packet(p);
+				}
+				passed = 0;
+			}
+		}
+		last = p;
+		last_o = o;
+		count++;
+	}
+
+	if (passed) {
+		out[last_o]->set_tail(last);
+		out[last_o]->set_count(out[last_o]->count() + passed);
+	}
+
+	int i = 0;
+	for (; i < outports; i++) {
+		if (out[i]) {
+			out[i]->tail()->set_next(NULL);
+			checked_output_push_batch(i, out[i]);
+		}
+	}
+}
+#endif
+
+String
+IPSynthesizer::udp_mappings_handler(Element *e, void *)
+{
+	IPSynthesizer *rw = static_cast<IPSynthesizer *> (e);
+	click_jiffies_t now = click_jiffies();
+	StringAccum sa;
+
+	for (Map::iterator iter = rw->_udp_map[click_current_cpu_id()].begin(); iter.live(); ++iter) {
+		iter->flow()->unparse(sa, iter->direction(), now);
+		sa << '\n';
+	}
+	return sa.take_string();
+}
+
+void
+IPSynthesizer::add_handlers()
+{
+	add_read_handler("tcp_table", tcp_mappings_handler);
+	add_read_handler("udp_table", udp_mappings_handler);
+	add_read_handler("tcp_mappings", tcp_mappings_handler, 0, Handler::h_deprecated);
+	add_read_handler("udp_mappings", udp_mappings_handler, 0, Handler::h_deprecated);
+	set_handler("tcp_lookup", Handler::OP_READ | Handler::READ_PARAM, tcp_lookup_handler, 0);
+	add_rewriter_handlers(true);
+}
+
+CLICK_ENDDECLS
+ELEMENT_REQUIRES(TCPRewriter UDPRewriter)
+EXPORT_ELEMENT(IPSynthesizer)
diff --git a/elements/tcpudp/ipsynthesizer.hh b/elements/tcpudp/ipsynthesizer.hh
new file mode 100644
index 0000000..949bef8
--- /dev/null
+++ b/elements/tcpudp/ipsynthesizer.hh
@@ -0,0 +1,318 @@
+#ifndef CLICK_IPSYNTHESIZER_HH
+#define CLICK_IPSYNTHESIZER_HH
+#include "tcprewriter.hh"
+#include "udprewriter.hh"
+CLICK_DECLS
+class UDPRewriter;
+
+/*
+=c
+
+IPSynthesizer(INPUTSPEC1, ..., INPUTSPECn [, I<keywords>])
+
+=s nat
+
+rewrites TCP/UDP packets' addresses and ports while (optionally) combining post-routing operations
+such as DecIPTTL, DropBroadcasts, FixIPSrc, IPGWOptions, and IPFragmentation.
+
+=d
+
+Rewrites the source address, source port, destination address, and/or
+destination port on TCP and UDP packets, along with their checksums.
+IPSynthesizer implements the functionality of a network address/port translator
+E<lparen>NAPT).  See also IPAddrRewriter and IPAddrPairRewriter, which
+implement Basic NAT, and TCPRewriter, which implements NAPT plus sequence
+number changes for TCP packets.
+
+IPSynthesizer maintains a I<mapping table> that records how packets are
+rewritten.  The mapping table is indexed by I<flow identifier>, the quintuple
+of source address, source port, destination address, destination port, and IP
+protocol (TCP or UDP).  Each mapping contains a new flow identifier and an
+output port.  Input packets with the indexed flow identifier are rewritten to
+use the new flow identifier, then emitted on the output port.  A mapping is
+written as follows:
+
+	(SA, SP, DA, DP, PROTO) => (SA', SP', DA', DP') [*OUTPUT]
+
+When IPSynthesizer receives a packet, it first looks up that packet in the
+mapping table by flow identifier.  If the table contains a mapping for the
+input packet, then the packet is rewritten according to the mapping and
+emitted on the specified output port.  If there was no mapping, the packet is
+handled by the INPUTSPEC corresponding to the input port on which the packet
+arrived.  (There are as many input ports as INPUTSPECs.)  Most INPUTSPECs
+install new mappings, so that future packets from the same TCP or UDP flow are
+handled by the mapping table rather than some INPUTSPEC.  The six forms of
+INPUTSPEC handle input packets as follows:
+
+=over 5
+
+=item 'drop' or 'discard'
+
+Discards input packets.
+
+=item 'pass OUTPUT'
+
+Sends input packets to output port OUTPUT.  No mappings are installed.
+
+=item 'keep FOUTPUT ROUTPUT'
+
+Installs mappings that preserve the input packet's flow ID.  Specifically,
+given an input packet with flow ID (SA, SP, DA, DP, PROTO), two mappings are
+installed:
+
+	(SA, SP, DA, DP, PROTO) => (SA, SP, DA, DP) [*FOUTPUT]
+	(DA, DP, SA, SP, PROTO) => (DA, DP, SA, SP) [*ROUTPUT]
+
+Thus, the input packet is emitted on output port FOUTPUT unchanged, and
+packets from the reply flow are emitted on output port ROUTPUT unchanged.
+
+=item 'pattern SADDR SPORT DADDR DPORT FOUTPUT ROUTPUT'
+
+Creates a mapping according to the given pattern, 'SADDR SPORT DADDR DPORT'.
+Any pattern field may be a dash '-', in which case the packet's corresponding
+field is left unchanged.  For instance, the pattern '1.0.0.1 20 - -' will
+rewrite input packets' source address and port, but leave its destination
+address and port unchanged.  SPORT may be a port range 'L-H'; IPSynthesizer will
+choose a source port in that range so that the resulting mappings don't
+conflict with any existing mappings.  The input packet's source port is
+preferred, if it is available; otherwise a random port is chosen.  If no
+source port is available, the packet is dropped.  To allocate source ports
+sequentially (which can make testing easier), append a pound sign to the
+range, as in '1024-65535#'.  To choose a random port rather than preferring
+the source, append a '?'.
+
+Say a packet with flow ID (SA, SP, DA, DP, PROTO) is received, and the
+corresponding new flow ID is (SA', SP', DA', DP').  Then two mappings are
+installed:
+
+	(SA, SP, DA, DP, PROTO) => (SA', SP', DA', DP') [*FOUTPUT]
+	(DA', DP', SA', SP', PROTO) => (DA, DP, SA, SP) [*ROUTPUT]
+
+Thus, the input packet is rewritten and sent to FOUTPUT, and packets from the
+reply flow are rewritten to look like part of the original flow and sent to
+ROUTPUT.
+
+=item 'pattern PATNAME FOUTPUT ROUTPUT'
+
+Like 'pattern' above, but refers to named patterns defined by an
+IPRewriterPatterns element.
+
+=item 'ELEMENTNAME'
+
+Creates mappings according to instructions from the element ELEMENTNAME.  This
+element must implement the IPMapper interface.  One example mapper is
+RoundRobinIPMapper.
+
+=back
+
+IPSynthesizer has no mappings when first initialized.
+
+Input packets must have their IP header annotations set.  Non-TCP and UDP
+packets, and second and subsequent fragments, are dropped unless they arrive
+on a 'pass' input port.  IPSynthesizer changes IP packet data and, optionally,
+destination IP address annotations; see the DST_ANNO keyword argument below.
+
+Keyword arguments determine how often stale mappings should be removed.
+
+=over 5
+
+=item TCP_TIMEOUT I<time>
+
+Time out TCP connections every I<time> seconds. Defaults to 24 hours. This
+timeout applies to TCP connections for which payload data has been seen
+flowing in both directions.
+
+=item TCP_DONE_TIMEOUT I<time>
+
+Time out completed TCP connections every I<time> seconds. Defaults to 4
+minutes. FIN and RST flags mark TCP connections as complete.
+
+=item TCP_NODATA_TIMEOUT I<time>
+
+Time out non-bidirectional TCP connections every I<time> seconds. Defaults to
+5 minutes. A non-bidirectional TCP connection is one in which payload data
+hasn't been seen in at least one direction. This should generally be larger
+than TCP_DONE_TIMEOUT.
+
+=item TCP_GUARANTEE I<time>
+
+Preserve each TCP connection mapping for at least I<time> seconds after each
+successfully processed packet. Defaults to 5 seconds. Incoming flows are
+dropped if an IPSynthesizer's mapping table is full of guaranteed flows.
+
+=item UDP_TIMEOUT I<time>
+
+Time out UDP connections every I<time> seconds. Default is 5 minutes.
+
+=item UDP_STREAMING_TIMEOUT I<time>
+
+Timeout UDP streaming connections every I<time> seconds. A "streaming"
+connection, in contrast to an "RPC-like" connection, comprises at least 3
+packets and at least one packet in each direction. Default is the UDP_TIMEOUT
+setting.
+
+=item UDP_GUARANTEE I<time>
+
+UDP connection mappings are guaranteed to exist for I<time> seconds after each successfully processed packet. Defaults to 5 seconds.
+
+=item REAP_INTERVAL I<time>
+
+Reap timed-out connections every I<time> seconds. Default is 15 minutes.
+
+=item MAPPING_CAPACITY I<capacity>
+
+Set the maximum number of mappings this rewriter can hold to I<capacity>.
+I<Capacity> can either be an integer or the name of another rewriter-like
+element, in which case this element will share the other element's capacity.
+
+=item DST_ANNO
+
+Boolean. If true, then set the destination IP address annotation on passing
+packets to the rewritten destination address. Default is true.
+
+=back
+
+=h table_size r
+
+Returns the number of mappings in this IPSynthesizer's tables.
+
+=h mapping_failures r
+
+Returns the number of mapping failures, which can occur, for example, when the
+IPSynthesizer runs out of source ports, or when a new flow is dropped because the
+IPSynthesizer is full.
+
+=h size r
+
+Returns the number of flows in the flow set.  This is generally the same as
+'table_size', but can be more when several rewriters share a flow set.
+
+=h capacity rw
+
+Return or set the capacity of the flow set.  The returned value is two
+space-separated numbers, where the first is the capacity and the second is the
+short-term flow reservation.  When writing, the short-term reservation can be
+omitted; it is then set to the minimum of 50 and one-eighth the capacity.
+
+=h tcp_table read-only
+
+Returns a human-readable description of the IPSynthesizer's current TCP mapping
+table. An unparsed mapping includes both directions' output ports; the
+relevant output port is starred.
+
+=h udp_table read-only
+
+Returns a human-readable description of the IPSynthesizer's current UDP mapping
+table.
+
+=h tcp_lookup read
+
+Takes a TCP flow as a space-separated
+
+	saddr sport daddr dport
+
+and attempts to find a forward mapping for that flow. If found, rewrites the
+flow and returns in the same format.  Otherwise, returns nothing.
+
+=a TCPRewriter, IPAddrRewriter, IPAddrPairRewriter, IPRewriterPatterns,
+RoundRobinIPMapper, FTPPortMapper, ICMPRewriter, ICMPPingRewriter */
+
+class IPSynthesizer : public TCPRewriter {
+
+	public:
+		typedef UDPRewriter::UDPFlow UDPFlow;
+
+		IPSynthesizer () CLICK_COLD;
+		~IPSynthesizer() CLICK_COLD;
+
+		const char *class_name() const { return "IPSynthesizer"; }
+		void *cast(const char *);
+
+		int configure(Vector<String> &, ErrorHandler *) CLICK_COLD;
+
+		IPRewriterEntry *get_entry(int ip_p, const IPFlowID &flowid, int input);
+		HashContainer<IPRewriterEntry> *get_map(int mapid) {
+			if (mapid == IPRewriterInput::mapid_default)
+				return &_map[click_current_cpu_id()];
+			else if (mapid == IPRewriterInput::mapid_iprewriter_udp)
+				return &_udp_map[click_current_cpu_id()];
+			else
+				return 0;
+		}
+
+		IPRewriterEntry *add_flow(int ip_p, const IPFlowID &flowid,
+					  const IPFlowID &rewritten_flowid, int input);
+
+		void destroy_flow(IPRewriterFlow *flow);
+		click_jiffies_t best_effort_expiry(const IPRewriterFlow *flow) {
+			if (flow->ip_p() == IP_PROTO_TCP)
+				return TCPRewriter::best_effort_expiry(flow);
+			else
+				return flow->expiry() 	+ udp_flow_timeout(static_cast<const UDPFlow *>(flow))
+										- _udp_timeouts[click_current_cpu_id()][1];
+		}
+
+		void push      (int, Packet      *p);
+	#if HAVE_BATCH
+		void push_batch(int, PacketBatch *batch);
+	#endif
+
+		void add_handlers() CLICK_COLD;
+
+	private:
+		// In multi-threaded mode, each core has its own cache.
+		// Since IPSynthesizer is stateful, a per-core table of connections
+		// might cause state inconsistencies (e.g., bi-directional flows that
+		// need to pass through the same table).
+		// To solve this conundrum and apply minimal modifications to the memory
+		// management of IPRewriter (upon which IPSynthesizer is built), we assume
+		// that you will instantiate a symmetric RSS scheme in your NIC.
+		// This guarantees that bidirectional flows get handled by  the same
+		// CPU core, thus the same cache.
+		unsigned _mem_units_no;
+		Map                                 *_udp_map;
+		SizedHashAllocator<sizeof(UDPFlow)> *_udp_allocator;
+		uint32_t                            **_udp_timeouts;
+		uint32_t                            *_udp_streaming_timeout;
+
+		atomic_uint32_t _drops;
+		atomic_uint32_t _fragments;
+
+		int udp_flow_timeout(const UDPFlow *mf) const {
+			if (mf->streaming())
+				return _udp_streaming_timeout[click_current_cpu_id()];
+			else
+				return _udp_timeouts[click_current_cpu_id()][0];
+		}
+
+		// The actual processing of this element is abstracted from the push operation.
+		// This allows both push and push_batch to exploit the same processing
+		int process(int port, Packet *p_in);
+
+		// SNF extension: Combines several post-routing elements
+		// to avoid further processing overhead
+		bool combine_ip_elements(Packet *p_in);
+		void fragment(Packet *p_in, const int& output_port);
+		int  optcopy(const click_ip *ip1, click_ip *ip2);
+
+		static inline Map &reply_udp_map(IPRewriterInput *rwinput) {
+			IPSynthesizer *x = static_cast<IPSynthesizer *>(rwinput->reply_element);
+			return x->_udp_map[click_current_cpu_id()];
+		}
+		static String udp_mappings_handler(Element *e, void *user_data);
+};
+
+inline void
+IPSynthesizer::destroy_flow(IPRewriterFlow *flow)
+{
+	if (flow->ip_p() == IP_PROTO_TCP)
+		TCPRewriter::destroy_flow(flow);
+	else {
+		unmap_flow(flow, _udp_map[click_current_cpu_id()], &reply_udp_map(flow->owner()));
+		flow->~IPRewriterFlow();
+		_udp_allocator[click_current_cpu_id()].deallocate(flow);
+	}
+}
+
+CLICK_ENDDECLS
+#endif
diff --git a/elements/tcpudp/tcprewriter.cc b/elements/tcpudp/tcprewriter.cc
index 6e10003..78740b5 100644
--- a/elements/tcpudp/tcprewriter.cc
+++ b/elements/tcpudp/tcprewriter.cc
@@ -3,9 +3,12 @@
  * tcprewriter.{cc,hh} -- rewrites packet source and destination
  * Eddie Kohler
  *
+ * Per-core, thread safe data structures and batching by Georgios Katsikas
+ *
  * Copyright (c) 2000 Massachusetts Institute of Technology
  * Copyright (c) 2000 Mazu Networks, Inc.
  * Copyright (c) 2008-2010 Meraki, Inc.
+ * Copyright (c) 2016 KTH Royal Institute of Technology
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -28,375 +31,489 @@
 CLICK_DECLS
 
 // TCPMapping
-
 int
 TCPRewriter::TCPFlow::update_seqno_delta(bool direction,
-					 tcp_seq_t trigger, int32_t d)
+ 					tcp_seq_t trigger, int32_t d)
 {
-    // delta transitions must be added in increasing order by sequence number
-    if (_dt && (_dt->nextptr & (1 << direction))
-	&& !SEQ_GEQ(trigger, _dt->trigger[direction]))
-	return -1;
-
-    // create a new delta transition object if required (there's already a
-    // delta)
-    if (!_dt || (_dt->nextptr & (1 << direction)
-		 ? trigger != _dt->trigger[direction]
-		 : _dt->delta[direction])) {
-	delta_transition *ndt = new delta_transition;
-	if (!ndt)
-	    return -1;
-	ndt->nextptr = reinterpret_cast<uintptr_t>(_dt);
-	_dt = ndt;
-	while (delta_transition *x = ndt->next()) {
-	    ndt->delta[!direction] = x->delta[!direction];
-	    ndt->trigger[!direction] = x->trigger[!direction];
-	    if (x->nextptr & (1 << !direction)) {
-		ndt->nextptr |= 1 << !direction;
-		ndt = x;
-	    } else {
-		ndt->nextptr -= ndt->nextptr & (1 << !direction);
-		break;
-	    }
+	// delta transitions must be added in increasing order by sequence number
+	if (_dt && (_dt->nextptr & (1 << direction))
+		&& !SEQ_GEQ(trigger, _dt->trigger[direction]))
+		return -1;
+
+	// reate a new delta transition object if required (there's already a
+	// delta)
+	if (!_dt || (_dt->nextptr & (1 << direction)
+		? trigger != _dt->trigger[direction]
+		: _dt->delta[direction])) {
+		delta_transition *ndt = new delta_transition;
+
+		if (!ndt)
+			return -1;
+		ndt->nextptr = reinterpret_cast<uintptr_t>(_dt);
+		_dt = ndt;
+		while (delta_transition *x = ndt->next()) {
+			ndt->delta[!direction] = x->delta[!direction];
+			ndt->trigger[!direction] = x->trigger[!direction];
+			if (x->nextptr & (1 << !direction)) {
+				ndt->nextptr |= 1 << !direction;
+				ndt = x;
+			}
+			else {
+				ndt->nextptr -= ndt->nextptr & (1 << !direction);
+				break;
+			}
+		}
+	}
+
+	// install new transition
+	_dt->trigger[direction] = trigger;
+	delta_transition *ndt = _dt->next();
+	_dt->delta[direction] = (ndt ? ndt->delta[direction] : 0) + d;
+	_dt->nextptr |= 1 << direction;
+
+	// maybe remove old transitions (1G behind the current transition)
+	while (ndt && ndt->has_trigger(direction)
+			&& !SEQ_GEQ(trigger, ndt->trigger[direction] + (1U << 30)))
+		ndt = ndt->next();
+
+	if (ndt && ndt->has_trigger(direction)) {
+		ndt->nextptr -= 1 << direction;
+		if (!(ndt->nextptr & 3))
+			while (delta_transition *x = ndt->next()) {
+				ndt->nextptr = x->nextptr - (x->nextptr & 3);
+				delete x;
+			}
 	}
-    }
-
-    // install new transition
-    _dt->trigger[direction] = trigger;
-    delta_transition *ndt = _dt->next();
-    _dt->delta[direction] = (ndt ? ndt->delta[direction] : 0) + d;
-    _dt->nextptr |= 1 << direction;
-
-    // maybe remove old transitions (1G behind the current transition)
-    while (ndt && ndt->has_trigger(direction)
-	   && !SEQ_GEQ(trigger, ndt->trigger[direction] + (1U << 30)))
-	ndt = ndt->next();
-    if (ndt && ndt->has_trigger(direction)) {
-	ndt->nextptr -= 1 << direction;
-	if (!(ndt->nextptr & 3))
-	    while (delta_transition *x = ndt->next()) {
-		ndt->nextptr = x->nextptr - (x->nextptr & 3);
-		delete x;
-	    }
-    }
-
-    return 0;
+
+	return 0;
 }
 
 void
-TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len)
+TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len, bool calc_checksum)
 {
-    if ((int)(tcph->th_off << 2) < len)
-	len = tcph->th_off << 2;
-    uint8_t *begin_opt = reinterpret_cast<uint8_t *>(tcph + 1);
-    uint8_t *end_opt = reinterpret_cast<uint8_t *>(tcph) + len;
-    uint32_t csum_delta = 0;
-
-    uint8_t *opt = begin_opt;
-    while (opt < end_opt)
-	switch (*opt) {
-	  case TCPOPT_EOL:
-	    goto done;
-	  case TCPOPT_NOP:
-	    opt++;
-	    break;
-	  case TCPOPT_SACK:
-	      if (opt + opt[1] > end_opt || (opt[1] % 8) != 2) {
-		  goto done;
-	      } else {
-		  uint8_t *end_sack = opt + opt[1];
-
-		  // develop initial checksum value
-		  uint16_t *csum_begin = reinterpret_cast<uint16_t *>(begin_opt + ((opt + 2 - begin_opt) & ~1));
-		  for (uint16_t *csum = csum_begin; reinterpret_cast<uint8_t *>(csum) < end_sack; csum++)
-		      csum_delta += ~*csum & 0xFFFF;
-
-		  for (opt += 2; opt < end_sack; opt += 8) {
-#if HAVE_INDIFFERENT_ALIGNMENT
-		      uint32_t *uopt = reinterpret_cast<uint32_t *>(opt);
-		      uopt[0] = htonl(new_ack(direction, ntohl(uopt[0])));
-		      uopt[1] = htonl(new_ack(direction, ntohl(uopt[1])));
-#else
-		      uint32_t buf[2];
-		      memcpy(&buf[0], opt, 8);
-		      buf[0] = htonl(new_ack(direction, ntohl(buf[0])));
-		      buf[1] = htonl(new_ack(direction, ntohl(buf[1])));
-		      memcpy(opt, &buf[0], 8);
-#endif
-		  }
-
-		  // finish off csum_delta calculation
-		  for (uint16_t *csum = csum_begin; reinterpret_cast<uint8_t *>(csum) < end_sack; csum++)
-		      csum_delta += *csum;
-		  break;
-	      }
-	  default:
-	    if (opt[1] < 2)
-		goto done;
-	    opt += opt[1];
-	    break;
-	}
-
-  done:
-    if (csum_delta) {
-	uint32_t sum = (~tcph->th_sum & 0xFFFF) + csum_delta;
-	sum = (sum & 0xFFFF) + (sum >> 16);
-	tcph->th_sum = ~(sum + (sum >> 16));
-    }
+	if ((int)(tcph->th_off << 2) < len)
+		len = tcph->th_off << 2;
+	uint8_t *begin_opt = reinterpret_cast<uint8_t *>(tcph + 1);
+	uint8_t *end_opt = reinterpret_cast<uint8_t *>(tcph) + len;
+	uint32_t csum_delta = 0;
+
+	uint8_t *opt = begin_opt;
+	while (opt < end_opt)
+		switch (*opt) {
+			case TCPOPT_EOL:
+				goto done;
+			case TCPOPT_NOP:
+				opt++;
+				break;
+			case TCPOPT_SACK:
+				if (opt + opt[1] > end_opt || (opt[1] % 8) != 2) {
+					goto done;
+				}
+				else {
+					uint8_t  *end_sack = opt + opt[1];
+					uint16_t *csum_begin= 0;
+
+					// SNF extension: Allow to skip TCP checksum calculation
+					if ( calc_checksum ) {
+						// develop initial checksum value
+						csum_begin = reinterpret_cast<uint16_t *>(begin_opt + ((opt + 2 - begin_opt) & ~1));
+						for (uint16_t *csum = csum_begin; reinterpret_cast<uint8_t *>(csum) < end_sack; csum++)
+							csum_delta += ~*csum & 0xFFFF;
+					}
+
+					for (opt += 2; opt < end_sack; opt += 8) {
+					#if HAVE_INDIFFERENT_ALIGNMENT
+						uint32_t *uopt = reinterpret_cast<uint32_t *>(opt);
+						uopt[0] = htonl(new_ack(direction, ntohl(uopt[0])));
+						uopt[1] = htonl(new_ack(direction, ntohl(uopt[1])));
+					#else
+						uint32_t buf[2];
+						memcpy(&buf[0], opt, 8);
+						buf[0] = htonl(new_ack(direction, ntohl(buf[0])));
+						buf[1] = htonl(new_ack(direction, ntohl(buf[1])));
+						memcpy(opt, &buf[0], 8);
+					#endif
+					}
+
+					// SNF extension: Allow to skip TCP checksum calculation
+					if ( calc_checksum ) {
+						// finish off csum_delta calculation
+						for (uint16_t *csum = csum_begin; reinterpret_cast<uint8_t *>(csum) < end_sack; csum++)
+							csum_delta += *csum;
+						break;
+					}
+				}
+			default:
+				if (opt[1] < 2)
+					goto done;
+				opt += opt[1];
+				break;
+		}
+
+	done:
+		// SNF extension: Allow to skip TCP checksum calculation
+		if (csum_delta && !calc_checksum) {
+			uint32_t sum = (~tcph->th_sum & 0xFFFF) + csum_delta;
+			sum = (sum & 0xFFFF) + (sum >> 16);
+			tcph->th_sum = ~(sum + (sum >> 16));
+		}
 }
 
 void
-TCPRewriter::TCPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
+TCPRewriter::TCPFlow::apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum)
 {
-    assert(p->has_network_header());
-    click_ip *iph = p->ip_header();
-
-    // IP header
-    const IPFlowID &revflow = _e[!direction].flowid();
-    iph->ip_src = revflow.daddr();
-    iph->ip_dst = revflow.saddr();
-    if (annos & 1)
-	p->set_dst_ip_anno(revflow.saddr());
-    if (direction && (annos & 2))
-	p->set_anno_u8(annos >> 2, _reply_anno);
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
-
-    // end if not first fragment
-    if (!IP_FIRSTFRAG(iph) || p->transport_length() < 18)
-	return;
-
-    // TCP header
-    click_tcp *tcph = p->tcp_header();
-    tcph->th_sport = revflow.dport();
-    tcph->th_dport = revflow.sport();
-    update_csum(&tcph->th_sum, direction, _udp_csum_delta);
-
-    // track connection state
-    bool have_payload = ((iph->ip_hl + tcph->th_off) << 2) < ntohs(iph->ip_len);
-    if (tcph->th_flags & TH_RST)
-	_tflags |= s_both_done;
-    else if (tcph->th_flags & TH_FIN)
-	_tflags |= s_forward_done << direction;
-    else if ((tcph->th_flags & TH_SYN) || have_payload)
-	_tflags &= ~(s_forward_done << direction);
-    if (have_payload)
-	_tflags |= s_forward_data << direction;
-
-    // end if weird transport length
-    if (p->transport_length() < (tcph->th_off << 2))
-	return;
-
-    // update sequence numbers
-    if (!_dt)
-	return;
-
-    // drop trigger once sequence number has advanced 1G beyond it
-    if (_dt->has_trigger(direction)
-	&& SEQ_GEQ(ntohl(tcph->th_seq), _dt->trigger[direction] + (1U << 30))) {
-	_dt->nextptr -= 1 << direction;
-	if (!(_dt->nextptr & 3))
-	    while (delta_transition *ndt = _dt->next()) {
-		_dt->nextptr = ndt->nextptr - (ndt->nextptr & 3);
-		delete ndt;
-	    }
-    }
-
-    if (_dt->delta[direction] || _dt->has_trigger(direction)) {
-	uint32_t newval = htonl(new_seq(direction, ntohl(tcph->th_seq)));
-	click_update_in_cksum(&tcph->th_sum, tcph->th_seq >> 16, newval >> 16);
-	click_update_in_cksum(&tcph->th_sum, tcph->th_seq, newval);
-	tcph->th_seq = newval;
-    }
-
-    if (_dt->delta[!direction] || _dt->has_trigger(!direction)) {
-	uint32_t newval = htonl(new_ack(direction, ntohl(tcph->th_ack)));
-	click_update_in_cksum(&tcph->th_sum, tcph->th_ack >> 16, newval >> 16);
-	click_update_in_cksum(&tcph->th_sum, tcph->th_ack, newval);
-	tcph->th_ack = newval;
-
-	// update SACK sequence numbers
-	if (tcph->th_off > 8
-	    || (tcph->th_off == 8
-		&& *(reinterpret_cast<const uint32_t *>(tcph + 1)) != htonl(0x0101080A)))
-	    apply_sack(direction, tcph, p->transport_length());
-    }
+	assert(p->has_network_header());
+	click_ip *iph = p->ip_header();
+
+	// IP header
+	const IPFlowID &revflow = _e[!direction].flowid();
+	iph->ip_src = revflow.daddr();
+	iph->ip_dst = revflow.saddr();
+	if (annos & 1)
+		p->set_dst_ip_anno(revflow.saddr());
+	if (direction && (annos & 2))
+		p->set_anno_u8(annos >> 2, _reply_anno);
+
+	// SNF extension: Allow to skip IP checksum calculation
+	if ( calc_checksum ) {
+		update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+	}
+
+	// end if not first fragment
+	if (!IP_FIRSTFRAG(iph) || p->transport_length() < 18)
+		return;
+
+	// TCP header
+	click_tcp *tcph = p->tcp_header();
+	tcph->th_sport = revflow.dport();
+	tcph->th_dport = revflow.sport();
+	// SNF extension: Allow to skip TCP checksum calculation
+	if ( calc_checksum ) {
+		update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+	}
+
+	// track connection state
+	bool have_payload = ((iph->ip_hl + tcph->th_off) << 2) < ntohs(iph->ip_len);
+	if (tcph->th_flags & TH_RST)
+		_tflags |= s_both_done;
+	else if (tcph->th_flags & TH_FIN)
+		_tflags |= s_forward_done << direction;
+	else if ((tcph->th_flags & TH_SYN) || have_payload)
+		_tflags &= ~(s_forward_done << direction);
+	if (have_payload)
+		_tflags |= s_forward_data << direction;
+
+	// end if weird transport length
+	if (p->transport_length() < (tcph->th_off << 2))
+		return;
+
+	// update sequence numbers
+	if (!_dt)
+		return;
+
+	// drop trigger once sequence number has advanced 1G beyond it
+	if (_dt->has_trigger(direction)
+		&& SEQ_GEQ(ntohl(tcph->th_seq), _dt->trigger[direction] + (1U << 30))) {
+		_dt->nextptr -= 1 << direction;
+		if (!(_dt->nextptr & 3))
+			while (delta_transition *ndt = _dt->next()) {
+				_dt->nextptr = ndt->nextptr - (ndt->nextptr & 3);
+				delete ndt;
+			}
+	}
+
+	if (_dt->delta[direction] || _dt->has_trigger(direction)) {
+		uint32_t newval = htonl(new_seq(direction, ntohl(tcph->th_seq)));
+		// SNF extension: Allow to skip TCP checksum calculation
+		if ( calc_checksum ) {
+			click_update_in_cksum(&tcph->th_sum, tcph->th_seq >> 16, newval >> 16);
+			click_update_in_cksum(&tcph->th_sum, tcph->th_seq, newval);
+		}
+		tcph->th_seq = newval;
+	}
+
+	if (_dt->delta[!direction] || _dt->has_trigger(!direction)) {
+		uint32_t newval = htonl(new_ack(direction, ntohl(tcph->th_ack)));
+
+		// SNF extension: Allow to skip TCP checksum calculation
+		if ( calc_checksum ) {
+			click_update_in_cksum(&tcph->th_sum, tcph->th_ack >> 16, newval >> 16);
+			click_update_in_cksum(&tcph->th_sum, tcph->th_ack, newval);
+		}
+		tcph->th_ack = newval;
+
+		// update SACK sequence numbers
+		if (tcph->th_off > 8
+			|| (tcph->th_off == 8
+			&& *(reinterpret_cast<const uint32_t *>(tcph + 1)) != htonl(0x0101080A)))
+			apply_sack(direction, tcph, p->transport_length(), calc_checksum);
+	}
 }
 
 void
 TCPRewriter::TCPFlow::unparse(StringAccum &sa, bool direction, click_jiffies_t now) const
 {
-    sa << _e[direction].flowid() << " => " << _e[direction].rewritten_flowid();
-    if (_dt && _dt->delta[direction] != 0)
+	sa << _e[direction].flowid() << " => " << _e[direction].rewritten_flowid();
+	if (_dt && _dt->delta[direction] != 0)
 	sa << " seq " << (_dt->delta[direction] > 0 ? "+" : "") << _dt->delta[direction];
-    unparse_ports(sa, direction, now);
+	unparse_ports(sa, direction, now);
 }
 
 
 // TCPRewriter
-
 TCPRewriter::TCPRewriter()
 {
+#if HAVE_USER_MULTITHREAD
+	_maps_no = ( click_max_cpu_ids() == 0 )? 1 : click_max_cpu_ids();
+	_allocator = new SizedHashAllocator<sizeof(TCPFlow)>[_maps_no];
+	//click_chatter("[%s]: Allocated %d TCP maps", class_name(), _maps_no);
+#endif
 }
 
 TCPRewriter::~TCPRewriter()
 {
+#if HAVE_USER_MULTITHREAD
+	if ( _allocator )
+		delete [] _allocator;
+#endif
 }
 
 void *
 TCPRewriter::cast(const char *n)
 {
-    if (strcmp(n, "IPRewriterBase") == 0)
-	return (IPRewriterBase *)this;
-    else if (strcmp(n, "TCPRewriter") == 0)
-	return (TCPRewriter *)this;
-    else
-	return 0;
+	if (strcmp(n, "IPRewriterBase") == 0)
+		return static_cast<IPRewriterBase *> (this);
+	else if (strcmp(n, "TCPRewriter") == 0)
+		return static_cast<TCPRewriter *> (this);
+	else
+		return 0;
 }
 
 int
 TCPRewriter::configure(Vector<String> &conf, ErrorHandler *errh)
 {
-    // numbers in seconds
-    _timeouts[0] = 300;		// nodata: 5 minutes (should be > TCP_DONE)
-    _tcp_data_timeout = 86400;	// 24 hours
-    _tcp_done_timeout = 240;	// 4 minutes
-    bool dst_anno = true, has_reply_anno = false;
-    int reply_anno;
-
-    if (Args(this, errh).bind(conf)
-	.read("TCP_NODATA_TIMEOUT", SecondsArg(), _timeouts[0])
-	.read("TCP_GUARANTEE", SecondsArg(), _timeouts[1])
-	.read("TIMEOUT", SecondsArg(), _tcp_data_timeout)
-	.read("TCP_TIMEOUT", SecondsArg(), _tcp_data_timeout)
-	.read("TCP_DONE_TIMEOUT", SecondsArg(), _tcp_done_timeout)
-	.read("DST_ANNO", dst_anno)
-	.read("REPLY_ANNO", AnnoArg(1), reply_anno).read_status(has_reply_anno)
-	.consume() < 0)
-	return -1;
-
-    _annos = (dst_anno ? 1 : 0) + (has_reply_anno ? 2 + (reply_anno << 2) : 0);
-    _tcp_data_timeout *= CLICK_HZ; // IPRewriterBase handles the others
-    _tcp_done_timeout *= CLICK_HZ;
-
-    return IPRewriterBase::configure(conf, errh);
+	uint32_t timeouts[2];
+
+	// numbers in seconds
+	timeouts[0] = 300;		// nodata: 5 minutes (should be > TCP_DONE)
+
+	_tcp_data_timeout = 86400;	// 24 hours
+	_tcp_done_timeout = 240;	// 4 minutes
+	bool dst_anno = true, has_reply_anno = false;
+	int reply_anno;
+
+	if (Args(this, errh).bind(conf)
+		.read("TCP_NODATA_TIMEOUT", SecondsArg(), timeouts[0])
+		.read("TCP_GUARANTEE", SecondsArg(), timeouts[1])
+		.read("TIMEOUT", SecondsArg(), _tcp_data_timeout)
+		.read("TCP_TIMEOUT", SecondsArg(), _tcp_data_timeout)
+		.read("TCP_DONE_TIMEOUT", SecondsArg(), _tcp_done_timeout)
+		.read("DST_ANNO", dst_anno)
+		.read("REPLY_ANNO", AnnoArg(1), reply_anno).read_status(has_reply_anno)
+		.consume() < 0)
+		return -1;
+
+	for (unsigned i=0; i<_mem_units_no; i++) {
+		_timeouts[i] = timeouts;
+	}
+
+	_annos = (dst_anno ? 1 : 0) + (has_reply_anno ? 2 + (reply_anno << 2) : 0);
+	_tcp_data_timeout *= CLICK_HZ; // IPRewriterBase handles the others
+	_tcp_done_timeout *= CLICK_HZ;
+
+	return IPRewriterBase::configure(conf, errh);
 }
 
 IPRewriterEntry *
 TCPRewriter::add_flow(int /*ip_p*/, const IPFlowID &flowid,
-		      const IPFlowID &rewritten_flowid, int input)
+			const IPFlowID &rewritten_flowid, int input)
 {
-    void *data;
-    if (!(data = _allocator.allocate()))
-	return 0;
+	void *data;
+	if (!(data = _allocator[click_current_cpu_id()].allocate()))
+		return 0;
+
+	TCPFlow *flow = new(data) TCPFlow
+		(&_input_specs[input], flowid, rewritten_flowid,
+		 !!_timeouts[click_current_cpu_id()][1], click_jiffies() +
+		 relevant_timeout(_timeouts[click_current_cpu_id()]));
 
-    TCPFlow *flow = new(data) TCPFlow
-	(&_input_specs[input], flowid, rewritten_flowid,
-	 !!_timeouts[1], click_jiffies() + relevant_timeout(_timeouts));
+	return store_flow(flow, input, _map[click_current_cpu_id()]);
+}
+
+int
+TCPRewriter::process(int port, Packet *p_in) {
+	WritablePacket *p = p_in->uniqueify();
+	if (!p) {
+		return -1;
+	}
+
+	click_ip *iph = p->ip_header();
+
+	// handle non-first fragments
+	if (iph->ip_p != IP_PROTO_TCP
+		|| !IP_FIRSTFRAG(iph)
+		|| p->transport_length() < 8) {
+		const IPRewriterInput &is = _input_specs[port];
+		if (is.kind == IPRewriterInput::i_nochange)
+			return is.foutput;
+		return -1;
+	}
 
-    return store_flow(flow, input, _map);
+	IPFlowID flowid(p);
+	IPRewriterEntry *m = _map[click_current_cpu_id()].get(flowid);
+
+	if (!m) {                   // create new mapping
+		IPRewriterInput &is = _input_specs.unchecked_at(port);
+		IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
+		int result = is.rewrite_flowid(flowid, rewritten_flowid, p);
+		if (result == rw_addmap)
+			m = TCPRewriter::add_flow(IP_PROTO_TCP, flowid, rewritten_flowid, port);
+		if (!m)
+			return result;
+		else if (_annos & 2)
+			m->flow()->set_reply_anno(p->anno_u8(_annos >> 2));
+	}
+
+	TCPFlow *mf = static_cast<TCPFlow *>(m->flow());
+	mf->apply(p, m->direction(), _annos, _calc_checksum);
+
+	click_jiffies_t now_j = click_jiffies();
+	if (_timeouts[click_current_cpu_id()][1])
+		mf->change_expiry(_heap[click_current_cpu_id()], true, now_j + _timeouts[click_current_cpu_id()][1]);
+	else
+		mf->change_expiry(_heap[click_current_cpu_id()], false, now_j + tcp_flow_timeout(mf));
+
+	return m->output();
 }
 
 void
-TCPRewriter::push(int port, Packet *p_in)
+TCPRewriter::push(int port, Packet *p)
 {
-    WritablePacket *p = p_in->uniqueify();
-    click_ip *iph = p->ip_header();
-
-    // handle non-first fragments
-    if (iph->ip_p != IP_PROTO_TCP
-	|| !IP_FIRSTFRAG(iph)
-	|| p->transport_length() < 8) {
-	const IPRewriterInput &is = _input_specs[port];
-	if (is.kind == IPRewriterInput::i_nochange)
-	    output(is.foutput).push(p);
-	else
-	    p->kill();
-	return;
-    }
-
-    IPFlowID flowid(p);
-    IPRewriterEntry *m = _map.get(flowid);
-
-    if (!m) {			// create new mapping
-	IPRewriterInput &is = _input_specs.unchecked_at(port);
-	IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
-	int result = is.rewrite_flowid(flowid, rewritten_flowid, p);
-	if (result == rw_addmap)
-	    m = TCPRewriter::add_flow(IP_PROTO_TCP, flowid, rewritten_flowid, port);
-	if (!m) {
-	    checked_output_push(result, p);
-	    return;
-	} else if (_annos & 2)
-	    m->flow()->set_reply_anno(p->anno_u8(_annos >> 2));
-    }
-
-    TCPFlow *mf = static_cast<TCPFlow *>(m->flow());
-    mf->apply(p, m->direction(), _annos);
-
-    click_jiffies_t now_j = click_jiffies();
-    if (_timeouts[1])
-	mf->change_expiry(_heap, true, now_j + _timeouts[1]);
-    else
-	mf->change_expiry(_heap, false, now_j + tcp_flow_timeout(mf));
-
-    output(m->output()).push(p);
+	int output_port = process(port, p);
+	if ( output_port < 0 ) {
+		p->kill();
+		return;
+	}
+
+	output(output_port).push(p);
 }
 
+#if HAVE_BATCH
+void
+TCPRewriter::push_batch(int port, PacketBatch *batch)
+{
+	unsigned short outports = noutputs();
+	PacketBatch* out[outports];
+	bzero(out,sizeof(PacketBatch*)*outports);
+	PacketBatch* next = ((batch != NULL)? static_cast<PacketBatch*>(batch->next()) : NULL );
+	PacketBatch* p = batch;
+	PacketBatch* last = NULL;
+	int last_o = -1;
+	int passed = 0;
+	int count  = 0;
+	for ( ; p != NULL;p=next,next=(p==0?0:static_cast<PacketBatch*>(p->next())) ) {
+		// The actual job of this element
+		int o = process(port, p);
+
+		if (o < 0 || o>=(outports)) o = (outports - 1);
+
+		if (o == last_o) {
+			passed ++;
+		}
+		else {
+			if ( !last ) {
+				out[o] = p;
+				p->set_count(1);
+				p->set_tail(p);
+			}
+			else {
+				out[last_o]->set_tail(last);
+				out[last_o]->set_count(out[last_o]->count() + passed);
+				if (!out[o]) {
+					out[o] = p;
+					out[o]->set_count(1);
+					out[o]->set_tail(p);
+				}
+				else {
+					out[o]->append_packet(p);
+				}
+				passed = 0;
+			}
+		}
+		last = p;
+		last_o = o;
+		count++;
+	}
+
+	if (passed) {
+		out[last_o]->set_tail(last);
+		out[last_o]->set_count(out[last_o]->count() + passed);
+	}
+
+	int i = 0;
+	for (; i < outports; i++) {
+		if (out[i]) {
+			out[i]->tail()->set_next(NULL);
+			checked_output_push_batch(i, out[i]);
+		}
+	}
+}
+#endif
 
 String
 TCPRewriter::tcp_mappings_handler(Element *e, void *)
 {
-    TCPRewriter *rw = (TCPRewriter *)e;
-    click_jiffies_t now = click_jiffies();
-    StringAccum sa;
-    for (Map::iterator iter = rw->_map.begin(); iter.live(); ++iter) {
-	TCPFlow *f = static_cast<TCPFlow *>(iter->flow());
-	f->unparse(sa, iter->direction(), now);
-	sa << '\n';
-    }
-    return sa.take_string();
+	TCPRewriter *rw = static_cast<TCPRewriter *> (e);
+	click_jiffies_t now = click_jiffies();
+	StringAccum sa;
+	for (Map::iterator iter = rw->_map[click_current_cpu_id()].begin(); iter.live(); ++iter) {
+		TCPFlow *f = static_cast<TCPFlow *>(iter->flow());
+		f->unparse(sa, iter->direction(), now);
+		sa << '\n';
+	}
+	return sa.take_string();
 }
 
 int
 TCPRewriter::tcp_lookup_handler(int, String &str, Element *e, const Handler *, ErrorHandler *errh)
 {
-    TCPRewriter *rw = (TCPRewriter *)e;
-    IPAddress saddr, daddr;
-    unsigned short sport, dport;
-
-    if (Args(rw, errh).push_back_words(str)
-	.read_mp("SADDR", saddr)
-	.read_mp("SPORT", IPPortArg(IP_PROTO_TCP), sport)
-	.read_mp("DADDR", daddr)
-	.read_mp("DPORT", IPPortArg(IP_PROTO_TCP), dport)
-	.complete() < 0)
-	return -1;
-
-    HashContainer<IPRewriterEntry> *map = rw->get_map(IPRewriterInput::mapid_default);
-    if (!map)
-	return errh->error("no map!");
-
-    StringAccum sa;
-    IPFlowID flow(saddr, htons(sport), daddr, htons(dport));
-    if (Map::iterator iter = map->find(flow)) {
-	TCPFlow *f = static_cast<TCPFlow *>(iter->flow());
-	const IPFlowID &flowid = f->entry(iter->direction()).rewritten_flowid();
-
-	sa << flowid.saddr() << " " << ntohs(flowid.sport()) << " "
-	   << flowid.daddr() << " " << ntohs(flowid.dport());
-    }
-
-    str = sa.take_string();
-    return 0;
+	TCPRewriter *rw = static_cast<TCPRewriter *> (e);
+	IPAddress saddr, daddr;
+	unsigned short sport, dport;
+
+	if (Args(rw, errh).push_back_words(str)
+		.read_mp("SADDR", saddr)
+		.read_mp("SPORT", IPPortArg(IP_PROTO_TCP), sport)
+		.read_mp("DADDR", daddr)
+		.read_mp("DPORT", IPPortArg(IP_PROTO_TCP), dport)
+		.complete() < 0)
+		return -1;
+
+	HashContainer<IPRewriterEntry> *map = rw->get_map(IPRewriterInput::mapid_default);
+	if (!map)
+		return errh->error("no map!");
+
+	StringAccum sa;
+	IPFlowID flow(saddr, htons(sport), daddr, htons(dport));
+	if (Map::iterator iter = map->find(flow)) {
+		TCPFlow *f = static_cast<TCPFlow *>(iter->flow());
+		const IPFlowID &flowid = f->entry(iter->direction()).rewritten_flowid();
+
+		sa 	<< flowid.saddr() << " " << ntohs(flowid.sport()) << " "
+			<< flowid.daddr() << " " << ntohs(flowid.dport());
+	}
+
+	str = sa.take_string();
+	return 0;
 }
 
 void
 TCPRewriter::add_handlers()
 {
-    add_read_handler("table", tcp_mappings_handler, 0);
-    add_read_handler("mappings", tcp_mappings_handler, 0, Handler::h_deprecated);
-    set_handler("lookup", Handler::OP_READ | Handler::READ_PARAM, tcp_lookup_handler, 0);
-    add_rewriter_handlers(true);
+	add_read_handler("table", tcp_mappings_handler, 0);
+	add_read_handler("mappings", tcp_mappings_handler, 0, Handler::h_deprecated);
+	set_handler("lookup", Handler::OP_READ | Handler::READ_PARAM, tcp_lookup_handler, 0);
+	add_rewriter_handlers(true);
 }
 
 CLICK_ENDDECLS
diff --git a/elements/tcpudp/tcprewriter.hh b/elements/tcpudp/tcprewriter.hh
index bcae3fc..09b35f6 100644
--- a/elements/tcpudp/tcprewriter.hh
+++ b/elements/tcpudp/tcprewriter.hh
@@ -84,7 +84,7 @@ table.
 
 Takes a flow as a space-separated
 
-    saddr sport daddr dport
+	saddr sport daddr dport
 
 and attempts to find a forward mapping for that flow. If found, rewrites the
 flow and returns in the same format.  Otherwise, returns nothing.
@@ -92,134 +92,145 @@ flow and returns in the same format.  Otherwise, returns nothing.
 =a IPRewriter, IPAddrRewriter, IPAddrPairRewriter, IPRewriterPatterns,
 FTPPortMapper */
 
-class TCPRewriter : public IPRewriterBase { public:
-
-    class TCPFlow : public IPRewriterFlow { public:
-
-	TCPFlow(IPRewriterInput *owner, const IPFlowID &flowid,
-		const IPFlowID &rewritten_flowid,
-		bool guaranteed, click_jiffies_t expiry_j)
-	    : IPRewriterFlow(owner, flowid, rewritten_flowid,
-			     IP_PROTO_TCP, guaranteed, expiry_j), _dt(0) {
-	}
-
-	~TCPFlow() {
-	    while (delta_transition *x = _dt) {
-		_dt = x->next();
-		delete x;
-	    }
-	}
-
-	enum {
-	    s_forward_done = 1, s_reply_done = 2,
-	    s_both_done = (s_forward_done | s_reply_done),
-	    s_forward_data = 4, s_reply_data = 8,
-	    s_both_data = (s_forward_data | s_reply_data)
-	};
-	bool both_done() const {
-	    return (_tflags & s_both_done) == s_both_done;
-	}
-	bool both_data() const {
-	    return (_tflags & s_both_data) == s_both_data;
-	}
-
-	int update_seqno_delta(bool direction, tcp_seq_t old_seqno, int32_t delta);
-	tcp_seq_t new_seq(bool direction, tcp_seq_t seqno) const;
-	tcp_seq_t new_ack(bool direction, tcp_seq_t seqno) const;
-
-	void apply(WritablePacket *p, bool direction, unsigned annos);
-
-	void unparse(StringAccum &sa, bool direction, click_jiffies_t now) const;
-
-      private:
-
-	struct delta_transition {
-	    int32_t delta[2];
-	    tcp_seq_t trigger[2];
-	    uintptr_t nextptr;
-	    delta_transition() {
-		memset(this, 0, sizeof(delta_transition));
-	    }
-	    delta_transition *next() const {
-		return reinterpret_cast<delta_transition *>(nextptr - (nextptr & 3));
-	    }
-	    bool has_trigger(bool direction) const {
-		return nextptr & (1 << direction);
-	    }
-	};
-
-	delta_transition *_dt;
-
-	void apply_sack(bool direction, click_tcp *tcp, int transport_len);
-
-    };
-
-    TCPRewriter() CLICK_COLD;
-    ~TCPRewriter() CLICK_COLD;
-
-    const char *class_name() const		{ return "TCPRewriter"; }
-    void *cast(const char *);
-
-    int configure(Vector<String> &, ErrorHandler *) CLICK_COLD;
-
-    IPRewriterEntry *add_flow(int ip_p, const IPFlowID &flowid,
-			      const IPFlowID &rewritten_flowid, int input);
-    void destroy_flow(IPRewriterFlow *flow);
-    click_jiffies_t best_effort_expiry(const IPRewriterFlow *flow) {
-	return flow->expiry() + tcp_flow_timeout(static_cast<const TCPFlow *>(flow)) - _timeouts[1];
-    }
-
-    void push(int, Packet *);
-
-    void add_handlers() CLICK_COLD;
-
- protected:
-
-    SizedHashAllocator<sizeof(TCPFlow)> _allocator;
-    unsigned _annos;
-    uint32_t _tcp_data_timeout;
-    uint32_t _tcp_done_timeout;
-
-    int tcp_flow_timeout(const TCPFlow *mf) const {
-	if (mf->both_done())
-	    return _tcp_done_timeout;
-	else if (mf->both_data())
-	    return _tcp_data_timeout;
-	else
-	    return _timeouts[0];
-    }
-
-    static String tcp_mappings_handler(Element *, void *);
-    static int tcp_lookup_handler(int, String &str, Element *e, const Handler *h, ErrorHandler *errh);
-
+class TCPRewriter : public IPRewriterBase {
+
+	public:
+		class TCPFlow : public IPRewriterFlow {
+			public:
+				TCPFlow(IPRewriterInput *owner, const IPFlowID &flowid,
+					const IPFlowID &rewritten_flowid,
+					bool guaranteed, click_jiffies_t expiry_j)
+					: IPRewriterFlow(owner, flowid, rewritten_flowid,
+							 IP_PROTO_TCP, guaranteed, expiry_j), _dt(0) {
+				}
+
+				~TCPFlow() {
+					while (delta_transition *x = _dt) {
+						_dt = x->next();
+						delete x;
+					}
+				}
+
+				enum {
+					s_forward_done = 1, s_reply_done = 2,
+					s_both_done = (s_forward_done | s_reply_done),
+					s_forward_data = 4, s_reply_data = 8,
+					s_both_data = (s_forward_data | s_reply_data)
+				};
+
+				bool both_done() const {
+					return (_tflags & s_both_done) == s_both_done;
+				}
+				bool both_data() const {
+					return (_tflags & s_both_data) == s_both_data;
+				}
+
+				int update_seqno_delta(bool direction, tcp_seq_t old_seqno, int32_t delta);
+				tcp_seq_t new_seq(bool direction, tcp_seq_t seqno) const;
+				tcp_seq_t new_ack(bool direction, tcp_seq_t seqno) const;
+
+				void apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum);
+				void unparse(StringAccum &sa, bool direction, click_jiffies_t now) const;
+
+			private:
+				struct delta_transition {
+					int32_t delta[2];
+					tcp_seq_t trigger[2];
+					uintptr_t nextptr;
+					delta_transition() {
+						memset(this, 0, sizeof(delta_transition));
+					}
+					delta_transition *next() const {
+						return reinterpret_cast<delta_transition *>(nextptr - (nextptr & 3));
+					}
+					bool has_trigger(bool direction) const {
+						return nextptr & (1 << direction);
+					}
+				};
+
+				delta_transition *_dt;
+				void apply_sack(bool direction, click_tcp *tcp, int transport_len, bool calc_checksum);
+		};
+
+		TCPRewriter () CLICK_COLD;
+		~TCPRewriter() CLICK_COLD;
+
+		const char *class_name() const { return "TCPRewriter"; }
+		void *cast(const char *);
+
+		int configure(Vector<String> &, ErrorHandler *) CLICK_COLD;
+
+		IPRewriterEntry *add_flow(int ip_p, const IPFlowID &flowid,
+					 				const IPFlowID &rewritten_flowid, int input);
+		void destroy_flow(IPRewriterFlow *flow);
+		click_jiffies_t best_effort_expiry(const IPRewriterFlow *flow) {
+			return flow->expiry() + tcp_flow_timeout(
+				static_cast<const TCPFlow *>(flow)) -
+				_timeouts[click_current_cpu_id()][1];
+		}
+
+		void push      (int port, Packet      *p);
+	#if HAVE_BATCH
+		void push_batch(int port, PacketBatch *batch);
+	#endif
+
+		void add_handlers() CLICK_COLD;
+
+	protected:
+	#if HAVE_USER_MULTITHREAD
+		unsigned _maps_no;
+		SizedHashAllocator<sizeof(TCPFlow)> *_allocator;
+	#else
+		SizedHashAllocator<sizeof(TCPFlow)> _allocator[CLICK_CPU_MAX];
+	#endif
+
+		unsigned _annos;
+		uint32_t _tcp_data_timeout;
+		uint32_t _tcp_done_timeout;
+
+		// The actual processing of this element is abstracted from the push operation.
+		// This allows both push and push_batch to exploit the same processing
+		int process(int port, Packet *p_in);
+
+		int tcp_flow_timeout(const TCPFlow *mf) const {
+			if (mf->both_done())
+				return _tcp_done_timeout;
+			else if (mf->both_data())
+				return _tcp_data_timeout;
+			else
+				return _timeouts[click_current_cpu_id()][0];
+		}
+
+		static String tcp_mappings_handler(Element *, void *);
+		static int tcp_lookup_handler(int, String &str, Element *e, const Handler *h, ErrorHandler *errh);
 };
 
 inline void
 TCPRewriter::destroy_flow(IPRewriterFlow *flow)
 {
-    unmap_flow(flow, _map);
-    static_cast<TCPFlow *>(flow)->~TCPFlow();
-    _allocator.deallocate(flow);
+	unmap_flow(flow, _map[click_current_cpu_id()]);
+	static_cast<TCPFlow *>(flow)->~TCPFlow();
+	_allocator[click_current_cpu_id()].deallocate(flow);
 }
 
 inline tcp_seq_t
 TCPRewriter::TCPFlow::new_seq(bool direction, tcp_seq_t seqno) const
 {
-    delta_transition *dt = _dt;
-    while (dt && dt->has_trigger(direction)
+	delta_transition *dt = _dt;
+	while (dt && dt->has_trigger(direction)
 	   && !SEQ_GEQ(seqno, dt->trigger[direction]))
 	dt = dt->next();
-    return dt ? seqno + dt->delta[direction] : seqno;
+	return dt ? seqno + dt->delta[direction] : seqno;
 }
 
 inline tcp_seq_t
 TCPRewriter::TCPFlow::new_ack(bool direction, tcp_seq_t ackno) const
 {
-    delta_transition *dt = _dt;
-    while (dt && dt->has_trigger(!direction)
+	delta_transition *dt = _dt;
+	while (dt && dt->has_trigger(!direction)
 	   && !SEQ_GEQ(ackno - dt->delta[!direction], dt->trigger[!direction]))
 	dt = dt->next();
-    return dt ? ackno - dt->delta[!direction] : ackno;
+	return dt ? ackno - dt->delta[!direction] : ackno;
 }
 
 CLICK_ENDDECLS
diff --git a/elements/tcpudp/udprewriter.cc b/elements/tcpudp/udprewriter.cc
index b3d0f62..9eb396b 100644
--- a/elements/tcpudp/udprewriter.cc
+++ b/elements/tcpudp/udprewriter.cc
@@ -2,8 +2,11 @@
  * udprewriter.{cc,hh} -- rewrites packet source and destination
  * Max Poletto, Eddie Kohler
  *
+ * Per-core, thread safe data structures and batching by Georgios Katsikas
+ *
  * Copyright (c) 2000 Massachusetts Institute of Technology
  * Copyright (c) 2008-2010 Meraki, Inc.
+ * Copyright (c) 2016 KTH Royal Institute of Technology
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -27,175 +30,267 @@
 CLICK_DECLS
 
 void
-UDPRewriter::UDPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
+UDPRewriter::UDPFlow::apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum)
 {
-    assert(p->has_network_header());
-    click_ip *iph = p->ip_header();
-
-    // IP header
-    const IPFlowID &revflow = _e[!direction].flowid();
-    iph->ip_src = revflow.daddr();
-    iph->ip_dst = revflow.saddr();
-    if (annos & 1)
-	p->set_dst_ip_anno(revflow.saddr());
-    if (direction && (annos & 2))
-	p->set_anno_u8(annos >> 2, _reply_anno);
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
-
-    // end if not first fragment
-    if (!IP_FIRSTFRAG(iph))
-	return;
-
-    // TCP/UDP header
-    click_udp *udph = p->udp_header();
-    udph->uh_sport = revflow.dport(); // TCP ports in the same place
-    udph->uh_dport = revflow.sport();
-    if (iph->ip_p == IP_PROTO_TCP) {
-	if (p->transport_length() >= 18)
-	    update_csum(&reinterpret_cast<click_tcp *>(udph)->th_sum, direction, _udp_csum_delta);
-    } else if (iph->ip_p == IP_PROTO_UDP) {
-	if (p->transport_length() >= 8 && udph->uh_sum)
-	    // 0 checksum is no checksum
-	    update_csum(&udph->uh_sum, direction, _udp_csum_delta);
-    }
-
-    // track connection state
-    if (direction)
-	_tflags |= 1;
-    if (_tflags < 6)
-	_tflags += 2;
+	assert(p->has_network_header());
+	click_ip *iph = p->ip_header();
+
+	// IP header
+	const IPFlowID &revflow = _e[!direction].flowid();
+	iph->ip_src = revflow.daddr();
+	iph->ip_dst = revflow.saddr();
+	if (annos & 1)
+		p->set_dst_ip_anno(revflow.saddr());
+	if (direction && (annos & 2))
+		p->set_anno_u8(annos >> 2, _reply_anno);
+
+	// SNF: Allow to skip IP checksum calculation
+	if ( calc_checksum ) {
+		update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+	}
+
+	// end if not first fragment
+	if (!IP_FIRSTFRAG(iph))
+		return;
+
+	// TCP/UDP header
+	click_udp *udph = p->udp_header();
+	udph->uh_sport = revflow.dport(); // TCP ports in the same place
+	udph->uh_dport = revflow.sport();
+	if (iph->ip_p == IP_PROTO_TCP) {
+		if (p->transport_length() >= 18)
+			update_csum(&reinterpret_cast<click_tcp *>(udph)->th_sum, direction, _udp_csum_delta);
+	}
+	else if (iph->ip_p == IP_PROTO_UDP) {
+		if (p->transport_length() >= 8 && udph->uh_sum)
+			// SNF: Allow to skip UDP checksum calculation
+			if ( calc_checksum ) {
+				update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+			}
+	}
+
+	// track connection state
+	if (direction)
+		_tflags |= 1;
+	if (_tflags < 6)
+		_tflags += 2;
 }
 
 UDPRewriter::UDPRewriter()
 {
+#if HAVE_USER_MULTITHREAD
+	_maps_no = ( click_max_cpu_ids() == 0 )? 1 : click_max_cpu_ids();
+	_allocator = new SizedHashAllocator<sizeof(UDPFlow)>[_maps_no];
+	//click_chatter("[%s]: Allocated %d UDP maps", class_name(), _maps_no);
+#endif
 }
 
 UDPRewriter::~UDPRewriter()
 {
+#if HAVE_USER_MULTITHREAD
+	if ( _allocator )
+		delete [] _allocator;
+#endif
 }
 
 void *
 UDPRewriter::cast(const char *n)
 {
-    if (strcmp(n, "IPRewriterBase") == 0)
-	return (IPRewriterBase *)this;
-    else if (strcmp(n, "UDPRewriter") == 0)
-	return (UDPRewriter *)this;
-    else
-	return 0;
+	if (strcmp(n, "IPRewriterBase") == 0)
+		return static_cast<IPRewriterBase *> (this);
+	else if (strcmp(n, "UDPRewriter") == 0)
+		return static_cast<UDPRewriter *> (this);
+	else
+		return 0;
 }
 
 int
 UDPRewriter::configure(Vector<String> &conf, ErrorHandler *errh)
 {
-    bool dst_anno = true, has_reply_anno = false,
+	bool dst_anno = true, has_reply_anno = false,
 	has_udp_streaming_timeout, has_streaming_timeout;
-    int reply_anno;
-    _timeouts[0] = 300;		// 5 minutes
-
-    if (Args(this, errh).bind(conf)
-	.read("DST_ANNO", dst_anno)
-	.read("REPLY_ANNO", AnnoArg(1), reply_anno).read_status(has_reply_anno)
-	.read("UDP_TIMEOUT", SecondsArg(), _timeouts[0])
-	.read("TIMEOUT", SecondsArg(), _timeouts[0])
-	.read("UDP_STREAMING_TIMEOUT", SecondsArg(), _udp_streaming_timeout).read_status(has_udp_streaming_timeout)
-	.read("STREAMING_TIMEOUT", SecondsArg(), _udp_streaming_timeout).read_status(has_streaming_timeout)
-	.read("UDP_GUARANTEE", SecondsArg(), _timeouts[1])
-	.consume() < 0)
-	return -1;
-
-    _annos = (dst_anno ? 1 : 0) + (has_reply_anno ? 2 + (reply_anno << 2) : 0);
-    if (!has_udp_streaming_timeout && !has_streaming_timeout)
-	_udp_streaming_timeout = _timeouts[0];
-    _udp_streaming_timeout *= CLICK_HZ; // IPRewriterBase handles the others
-
-    return IPRewriterBase::configure(conf, errh);
+	int reply_anno;
+	uint32_t timeouts[2];
+	timeouts[0] = 300;		// 5 minutes
+
+	if (Args(this, errh).bind(conf)
+		.read("DST_ANNO", dst_anno)
+		.read("REPLY_ANNO", AnnoArg(1), reply_anno).read_status(has_reply_anno)
+		.read("UDP_TIMEOUT", SecondsArg(), timeouts[0])
+		.read("TIMEOUT", SecondsArg(), timeouts[0])
+		.read("UDP_STREAMING_TIMEOUT", SecondsArg(), _udp_streaming_timeout).read_status(has_udp_streaming_timeout)
+		.read("STREAMING_TIMEOUT", SecondsArg(), _udp_streaming_timeout).read_status(has_streaming_timeout)
+		.read("UDP_GUARANTEE", SecondsArg(), timeouts[1])
+		.consume() < 0)
+		return -1;
+
+	for (unsigned i=0; i<_mem_units_no; i++) {
+		_timeouts[i] = timeouts;
+	}
+
+	_annos = (dst_anno ? 1 : 0) + (has_reply_anno ? 2 + (reply_anno << 2) : 0);
+	if (!has_udp_streaming_timeout && !has_streaming_timeout)
+		_udp_streaming_timeout = _timeouts[click_current_cpu_id()][0];
+	_udp_streaming_timeout *= CLICK_HZ; // IPRewriterBase handles the others
+
+	return IPRewriterBase::configure(conf, errh);
 }
 
 IPRewriterEntry *
 UDPRewriter::add_flow(int ip_p, const IPFlowID &flowid,
-		      const IPFlowID &rewritten_flowid, int input)
+			const IPFlowID &rewritten_flowid, int input)
 {
-    void *data;
-    if (!(data = _allocator.allocate()))
-	return 0;
+	void *data = _allocator[click_current_cpu_id()].allocate();
+	if ( !data )
+		return 0;
+
+	UDPFlow *flow = new(data) UDPFlow
+		(&_input_specs[input], flowid, rewritten_flowid, ip_p,
+		 !!_timeouts[click_current_cpu_id()][1], click_jiffies() +
+		 relevant_timeout(_timeouts[click_current_cpu_id()]));
+
+	return store_flow(flow, input, _map[click_current_cpu_id()]);
+}
+
+int
+UDPRewriter::process(int port, Packet *p_in) {
+	WritablePacket *p = p_in->uniqueify();
+	if (!p) {
+		return -1;
+	}
+	click_ip *iph = p->ip_header();
+
+	// Handle non-TCP and non-first fragments
+	int ip_p = iph->ip_p;
+	if ((ip_p != IP_PROTO_TCP && ip_p != IP_PROTO_UDP && ip_p != IP_PROTO_DCCP)
+		|| !IP_FIRSTFRAG(iph)
+		|| p->transport_length() < 8) {
+		const IPRewriterInput &is = _input_specs[port];
+		if (is.kind == IPRewriterInput::i_nochange)
+			return is.foutput;
+		return -1;
+	}
+
+	IPFlowID flowid(p);
+	IPRewriterEntry *m = _map[click_current_cpu_id()].get(flowid);
+
+	if (!m) {                   // create new mapping
+		IPRewriterInput &is = _input_specs.unchecked_at(port);
+		IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
+		int result = is.rewrite_flowid(flowid, rewritten_flowid, p);
+		if (result == rw_addmap)
+			m = UDPRewriter::add_flow(ip_p, flowid, rewritten_flowid, port);
+		if (!m)
+			return result;
+		else if (_annos & 2)
+			m->flow()->set_reply_anno(p->anno_u8(_annos >> 2));
+	}
 
-    UDPFlow *flow = new(data) UDPFlow
-	(&_input_specs[input], flowid, rewritten_flowid, ip_p,
-	 !!_timeouts[1], click_jiffies() + relevant_timeout(_timeouts));
+	UDPFlow *mf = static_cast<UDPFlow *>(m->flow());
+	mf->apply(p, m->direction(), _annos, _calc_checksum);
 
-    return store_flow(flow, input, _map);
+	click_jiffies_t now_j = click_jiffies();
+	if (_timeouts[click_current_cpu_id()][1])
+		mf->change_expiry(_heap[click_current_cpu_id()], true, now_j + _timeouts[click_current_cpu_id()][1]);
+	else
+		mf->change_expiry(_heap[click_current_cpu_id()], false, now_j + udp_flow_timeout(mf));
+
+	return m->output();
 }
 
 void
-UDPRewriter::push(int port, Packet *p_in)
+UDPRewriter::push(int port, Packet *p)
 {
-    WritablePacket *p = p_in->uniqueify();
-    if (!p)
-	return;
-    click_ip *iph = p->ip_header();
-
-    // handle non-TCP and non-first fragments
-    int ip_p = iph->ip_p;
-    if ((ip_p != IP_PROTO_TCP && ip_p != IP_PROTO_UDP && ip_p != IP_PROTO_DCCP)
-	|| !IP_FIRSTFRAG(iph)
-	|| p->transport_length() < 8) {
-	const IPRewriterInput &is = _input_specs[port];
-	if (is.kind == IPRewriterInput::i_nochange)
-	    output(is.foutput).push(p);
-	else
-	    p->kill();
-	return;
-    }
-
-    IPFlowID flowid(p);
-    IPRewriterEntry *m = _map.get(flowid);
-
-    if (!m) {			// create new mapping
-	IPRewriterInput &is = _input_specs.unchecked_at(port);
-	IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
-	int result = is.rewrite_flowid(flowid, rewritten_flowid, p);
-	if (result == rw_addmap)
-	    m = UDPRewriter::add_flow(ip_p, flowid, rewritten_flowid, port);
-	if (!m) {
-	    checked_output_push(result, p);
-	    return;
-	} else if (_annos & 2)
-	    m->flow()->set_reply_anno(p->anno_u8(_annos >> 2));
-    }
-
-    UDPFlow *mf = static_cast<UDPFlow *>(m->flow());
-    mf->apply(p, m->direction(), _annos);
-
-    click_jiffies_t now_j = click_jiffies();
-    if (_timeouts[1])
-	mf->change_expiry(_heap, true, now_j + _timeouts[1]);
-    else
-	mf->change_expiry(_heap, false, now_j + udp_flow_timeout(mf));
-
-    output(m->output()).push(p);
+	int output_port = process(port, p);
+	if ( output_port < 0 ) {
+		p->kill();
+		return;
+	}
+
+	output(output_port).push(p);
 }
 
+#if HAVE_BATCH
+void
+UDPRewriter::push_batch(int port, PacketBatch *batch)
+{
+	unsigned short outports = noutputs();
+	PacketBatch *out[outports];
+	bzero(out, sizeof(PacketBatch*) *outports);
+	PacketBatch *next = ((batch != NULL)? static_cast<PacketBatch*>(batch->next()) : NULL );
+	PacketBatch *p = batch;
+	PacketBatch *last = NULL;
+	int last_o = -1;
+	int passed = 0;
+	int count  = 0;
+	for ( ; p != NULL;p=next,next=(p==0?0:static_cast<PacketBatch*>(p->next())) ) {
+		// The actual job of this element
+		int o = process(port, p);
+
+		if (o < 0 || o>=(outports)) o = (outports - 1);
+
+		if (o == last_o) {
+			passed ++;
+		}
+		else {
+			if ( !last ) {
+				out[o] = p;
+				p->set_count(1);
+				p->set_tail(p);
+			}
+			else {
+				out[last_o]->set_tail(last);
+				out[last_o]->set_count(out[last_o]->count() + passed);
+				if (!out[o]) {
+					out[o] = p;
+					out[o]->set_count(1);
+					out[o]->set_tail(p);
+				}
+				else {
+					out[o]->append_packet(p);
+				}
+				passed = 0;
+			}
+		}
+		last = p;
+		last_o = o;
+		count++;
+	}
+
+	if (passed) {
+		out[last_o]->set_tail(last);
+		out[last_o]->set_count(out[last_o]->count() + passed);
+	}
+
+	int i = 0;
+	for (; i < outports; i++) {
+		if (out[i]) {
+			out[i]->tail()->set_next(NULL);
+			checked_output_push_batch(i, out[i]);
+		}
+	}
+}
+#endif
 
 String
 UDPRewriter::dump_mappings_handler(Element *e, void *)
 {
-    UDPRewriter *rw = (UDPRewriter *)e;
-    click_jiffies_t now = click_jiffies();
-    StringAccum sa;
-    for (Map::iterator iter = rw->_map.begin(); iter.live(); ++iter) {
-	iter->flow()->unparse(sa, iter->direction(), now);
-	sa << '\n';
-    }
-    return sa.take_string();
+	UDPRewriter *rw = static_cast<UDPRewriter *> (e);
+	click_jiffies_t now = click_jiffies();
+	StringAccum sa;
+	for (Map::iterator iter = rw->_map[click_current_cpu_id()].begin(); iter.live(); ++iter) {
+		iter->flow()->unparse(sa, iter->direction(), now);
+		sa << '\n';
+	}
+	return sa.take_string();
 }
 
 void
 UDPRewriter::add_handlers()
 {
-    add_read_handler("table", dump_mappings_handler);
-    add_read_handler("mappings", dump_mappings_handler, 0, Handler::h_deprecated);
-    add_rewriter_handlers(true);
+	add_read_handler("table", dump_mappings_handler);
+	add_read_handler("mappings", dump_mappings_handler, 0, Handler::h_deprecated);
+	add_rewriter_handlers(true);
 }
 
 CLICK_ENDDECLS
diff --git a/elements/tcpudp/udprewriter.hh b/elements/tcpudp/udprewriter.hh
index 4246624..684e135 100644
--- a/elements/tcpudp/udprewriter.hh
+++ b/elements/tcpudp/udprewriter.hh
@@ -33,7 +33,7 @@ Each mapping contains a new flow identifier and an output port.  Input packets
 with the indexed flow identifier are rewritten to use the new flow identifier,
 then emitted on the output port.  A mapping is written as follows:
 
-    (SA, SP, DA, DP) => (SA', SP', DA', DP') [OUTPUT]
+	(SA, SP, DA, DP) => (SA', SP', DA', DP') [OUTPUT]
 
 When UDPRewriter receives a packet, it first looks up that packet in the
 mapping table by flow identifier.  If the table contains a mapping for the
@@ -62,8 +62,8 @@ Installs mappings that preserve the input packet's flow ID.  Specifically,
 given an input packet with flow ID (SA, SP, DA, DP, PROTO), two mappings are
 installed:
 
-    (SA, SP, DA, DP, PROTO) => (SA, SP, DA, DP) [FOUTPUT]
-    (DA, DP, SA, SP, PROTO) => (DA, DP, SA, SP) [ROUTPUT]
+	(SA, SP, DA, DP, PROTO) => (SA, SP, DA, DP) [FOUTPUT]
+	(DA, DP, SA, SP, PROTO) => (DA, DP, SA, SP) [ROUTPUT]
 
 Thus, the input packet is emitted on output port FOUTPUT unchanged, and
 packets from the reply flow are emitted on output port ROUTPUT unchanged.
@@ -87,8 +87,8 @@ Say a packet with flow ID (SA, SP, DA, DP, PROTO) is received, and the
 corresponding new flow ID is (SA', SP', DA', DP').  Then two mappings are
 installed:
 
-    (SA, SP, DA, DP, PROTO) => (SA', SP', DA', DP') [FOUTPUT]
-    (DA', DP', SA', SP', PROTO) => (DA, DP, SA, SP) [ROUTPUT]
+	(SA, SP, DA, DP, PROTO) => (SA', SP', DA', DP') [FOUTPUT]
+	(DA', DP', SA', SP', PROTO) => (DA, DP, SA, SP) [ROUTPUT]
 
 Thus, the input packet is rewritten and sent to FOUTPUT, and packets from the
 reply flow are rewritten to look like part of the original flow and sent to
@@ -160,70 +160,85 @@ table.
 =a TCPRewriter, IPAddrRewriter, IPAddrPairRewriter, IPRewriterPatterns,
 RoundRobinIPMapper, FTPPortMapper, ICMPRewriter, ICMPPingRewriter */
 
-class UDPRewriter : public IPRewriterBase { public:
+class UDPRewriter : public IPRewriterBase {
 
-    class UDPFlow : public IPRewriterFlow { public:
+	public:
+		class UDPFlow : public IPRewriterFlow {
 
-	UDPFlow(IPRewriterInput *owner, const IPFlowID &flowid,
-		const IPFlowID &rewritten_flowid, int ip_p,
-		bool guaranteed, click_jiffies_t expiry_j)
-	    : IPRewriterFlow(owner, flowid, rewritten_flowid,
-			     ip_p, guaranteed, expiry_j) {
-	}
+			public:
+				UDPFlow(IPRewriterInput *owner, const IPFlowID &flowid,
+					const IPFlowID &rewritten_flowid, int ip_p,
+					bool guaranteed, click_jiffies_t expiry_j)
+					: IPRewriterFlow(owner, flowid, rewritten_flowid,
+							 ip_p, guaranteed, expiry_j) {
+				}
 
-	bool streaming() const {
-	    return _tflags > 6;
-	}
+				bool streaming() const {
+					return _tflags > 6;
+				}
 
-	void apply(WritablePacket *p, bool direction, unsigned annos);
+				void apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum);
+		};
 
-    };
+		UDPRewriter () CLICK_COLD;
+		~UDPRewriter() CLICK_COLD;
 
-    UDPRewriter() CLICK_COLD;
-    ~UDPRewriter() CLICK_COLD;
+		const char *class_name() const	{ return "UDPRewriter"; }
+		void *cast(const char *);
 
-    const char *class_name() const		{ return "UDPRewriter"; }
-    void *cast(const char *);
+		int configure(Vector<String> &, ErrorHandler *) CLICK_COLD;
 
-    int configure(Vector<String> &, ErrorHandler *) CLICK_COLD;
+		IPRewriterEntry *add_flow(int ip_p, const IPFlowID &flowid,
+									const IPFlowID &rewritten_flowid, int input);
 
-    IPRewriterEntry *add_flow(int ip_p, const IPFlowID &flowid,
-			      const IPFlowID &rewritten_flowid, int input);
-    void destroy_flow(IPRewriterFlow *flow);
-    click_jiffies_t best_effort_expiry(const IPRewriterFlow *flow) {
-	return flow->expiry() + udp_flow_timeout(static_cast<const UDPFlow *>(flow)) - _timeouts[1];
-    }
+		void destroy_flow(IPRewriterFlow *flow);
+		click_jiffies_t best_effort_expiry(const IPRewriterFlow *flow) {
+			return flow->expiry() +
+				udp_flow_timeout(static_cast<const UDPFlow *>(flow)) -
+				_timeouts[click_current_cpu_id()][1];
+		}
 
-    void push(int, Packet *);
+		void push      (int port, Packet      *p);
+	#if HAVE_BATCH
+		void push_batch(int port, PacketBatch *batch);
+	#endif
 
-    void add_handlers() CLICK_COLD;
+		void add_handlers() CLICK_COLD;
 
-  private:
+	private:
+	#if HAVE_USER_MULTITHREAD
+		unsigned _maps_no;
+		SizedHashAllocator<sizeof(UDPFlow)> *_allocator;
+	#else
+		SizedHashAllocator<sizeof(UDPFlow)> _allocator[CLICK_CPU_MAX];
+	#endif
 
-    SizedHashAllocator<sizeof(UDPFlow)> _allocator;
-    unsigned _annos;
-    uint32_t _udp_streaming_timeout;
+		unsigned _annos;
+		uint32_t _udp_streaming_timeout;
 
-    int udp_flow_timeout(const UDPFlow *mf) const {
-	if (mf->streaming())
-	    return _udp_streaming_timeout;
-	else
-	    return _timeouts[0];
-    }
+		// The actual processing of this element is abstracted from the push operation.
+		// This allows both push and push_batch to exploit the same processing
+		int process(int port, Packet *p_in);
 
-    static String dump_mappings_handler(Element *, void *);
+		int udp_flow_timeout(const UDPFlow *mf) const {
+			if (mf->streaming())
+				return _udp_streaming_timeout;
+			else
+				return _timeouts[click_current_cpu_id()][0];
+		}
 
-    friend class IPRewriter;
+		static String dump_mappings_handler(Element *, void *);
 
+		friend class IPRewriter;
 };
 
 
 inline void
 UDPRewriter::destroy_flow(IPRewriterFlow *flow)
 {
-    unmap_flow(flow, _map);
-    flow->~IPRewriterFlow();
-    _allocator.deallocate(flow);
+	unmap_flow(flow, _map[click_current_cpu_id()]);
+	flow->~IPRewriterFlow();
+	_allocator[click_current_cpu_id()].deallocate(flow);
 }
 
 CLICK_ENDDECLS
diff --git a/include/click/router.hh b/include/click/router.hh
index b4fa24b..798cae8 100644
--- a/include/click/router.hh
+++ b/include/click/router.hh
@@ -133,7 +133,13 @@ class Router { public:
     inline Router* hotswap_router() const;
     void set_hotswap_router(Router* router);
 
-    int initialize(ErrorHandler* errh);
+    /*
+     * SNF Modification to prevent Click from initializing the elements in this call.
+     * We simply want to have the Click DAG populated with all the elements and connections.
+     * The 2nd argument is set to false by default. This is how normal Click calls the function
+     * so it does not affect normal Click executions.
+     */
+    int initialize(ErrorHandler* errh, bool initialize_only_dag=false);
     void activate(bool foreground, ErrorHandler* errh);
     inline void activate(ErrorHandler* errh);
     inline void set_foreground(bool foreground);
@@ -301,6 +307,10 @@ class Router { public:
 
     Router* _next_router;
 
+    // SNF extension: If set to true, the router's elements are not initialized
+    // Router::initialize() and ~Router() use this field to properly set and reset the router
+    bool _do_not_initialize;
+
 #if CLICK_LINUXMODULE
     Vector<struct module*> _modules;
 #endif
diff --git a/lib/dpdkdevice.cc b/lib/dpdkdevice.cc
index 9264320..4e858b5 100644
--- a/lib/dpdkdevice.cc
+++ b/lib/dpdkdevice.cc
@@ -2,8 +2,11 @@
  * dpdkdevice.{cc,hh} -- library for interfacing with Intel's DPDK
  * Cyril Soldani, Tom Barbette
  *
+ * Symmetric RSS added by Georgios Katsikas
+ *
  * Copyright (c) 2014-2016 University of Liege
  * Copyright (c) 2016 Cisco Meraki
+ * Copyright (c) 2015-2016 KTH Royal Institute of Technology
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -22,6 +25,18 @@
 
 CLICK_DECLS
 
+// SNF: A group of smart people found that there is a specific hash key
+//      which gives you both symmetrical flow distribution and a uniform one.
+//      You can read about it in their published paper:
+//            http://www.ndsl.kaist.edu/~kyoungsoo/papers/TR-symRSS.pdf
+//      Some tests have been done to check the uniform distribution of this key
+//      with random IP traffic and found it to be good (and symmetrical).
+//      The hash key (in case you dont want to read the document) is:
+static uint8_t symmetric_hashkey[40] = {
+	0x6D, 0x5A, 0x6D, 0x5A, 0x6D, 0x5A, 0x6D, 0x5A, 0x6D, 0x5A, 0x6D, 0x5A, 0x6D, 0x5A, 0x6D, 0x5A, 0x6D, 0x5A, 0x6D, 0x5A,
+	0x6D, 0x5A, 0x6D, 0x5A, 0x6D, 0x5A, 0x6D, 0x5A, 0x6D, 0x5A, 0x6D, 0x5A, 0x6D, 0x5A, 0x6D, 0x5A, 0x6D, 0x5A, 0x6D, 0x5A
+};
+
 /* Wraps rte_eth_dev_socket_id(), which may return -1 for valid ports when NUMA
  * is not well supported. This function will return 0 instead in that case. */
 int DPDKDevice::get_port_numa_node(unsigned port_id)
@@ -137,7 +152,8 @@ int DPDKDevice::initialize_device(ErrorHandler *errh)
     rte_eth_dev_info_get(port_id, &dev_info);
 
     dev_conf.rxmode.mq_mode = ETH_MQ_RX_RSS;
-    dev_conf.rx_adv_conf.rss_conf.rss_key = NULL;
+    // SNF: Symmetric RSS
+    dev_conf.rx_adv_conf.rss_conf.rss_key = symmetric_hashkey;
     dev_conf.rx_adv_conf.rss_conf.rss_hf = ETH_RSS_IP;
 
     //We must open at least one queue per direction
diff --git a/lib/driver.cc b/lib/driver.cc
index 555fe92..ae5ec8a 100644
--- a/lib/driver.cc
+++ b/lib/driver.cc
@@ -3,9 +3,13 @@
  * driver.cc -- support for packages
  * Eddie Kohler
  *
+ * Extensions to allow optional deactivation of the router's complete initialization
+ * Georgios Katsikas
+ *
  * Copyright (c) 2001 Mazu Networks, Inc.
  * Copyright (c) 2003 International Computer Science Institute
  * Copyright (c) 2007 Regents of the University of California
+ * Copyright (c) 2016 KTH Royal Institute of Technology
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -535,8 +539,10 @@ click_read_router(String filename, bool is_expr, ErrorHandler *errh, bool initia
     l->end_parse(cookie);
 
     // initialize if requested
+    // SNF extension: If initialize_only_dag is true, the router's elements are not initialized.
+    bool initialize_only_dag = false;
     if (initialize)
-        if (errh->nerrors() > before || router->initialize(errh) < 0) {
+        if (errh->nerrors() > before || router->initialize(errh, initialize_only_dag) < 0) {
             delete router;
             return 0;
         }
diff --git a/lib/router.cc b/lib/router.cc
index c617aae..70e8865 100644
--- a/lib/router.cc
+++ b/lib/router.cc
@@ -3,10 +3,14 @@
  * router.{cc,hh} -- a Click router configuration
  * Eddie Kohler
  *
+ * Extensions to allow optional deactivation of the router's complete initialization
+ * Georgios Katsikas
+ *
  * Copyright (c) 1999-2000 Massachusetts Institute of Technology
  * Copyright (c) 2000 Mazu Networks, Inc.
  * Copyright (c) 2004-2007 Regents of the University of California
  * Copyright (c) 2008 Meraki, Inc.
+ * Copyright (c) 2016 KTH Royal Institute of Technology
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -87,7 +91,8 @@ Router::Router(const String &configuration, Master *master)
       _configuration(configuration),
       _notifier_signals(0),
       _arena_factory(new HashMap_ArenaFactory),
-      _hotswap_router(0), _thread_sched(0), _name_info(0), _next_router(0)
+      _hotswap_router(0), _thread_sched(0), _name_info(0), _next_router(0),
+      _do_not_initialize(false)
 {
     _refcount = 0;
     _runcount = 0;
@@ -121,7 +126,9 @@ Router::~Router()
         for (int ord = _elements.size() - 1; ord >= 0; ord--)
             _elements[ _element_configure_order[ord] ]->cleanup(Element::CLEANUP_ROUTER_INITIALIZED);
     } else if (_state != ROUTER_DEAD) {
-        assert(_element_configure_order.size() == 0 && _state <= ROUTER_PRECONFIGURE);
+        // We do not follow all the Click states when _do_not_initialize is true
+        if (!_do_not_initialize)
+            assert(_element_configure_order.size() == 0 && _state <= ROUTER_PRECONFIGURE);
         for (int i = _elements.size() - 1; i >= 0; i--)
             _elements[i]->cleanup(Element::CLEANUP_NO_ROUTER);
     }
@@ -155,6 +162,12 @@ Router::~Router()
         delete ns;
     }
     delete _name_info;
+
+    // Return here in case that the router has been constructed by setting this member to true.
+    // In this case we haven't registered our Router in the first place.
+    if (_do_not_initialize)
+        return;
+
     if (_master)
         _master->unregister_router(this);
 }
@@ -1089,7 +1102,7 @@ Router::initialize_handlers(bool defaults, bool specifics)
 }
 
 int
-Router::initialize(ErrorHandler *errh)
+Router::initialize(ErrorHandler *errh, bool do_not_initialize)
 {
     if (_state != ROUTER_NEW)
         return errh->error("second attempt to initialize router");
@@ -1169,6 +1182,18 @@ Router::initialize(ErrorHandler *errh)
         }
     }
 
+    //////////////////////////////////////////////////////////////////////////////
+    /*
+     * SNF modification to prevent the initialization of Click elements
+     * It happens only when the boolean argument is true. Default is false.
+     */
+    //////////////////////////////////////////////////////////////////////////////
+    if ( do_not_initialize ) {
+        // This field is useful in the destructor
+        _do_not_initialize = true;
+        return 0;
+    }
+
 #if HAVE_BATCH
     if (all_ok) {
         //In the first phase we propagate batch mode from all BATCH_MODE_YES elements, being the one instanciating batches
diff --git a/userlevel/click.cc b/userlevel/click.cc
index d5e6fad..4bd9e60 100644
--- a/userlevel/click.cc
+++ b/userlevel/click.cc
@@ -3,12 +3,16 @@
  * click.cc -- user-level Click main program
  * Eddie Kohler
  *
+ * Extensions to allow optional deactivation of the router's complete initialization
+ * Georgios Katsikas
+ *
  * Copyright (c) 1999-2000 Massachusetts Institute of Technology
  * Copyright (c) 2000 Mazu Networks, Inc.
  * Copyright (c) 2001-2003 International Computer Science Institute
  * Copyright (c) 2004-2006 Regents of the University of California
  * Copyright (c) 2008-2009 Meraki, Inc.
  * Copyright (c) 1999-2015 Eddie Kohler
+ * Copyright (c) 2016 KTH Royal Institute of Technology
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -395,8 +399,9 @@ parse_configuration(const String &text, bool text_is_expr, bool hotswap,
   if (hotswap && click_router && click_router->initialized())
       router->set_hotswap_router(click_router);
 
+  bool initialize_only_dag = false;
   if (errh->nerrors() == before_errors
-      && router->initialize(errh) >= 0)
+      && router->initialize(errh, initialize_only_dag) >= 0)
     return router;
   else {
     delete router;
