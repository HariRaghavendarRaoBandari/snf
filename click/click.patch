diff --git elements/icmp/icmprewriter.cc elements/icmp/icmprewriter.cc
index 28de1db..e780844 100644
--- elements/icmp/icmprewriter.cc
+++ elements/icmp/icmprewriter.cc
@@ -43,6 +43,7 @@ ICMPRewriter::configure(Vector<String> &conf, ErrorHandler *errh)
     if (Args(conf, this, errh)
 	.read_mp("MAPS", AnyArg(), arg)
 	.read("DST_ANNO", dst_anno)
+	.read("CALC_CHECKSUM", _calc_checksum)
 	.read("REPLY_ANNO", AnnoArg(1), reply_anno).read_status(has_reply_anno)
 	.complete() < 0)
 	return -1;
@@ -163,7 +164,9 @@ ICMPRewriter::handle(WritablePacket *p)
 	click_ip *iph = p->ip_header();
 	memcpy(old_hw, &iph->ip_dst, 4);
 	iph->ip_dst = new_flowid.daddr();
-	update_in_cksum(&iph->ip_sum, old_hw, reinterpret_cast<const uint16_t *>(&iph->ip_dst), 2);
+	if ( _calc_checksum ) {
+		update_in_cksum(&iph->ip_sum, old_hw, reinterpret_cast<const uint16_t *>(&iph->ip_dst), 2);
+	}
 	if (_annos & 1)
 	    p->set_dst_ip_anno(new_flowid.daddr());
     }
@@ -176,7 +179,9 @@ ICMPRewriter::handle(WritablePacket *p)
     enc_iph->ip_src = new_flowid.daddr();
     enc_iph->ip_dst = new_flowid.saddr(); // XXX source routing
     memcpy(&new_hw[1], &enc_iph->ip_src, 8);
-    update_in_cksum(&enc_iph->ip_sum, old_hw + 1, new_hw + 1, 4);
+    if ( _calc_checksum ) {
+	update_in_cksum(&enc_iph->ip_sum, old_hw + 1, new_hw + 1, 4);
+    }
     new_hw[0] = enc_iph->ip_sum;
     nhw = 5;
 
@@ -200,7 +205,9 @@ ICMPRewriter::handle(WritablePacket *p)
 		enc_csum = &(reinterpret_cast<click_udp *>(enc_transp)->uh_sum);
 	    if (enc_csum) {
 		old_hw[nhw] = *enc_csum;
-		update_in_cksum(enc_csum, old_hw + 1, new_hw + 1, nhw - 1);
+		if ( _calc_checksum ) {
+			update_in_cksum(enc_csum, old_hw + 1, new_hw + 1, nhw - 1);
+		}
 		new_hw[nhw] = *enc_csum;
 		nhw++;
 	    }
@@ -211,15 +218,19 @@ ICMPRewriter::handle(WritablePacket *p)
 	    enc_icmph->icmp_identifier = new_hw[nhw] = new_flowid.dport();
 	    nhw++;
 	    old_hw[nhw] = enc_icmph->icmp_cksum;
-	    click_update_in_cksum(&enc_icmph->icmp_cksum, old_hw[nhw-1], new_hw[nhw-1]);
-	    click_update_zero_in_cksum(&enc_icmph->icmp_cksum, enc_transp, p->end_data() - enc_transp);
+	    if ( _calc_checksum ) {
+		click_update_in_cksum(&enc_icmph->icmp_cksum, old_hw[nhw-1], new_hw[nhw-1]);
+		click_update_zero_in_cksum(&enc_icmph->icmp_cksum, enc_transp, p->end_data() - enc_transp);
+	    }
 	    new_hw[nhw] = enc_icmph->icmp_cksum;
 	    nhw++;
 	}
     }
 
     // patch outer ICMP checksum
-    update_in_cksum(&icmph->icmp_cksum, old_hw, new_hw, nhw);
+    if ( _calc_checksum ) {
+	update_in_cksum(&icmph->icmp_cksum, old_hw, new_hw, nhw);
+    }
 
     if (_maps[mapid]._port_offset >= 0)
 	return _maps[mapid]._port_offset + entry->output();
diff --git elements/icmp/icmprewriter.hh elements/icmp/icmprewriter.hh
index 4ae7236..598ef64 100644
--- elements/icmp/icmprewriter.hh
+++ elements/icmp/icmprewriter.hh
@@ -86,6 +86,9 @@ class ICMPRewriter : public Element { public:
     Vector<MapEntry> _maps;
     unsigned _annos;
 
+    // Hyper-NF: Make the Checksum calculation optional
+    bool _calc_checksum;
+
     void rewrite_packet(WritablePacket *, click_ip *, click_udp *,
 			const IPFlowID &, IPRewriterEntry *);
     void rewrite_ping_packet(WritablePacket *, click_ip *, click_icmp_echo *,
diff --git elements/ip/decipttl.cc elements/ip/decipttl.cc
index cdc8dca..86e1a78 100644
--- elements/ip/decipttl.cc
+++ elements/ip/decipttl.cc
@@ -24,7 +24,7 @@
 CLICK_DECLS
 
 DecIPTTL::DecIPTTL()
-    : _active(true), _multicast(true)
+    : _active(true), _multicast(true), _calc_checksum(true)
 {
     _drops = 0;
 }
@@ -37,8 +37,9 @@ int
 DecIPTTL::configure(Vector<String> &conf, ErrorHandler *errh)
 {
     return Args(conf, this, errh)
-	.read("ACTIVE", _active)
-	.read("MULTICAST", _multicast).complete();
+	.read("ACTIVE",        _active)
+	.read("CALC_CHECKSUM", _calc_checksum)
+	.read("MULTICAST",     _multicast).complete();
 }
 
 Packet *
@@ -51,6 +52,7 @@ DecIPTTL::simple_action(Packet *p)
     if (!_multicast && IPAddress(ip_in->ip_dst).is_multicast())
 	return p;
 
+    // Time to drop
     if (ip_in->ip_ttl <= 1) {
 	++_drops;
 	checked_output_push(1, p);
@@ -60,7 +62,13 @@ DecIPTTL::simple_action(Packet *p)
 	if (!q)
 	    return 0;
 	click_ip *ip = q->ip_header();
-	--ip->ip_ttl;
+
+	// Decrement
+	ip->ip_ttl --;
+
+	// Hyper-NF: Do not calculate IP checksum if you are requested to do so
+	if ( !_calc_checksum )
+		return q;
 
 	// 19.Aug.1999 - incrementally update IP checksum as suggested by SOSP
 	// reviewers, according to RFC1141, as updated by RFC1624.
@@ -81,6 +89,7 @@ DecIPTTL::add_handlers()
 {
     add_data_handlers("drops", Handler::OP_READ, &_drops);
     add_data_handlers("active", Handler::OP_READ | Handler::OP_WRITE | Handler::CHECKBOX, &_active);
+    add_data_handlers("calc_checksum", Handler::OP_READ | Handler::OP_WRITE | Handler::CHECKBOX, &_calc_checksum);
 }
 
 CLICK_ENDDECLS
diff --git elements/ip/decipttl.hh elements/ip/decipttl.hh
index b2ff703..7f5aa4a 100644
--- elements/ip/decipttl.hh
+++ elements/ip/decipttl.hh
@@ -62,6 +62,8 @@ class DecIPTTL : public Element { public:
     bool _active;
     bool _multicast;
 
+    // Hyper-NF: Make the Checksum calculation optional
+    bool _calc_checksum;
 };
 
 CLICK_ENDDECLS
diff --git elements/ip/ipaddrpairrewriter.cc elements/ip/ipaddrpairrewriter.cc
index 05ac76f..7b43032 100644
--- elements/ip/ipaddrpairrewriter.cc
+++ elements/ip/ipaddrpairrewriter.cc
@@ -27,7 +27,7 @@ CLICK_DECLS
 
 void
 IPAddrPairRewriter::IPAddrPairFlow::apply(WritablePacket *p, bool direction,
-					  unsigned annos)
+					  unsigned annos, bool calc_checksum)
 {
     assert(p->has_network_header());
     click_ip *iph = p->ip_header();
@@ -40,18 +40,29 @@ IPAddrPairRewriter::IPAddrPairFlow::apply(WritablePacket *p, bool direction,
 	p->set_dst_ip_anno(revflow.saddr());
     if (direction && (annos & 2))
 	p->set_anno_u8(annos >> 2, _reply_anno);
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+
+    // Hyper-NF: Allow to skip IP checksum calculation
+    if ( calc_checksum ) {
+	update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+    }
 
     // UDP/TCP header
     if (!IP_FIRSTFRAG(iph))
 	/* do nothing */;
     else if (iph->ip_p == IP_PROTO_TCP && p->transport_length() >= 18) {
 	click_tcp *tcph = p->tcp_header();
-	update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+	// Hyper-NF extension: Allow to skip TCP checksum calculation
+	if ( calc_checksum ) {
+		update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+	}
     } else if (iph->ip_p == IP_PROTO_UDP && p->transport_length() >= 8) {
 	click_udp *udph = p->udp_header();
-	if (udph->uh_sum)	// 0 checksum is no checksum
-	    update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	if (udph->uh_sum) {	// 0 checksum is no checksum
+	    // Hyper-NF extension: Allow to skip UDP checksum calculation
+	    if ( calc_checksum ) {
+	    	update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	    }
+	}
     }
 }
 
@@ -155,7 +166,7 @@ IPAddrPairRewriter::push(int port, Packet *p_in)
     }
 
     IPAddrPairFlow *mf = static_cast<IPAddrPairFlow *>(m->flow());
-    mf->apply(p, m->direction(), _annos);
+    mf->apply(p, m->direction(), _annos, _calc_checksum);
     mf->change_expiry_by_timeout(_heap, click_jiffies(), _timeouts);
     output(m->output()).push(p);
 }
diff --git elements/ip/ipaddrpairrewriter.hh elements/ip/ipaddrpairrewriter.hh
index 27921a0..3289ed7 100644
--- elements/ip/ipaddrpairrewriter.hh
+++ elements/ip/ipaddrpairrewriter.hh
@@ -125,7 +125,7 @@ class IPAddrPairRewriter : public IPRewriterBase { public:
 			     0, guaranteed, expiry_j) {
 	}
 
-	void apply(WritablePacket *p, bool direction, unsigned annos);
+	void apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum);
 
 	void unparse(StringAccum &sa, bool direction, click_jiffies_t now) const;
 
diff --git elements/ip/ipaddrrewriter.cc elements/ip/ipaddrrewriter.cc
index 868513e..773f0b9 100644
--- elements/ip/ipaddrrewriter.cc
+++ elements/ip/ipaddrrewriter.cc
@@ -27,7 +27,7 @@ CLICK_DECLS
 
 void
 IPAddrRewriter::IPAddrFlow::apply(WritablePacket *p, bool direction,
-				  unsigned annos)
+				  unsigned annos, bool calc_checksum)
 {
     assert(p->has_network_header());
     click_ip *iph = p->ip_header();
@@ -43,18 +43,29 @@ IPAddrRewriter::IPAddrFlow::apply(WritablePacket *p, bool direction,
 	if (annos & 2)
 	    p->set_anno_u8(annos >> 2, _reply_anno);
     }
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+
+    // Hyper-NF: Allow to skip IP checksum calculation
+    if ( calc_checksum ) {
+	    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+    }
 
     // UDP/TCP header
     if (!IP_FIRSTFRAG(iph))
 	/* do nothing */;
     else if (iph->ip_p == IP_PROTO_TCP && p->transport_length() >= 18) {
 	click_tcp *tcph = p->tcp_header();
-	update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+	// Hyper-NF extension: Allow to skip TCP checksum calculation
+	if ( calc_checksum ) {
+		update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+	}
     } else if (iph->ip_p == IP_PROTO_UDP && p->transport_length() >= 8) {
 	click_udp *udph = p->udp_header();
-	if (udph->uh_sum)	// 0 checksum is no checksum
-	    update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	if (udph->uh_sum) {	// 0 checksum is no checksum
+	    // Hyper-NF extension: Allow to skip UDP checksum calculation
+	    if ( calc_checksum ) {
+	    	update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	    }
+	}
     }
 }
 
@@ -166,7 +177,7 @@ IPAddrRewriter::push(int port, Packet *p_in)
     }
 
     IPAddrFlow *mf = static_cast<IPAddrFlow *>(m->flow());
-    mf->apply(p, m->direction(), _annos);
+    mf->apply(p, m->direction(), _annos, _calc_checksum);
     mf->change_expiry_by_timeout(_heap, click_jiffies(), _timeouts);
     output(m->output()).push(p);
 }
diff --git elements/ip/ipaddrrewriter.hh elements/ip/ipaddrrewriter.hh
index edf6357..fe331c7 100644
--- elements/ip/ipaddrrewriter.hh
+++ elements/ip/ipaddrrewriter.hh
@@ -124,7 +124,7 @@ class IPAddrRewriter : public IPRewriterBase { public:
 			     0, guaranteed, expiry_j) {
 	}
 
-	void apply(WritablePacket *p, bool direction, unsigned annos);
+	void apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum);
 
 	void unparse(StringAccum &sa, bool direction, click_jiffies_t now) const;
 
diff --git elements/ip/iprewriterbase.cc elements/ip/iprewriterbase.cc
index 50e3f34..f002f82 100644
--- elements/ip/iprewriterbase.cc
+++ elements/ip/iprewriterbase.cc
@@ -65,10 +65,11 @@ IPMapper::rewrite_flowid(IPRewriterInput *, const IPFlowID &, IPFlowID &,
 
 //
 // IPRewriterBase
+// Hyper-NF extension: Set the checksum calculation parameter to true by default
 //
 
 IPRewriterBase::IPRewriterBase()
-    : _map(0), _heap(new IPRewriterHeap), _gc_timer(gc_timer_hook, this)
+    : _map(0), _heap(new IPRewriterHeap), _gc_timer(gc_timer_hook, this), _calc_checksum(true), _dec_ip_ttl(false)
 {
     _timeouts[0] = default_timeout;
     _timeouts[1] = default_guarantee;
@@ -158,6 +159,9 @@ IPRewriterBase::configure(Vector<String> &conf, ErrorHandler *errh)
 	.read("GUARANTEE", SecondsArg(), _timeouts[1])
 	.read("REAP_INTERVAL", SecondsArg(), _gc_interval_sec)
 	.read("REAP_TIME", Args::deprecated, SecondsArg(), _gc_interval_sec)
+	// Hyper-NF extra arguments
+	.read("CALC_CHECKSUM", _calc_checksum)
+	.read("DEC_IP_TTL", _dec_ip_ttl)
 	.consume() < 0)
 	return -1;
 
diff --git elements/ip/iprewriterbase.hh elements/ip/iprewriterbase.hh
index b7ced3a..3d68abb 100644
--- elements/ip/iprewriterbase.hh
+++ elements/ip/iprewriterbase.hh
@@ -140,6 +140,13 @@ class IPRewriterBase : public Element { public:
     uint32_t _gc_interval_sec;
     Timer _gc_timer;
 
+    // Hyper-NF extension: Read one extra input argument to allow
+    // skipping IP/TCP/UDP checksum calculation
+    bool _calc_checksum;
+
+    // Hyper-NF extension: IP Rewriter can possibly decrement IP TTL field
+    bool _dec_ip_ttl;
+
     enum {
 	default_timeout = 300,	   // 5 minutes
 	default_guarantee = 5,	   // 5 seconds
diff --git elements/ip/iprwmapping.cc elements/ip/iprwmapping.cc
index 966382c..03c755e 100644
--- elements/ip/iprwmapping.cc
+++ elements/ip/iprwmapping.cc
@@ -19,6 +19,8 @@
  * legally binding.
  */
 
+#include <stdio.h>
+
 #include <click/config.h>
 #include "iprwmapping.hh"
 #include "iprewriterbase.hh"
@@ -40,6 +42,9 @@ IPRewriterFlow::IPRewriterFlow(IPRewriterInput *owner, const IPFlowID &flowid,
       _guaranteed(guaranteed), _reply_anno(0),
       _owner(owner)
 {
+    //printf("Forward Port: %d\n", owner->foutput);
+    //printf("Reverse Port: %d\n", owner->routput);
+
     _e[0].initialize(flowid, owner->foutput, false);
     _e[1].initialize(rewritten_flowid.reverse(), owner->routput, true);
 
@@ -55,7 +60,7 @@ IPRewriterFlow::IPRewriterFlow(IPRewriterInput *owner, const IPFlowID &flowid,
 }
 
 void
-IPRewriterFlow::apply(WritablePacket *p, bool direction, unsigned annos)
+IPRewriterFlow::apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum)
 {
     assert(p->has_network_header());
     click_ip *iph = p->ip_header();
@@ -68,7 +73,11 @@ IPRewriterFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 	p->set_dst_ip_anno(revflow.saddr());
     if (direction && (annos & 2))
 	p->set_anno_u8(annos >> 2, _reply_anno);
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+
+    // Hyper-NF: Allow to skip IP checksum calculation
+    if ( calc_checksum ) {
+	update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+    }
 
     // end if not first fragment
     if (!IP_FIRSTFRAG(iph))
@@ -79,13 +88,21 @@ IPRewriterFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 	click_tcp *tcph = p->tcp_header();
 	tcph->th_sport = revflow.dport();
 	tcph->th_dport = revflow.sport();
-	update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+
+	// Hyper-NF extension: Allow to skip TCP checksum calculation
+	if ( calc_checksum ) {
+		update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+	}
     } else if (iph->ip_p == IP_PROTO_UDP) {
 	click_udp *udph = p->udp_header();
 	udph->uh_sport = revflow.dport();
 	udph->uh_dport = revflow.sport();
-	if (udph->uh_sum)	// 0 checksum is no checksum
-	    update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	if (udph->uh_sum) {	// 0 checksum is no checksum
+	    // Hyper-NF extension: Allow to skip UDP checksum calculation
+	    if ( calc_checksum ) {
+	    	update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	    }
+	}
     }
 }
 
diff --git elements/ip/iprwmapping.hh elements/ip/iprwmapping.hh
index 446f95b..5ee3860 100644
--- elements/ip/iprwmapping.hh
+++ elements/ip/iprwmapping.hh
@@ -135,7 +135,7 @@ class IPRewriterFlow { public:
     static inline void update_csum(uint16_t *csum, bool direction,
 				   uint16_t csum_delta);
 
-    void apply(WritablePacket *p, bool direction, unsigned annos);
+    void apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum);
 
     void unparse(StringAccum &sa, bool direction, click_jiffies_t now) const;
     void unparse_ports(StringAccum &sa, bool direction, click_jiffies_t now) const;
diff --git elements/standard/paint.cc elements/standard/paint.cc
index 1c1545e..5a50701 100644
--- elements/standard/paint.cc
+++ elements/standard/paint.cc
@@ -16,6 +16,8 @@
  * legally binding.
  */
 
+#include <stdio.h>
+
 #include <click/config.h>
 #include "paint.hh"
 #include <click/args.hh>
@@ -43,6 +45,8 @@ Paint::configure(Vector<String> &conf, ErrorHandler *errh)
 Packet *
 Paint::simple_action(Packet *p)
 {
+    //printf("Annotation position: %d\n", _anno);
+    //printf("Annotation    color: %d\n", _color);
     p->set_anno_u8(_anno, _color);
     return p;
 }
diff --git elements/tcpudp/iprewriter.cc elements/tcpudp/iprewriter.cc
index 0bc909b..74f9698 100644
--- elements/tcpudp/iprewriter.cc
+++ elements/tcpudp/iprewriter.cc
@@ -16,6 +16,8 @@
  * legally binding.
  */
 
+#include <stdio.h>
+
 #include <click/config.h>
 #include "iprewriter.hh"
 #include <clicknet/ip.h>
@@ -28,6 +30,10 @@
 #include <click/router.hh>
 CLICK_DECLS
 
+// Hyper-NF: A statically-specified byte position in the packet annotation area
+//           used by Hyper-NF to encode the path of a flow across several NATs
+#define HYPER_NF_LABEL_POS 47
+
 IPRewriter::IPRewriter()
     : _udp_map(0)
 {
@@ -85,14 +91,15 @@ IPRewriter::get_entry(int ip_p, const IPFlowID &flowid, int input)
 	IPRewriterInput &is = _input_specs[input];
 	IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
 	if (is.rewrite_flowid(flowid, rewritten_flowid, 0, IPRewriterInput::mapid_iprewriter_udp) == rw_addmap)
-	    m = IPRewriter::add_flow(0, flowid, rewritten_flowid, input);
+	    m = IPRewriter::add_flow(0, flowid, rewritten_flowid, input, -1);
     }
+
     return m;
 }
 
 IPRewriterEntry *
 IPRewriter::add_flow(int ip_p, const IPFlowID &flowid,
-		     const IPFlowID &rewritten_flowid, int input)
+		     const IPFlowID &rewritten_flowid, int input, int hyper_nf_label)
 {
     if (ip_p == IP_PROTO_TCP)
 	return TCPRewriter::add_flow(ip_p, flowid, rewritten_flowid, input);
@@ -101,7 +108,18 @@ IPRewriter::add_flow(int ip_p, const IPFlowID &flowid,
     if (!(data = _udp_allocator.allocate()))
 	return 0;
 
+    // Hyper-NF: If your packet has been arrived annotated, hyper_nf_label is zero or positive.
+    // This means that the reverse output to be installed in the map table must get the value of
+    // hyper_nf_label.
     IPRewriterInput *rwinput = &_input_specs[input];
+
+    // We have something to give you!!! A different reverse port
+    if ( hyper_nf_label != -1 ) {
+	printf("---->  ROUTPUT before: %d\n", rwinput->routput);
+	rwinput->routput = hyper_nf_label;
+	printf("---->  ROUTPUT  after: %d\n", rwinput->routput);
+    }
+
     IPRewriterFlow *flow = new(data) IPRewriterFlow
 	(rwinput, flowid, rewritten_flowid, ip_p,
 	 !!_udp_timeouts[1], click_jiffies() + relevant_timeout(_udp_timeouts));
@@ -127,41 +145,96 @@ IPRewriter::push(int port, Packet *p_in)
 	return;
     }
 
+    // Hyper-NF: Decrement IP TTL!
+    // Do it here, before jumping to either UDP or TCP
+    if ( _dec_ip_ttl ) {
+	// Safe decrement
+	if ( iph->ip_ttl > 1 ) {
+		iph->ip_ttl --;
+		// Checksum is not mandatory anymore
+		if ( _calc_checksum ) {
+			unsigned long sum = (~ntohs(iph->ip_sum) & 0xFFFF) + 0xFEFF;
+			iph->ip_sum = ~htons(sum + (sum >> 16));
+		}
+	}
+	// End flow if TTL is 0
+	else {
+		return;
+	}
+    }
+
+    // Hyper-NF: Read a specific position in the annotation area
+    // If set, this position tells you how to route the packet on
+    // the reverse outport specified by the value (the NAT's table
+    // routput must be set accordingly in method IPRewriter::add_flow)
+    // If not set, it must have a value 255 in order to use the standard
+    // port allocation of this element
+    uint8_t hyper_nf_label = p->anno_u8(HYPER_NF_LABEL_POS);
+    // There is no annotation, behave normally
+    if ( hyper_nf_label == 255 ) {
+	hyper_nf_label = -1;
+    }
+    else {
+	//printf("\n----> Routing annotation: %d\n", hyper_nf_label);
+	// Check whether the given label is in the range of ports of this element
+	if ( this->noutputs() < (hyper_nf_label+1) ) {
+		printf("----> Invalid routing annotation: %d. Element has only %d output ports\n", hyper_nf_label, this->noutputs());
+		return;
+	}
+    }
+
     IPFlowID flowid(p);
     HashContainer<IPRewriterEntry> *map = (iph->ip_p == IP_PROTO_TCP ? &_map : &_udp_map);
     IPRewriterEntry *m = map->get(flowid);
 
+    // This is a fresh flow, store the annotation
     if (!m) {			// create new mapping
+	//printf("----> NEW FLOW \n");
 	IPRewriterInput &is = _input_specs.unchecked_at(port);
 	IPFlowID rewritten_flowid = IPFlowID::uninitialized_t();
+
 	int result = is.rewrite_flowid(flowid, rewritten_flowid, p, iph->ip_p == IP_PROTO_TCP ? 0 : IPRewriterInput::mapid_iprewriter_udp);
-	if (result == rw_addmap)
-	    m = IPRewriter::add_flow(iph->ip_p, flowid, rewritten_flowid, port);
+	if (result == rw_addmap) {
+	    m = IPRewriter::add_flow(iph->ip_p, flowid, rewritten_flowid, port, hyper_nf_label);
+	    printf("---->        IP Proto: %d\n", iph->ip_p);
+	    printf("---->        Src   IP: %s\n", m->flowid().saddr().s().c_str());
+	    printf("---->        Src Port: %d\n", htons(m->flowid().sport()));
+	    printf("---->        Dst   IP: %s\n", m->flowid().daddr().s().c_str());
+	    printf("---->        Dst Port: %d\n", htons(m->flowid().dport()));
+	    printf("---->       Direction: %s\n", m->direction()? "Response":"Forward");
+	    printf("----> Forward Outport: %d\n", m->output());
+	    printf("----> Reverse Outport: %d\n", hyper_nf_label);
+	}
 	if (!m) {
 	    checked_output_push(result, p);
 	    return;
-	} else if (_annos & 2)
+	} else if (_annos & 2) {
 	    m->flow()->set_reply_anno(p->anno_u8(_annos >> 2));
+	}
     }
 
+    // Flow exists for sure now, go to transport header
     click_jiffies_t now_j = click_jiffies();
     IPRewriterFlow *mf = m->flow();
     if (iph->ip_p == IP_PROTO_TCP) {
 	TCPFlow *tcpmf = static_cast<TCPFlow *>(mf);
-	tcpmf->apply(p, m->direction(), _annos);
+	tcpmf->apply(p, m->direction(), _annos, _calc_checksum);
 	if (_timeouts[1])
 	    tcpmf->change_expiry(_heap, true, now_j + _timeouts[1]);
 	else
 	    tcpmf->change_expiry(_heap, false, now_j + tcp_flow_timeout(tcpmf));
     } else {
 	UDPFlow *udpmf = static_cast<UDPFlow *>(mf);
-	udpmf->apply(p, m->direction(), _annos);
+	udpmf->apply(p, m->direction(), _annos, _calc_checksum);
 	if (_udp_timeouts[1])
 	    udpmf->change_expiry(_heap, true, now_j + _udp_timeouts[1]);
 	else
 	    udpmf->change_expiry(_heap, false, now_j + udp_flow_timeout(udpmf));
     }
 
+    // Hyper-NF: Check the output port before the final push
+    printf("----> Output Port: %d\n", m->output());
+
     output(m->output()).push(p);
 }
 
diff --git elements/tcpudp/iprewriter.hh elements/tcpudp/iprewriter.hh
index 50fb742..c9f2e95 100644
--- elements/tcpudp/iprewriter.hh
+++ elements/tcpudp/iprewriter.hh
@@ -237,8 +237,11 @@ class IPRewriter : public TCPRewriter { public:
 	else
 	    return 0;
     }
+
+    // Hyper-NF: Interface for add flow changed to accommodate label-based lookup in the map table
     IPRewriterEntry *add_flow(int ip_p, const IPFlowID &flowid,
-			      const IPFlowID &rewritten_flowid, int input);
+			      const IPFlowID &rewritten_flowid, int input, int hyper_nf_label);
+
     void destroy_flow(IPRewriterFlow *flow);
     click_jiffies_t best_effort_expiry(const IPRewriterFlow *flow) {
 	if (flow->ip_p() == IP_PROTO_TCP)
diff --git elements/tcpudp/tcprewriter.cc elements/tcpudp/tcprewriter.cc
index 6e10003..242a384 100644
--- elements/tcpudp/tcprewriter.cc
+++ elements/tcpudp/tcprewriter.cc
@@ -84,7 +84,7 @@ TCPRewriter::TCPFlow::update_seqno_delta(bool direction,
 }
 
 void
-TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len)
+TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len, bool calc_checksum)
 {
     if ((int)(tcph->th_off << 2) < len)
 	len = tcph->th_off << 2;
@@ -106,10 +106,14 @@ TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len)
 	      } else {
 		  uint8_t *end_sack = opt + opt[1];
 
-		  // develop initial checksum value
-		  uint16_t *csum_begin = reinterpret_cast<uint16_t *>(begin_opt + ((opt + 2 - begin_opt) & ~1));
-		  for (uint16_t *csum = csum_begin; reinterpret_cast<uint8_t *>(csum) < end_sack; csum++)
-		      csum_delta += ~*csum & 0xFFFF;
+		  // Hyper-NF extension: Allow to skip TCP checksum calculation
+		  uint16_t *csum_begin= 0;
+		  if ( calc_checksum ) {
+		  	// develop initial checksum value
+		  	csum_begin = reinterpret_cast<uint16_t *>(begin_opt + ((opt + 2 - begin_opt) & ~1));
+		  	for (uint16_t *csum = csum_begin; reinterpret_cast<uint8_t *>(csum) < end_sack; csum++)
+		  	    csum_delta += ~*csum & 0xFFFF;
+		  }
 
 		  for (opt += 2; opt < end_sack; opt += 8) {
 #if HAVE_INDIFFERENT_ALIGNMENT
@@ -125,10 +129,13 @@ TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len)
 #endif
 		  }
 
-		  // finish off csum_delta calculation
-		  for (uint16_t *csum = csum_begin; reinterpret_cast<uint8_t *>(csum) < end_sack; csum++)
-		      csum_delta += *csum;
-		  break;
+		  // Hyper-NF extension: Allow to skip TCP checksum calculation
+		  if ( calc_checksum ) {
+			  // finish off csum_delta calculation
+			  for (uint16_t *csum = csum_begin; reinterpret_cast<uint8_t *>(csum) < end_sack; csum++)
+			      csum_delta += *csum;
+			  break;
+		  }
 	      }
 	  default:
 	    if (opt[1] < 2)
@@ -138,7 +145,8 @@ TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len)
 	}
 
   done:
-    if (csum_delta) {
+    // Hyper-NF extension: Allow to skip TCP checksum calculation
+    if (csum_delta && !calc_checksum) {
 	uint32_t sum = (~tcph->th_sum & 0xFFFF) + csum_delta;
 	sum = (sum & 0xFFFF) + (sum >> 16);
 	tcph->th_sum = ~(sum + (sum >> 16));
@@ -146,7 +154,7 @@ TCPRewriter::TCPFlow::apply_sack(bool direction, click_tcp *tcph, int len)
 }
 
 void
-TCPRewriter::TCPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
+TCPRewriter::TCPFlow::apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum)
 {
     assert(p->has_network_header());
     click_ip *iph = p->ip_header();
@@ -159,7 +167,11 @@ TCPRewriter::TCPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 	p->set_dst_ip_anno(revflow.saddr());
     if (direction && (annos & 2))
 	p->set_anno_u8(annos >> 2, _reply_anno);
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+
+    // Hyper-NF extension: Allow to skip IP checksum calculation
+    if ( calc_checksum ) {
+	update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+    }
 
     // end if not first fragment
     if (!IP_FIRSTFRAG(iph) || p->transport_length() < 18)
@@ -169,7 +181,11 @@ TCPRewriter::TCPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
     click_tcp *tcph = p->tcp_header();
     tcph->th_sport = revflow.dport();
     tcph->th_dport = revflow.sport();
-    update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+
+    // Hyper-NF extension: Allow to skip TCP checksum calculation
+    if ( calc_checksum ) {
+	update_csum(&tcph->th_sum, direction, _udp_csum_delta);
+    }
 
     // track connection state
     bool have_payload = ((iph->ip_hl + tcph->th_off) << 2) < ntohs(iph->ip_len);
@@ -203,22 +219,28 @@ TCPRewriter::TCPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 
     if (_dt->delta[direction] || _dt->has_trigger(direction)) {
 	uint32_t newval = htonl(new_seq(direction, ntohl(tcph->th_seq)));
-	click_update_in_cksum(&tcph->th_sum, tcph->th_seq >> 16, newval >> 16);
-	click_update_in_cksum(&tcph->th_sum, tcph->th_seq, newval);
+	// Hyper-NF extension: Allow to skip TCP checksum calculation
+	if ( calc_checksum ) {
+		click_update_in_cksum(&tcph->th_sum, tcph->th_seq >> 16, newval >> 16);
+		click_update_in_cksum(&tcph->th_sum, tcph->th_seq, newval);
+	}
 	tcph->th_seq = newval;
     }
 
     if (_dt->delta[!direction] || _dt->has_trigger(!direction)) {
 	uint32_t newval = htonl(new_ack(direction, ntohl(tcph->th_ack)));
-	click_update_in_cksum(&tcph->th_sum, tcph->th_ack >> 16, newval >> 16);
-	click_update_in_cksum(&tcph->th_sum, tcph->th_ack, newval);
+	// Hyper-NF extension: Allow to skip TCP checksum calculation
+	if ( calc_checksum ) {
+		click_update_in_cksum(&tcph->th_sum, tcph->th_ack >> 16, newval >> 16);
+		click_update_in_cksum(&tcph->th_sum, tcph->th_ack, newval);
+	}
 	tcph->th_ack = newval;
 
 	// update SACK sequence numbers
 	if (tcph->th_off > 8
 	    || (tcph->th_off == 8
 		&& *(reinterpret_cast<const uint32_t *>(tcph + 1)) != htonl(0x0101080A)))
-	    apply_sack(direction, tcph, p->transport_length());
+	    apply_sack(direction, tcph, p->transport_length(), calc_checksum);
     }
 }
 
@@ -331,7 +353,7 @@ TCPRewriter::push(int port, Packet *p_in)
     }
 
     TCPFlow *mf = static_cast<TCPFlow *>(m->flow());
-    mf->apply(p, m->direction(), _annos);
+    mf->apply(p, m->direction(), _annos, _calc_checksum);
 
     click_jiffies_t now_j = click_jiffies();
     if (_timeouts[1])
diff --git elements/tcpudp/tcprewriter.hh elements/tcpudp/tcprewriter.hh
index bcae3fc..2bb8a6c 100644
--- elements/tcpudp/tcprewriter.hh
+++ elements/tcpudp/tcprewriter.hh
@@ -127,7 +127,7 @@ class TCPRewriter : public IPRewriterBase { public:
 	tcp_seq_t new_seq(bool direction, tcp_seq_t seqno) const;
 	tcp_seq_t new_ack(bool direction, tcp_seq_t seqno) const;
 
-	void apply(WritablePacket *p, bool direction, unsigned annos);
+	void apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum);
 
 	void unparse(StringAccum &sa, bool direction, click_jiffies_t now) const;
 
@@ -150,7 +150,7 @@ class TCPRewriter : public IPRewriterBase { public:
 
 	delta_transition *_dt;
 
-	void apply_sack(bool direction, click_tcp *tcp, int transport_len);
+	void apply_sack(bool direction, click_tcp *tcp, int transport_len, bool calc_checksum);
 
     };
 
diff --git elements/tcpudp/udprewriter.cc elements/tcpudp/udprewriter.cc
index b3d0f62..5033e07 100644
--- elements/tcpudp/udprewriter.cc
+++ elements/tcpudp/udprewriter.cc
@@ -27,7 +27,7 @@
 CLICK_DECLS
 
 void
-UDPRewriter::UDPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
+UDPRewriter::UDPFlow::apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum)
 {
     assert(p->has_network_header());
     click_ip *iph = p->ip_header();
@@ -40,7 +40,11 @@ UDPRewriter::UDPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
 	p->set_dst_ip_anno(revflow.saddr());
     if (direction && (annos & 2))
 	p->set_anno_u8(annos >> 2, _reply_anno);
-    update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+
+    // Hyper-NF: Allow to skip IP checksum calculation
+    if ( calc_checksum ) {
+    	update_csum(&iph->ip_sum, direction, _ip_csum_delta);
+    }
 
     // end if not first fragment
     if (!IP_FIRSTFRAG(iph))
@@ -51,12 +55,20 @@ UDPRewriter::UDPFlow::apply(WritablePacket *p, bool direction, unsigned annos)
     udph->uh_sport = revflow.dport(); // TCP ports in the same place
     udph->uh_dport = revflow.sport();
     if (iph->ip_p == IP_PROTO_TCP) {
-	if (p->transport_length() >= 18)
-	    update_csum(&reinterpret_cast<click_tcp *>(udph)->th_sum, direction, _udp_csum_delta);
+	if (p->transport_length() >= 18) {
+	    // Hyper-NF: Allow to skip UDP checksum calculation
+	    if ( calc_checksum ) {
+	    	update_csum(&reinterpret_cast<click_tcp *>(udph)->th_sum, direction, _udp_csum_delta);
+	    }
+	}
     } else if (iph->ip_p == IP_PROTO_UDP) {
-	if (p->transport_length() >= 8 && udph->uh_sum)
-	    // 0 checksum is no checksum
-	    update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	if (p->transport_length() >= 8 && udph->uh_sum) {
+	    // Hyper-NF: Allow to skip UDP checksum calculation
+	    if ( calc_checksum ) {
+	    	// 0 checksum is no checksum
+	    	update_csum(&udph->uh_sum, direction, _udp_csum_delta);
+	    }
+	}
     }
 
     // track connection state
@@ -165,7 +177,7 @@ UDPRewriter::push(int port, Packet *p_in)
     }
 
     UDPFlow *mf = static_cast<UDPFlow *>(m->flow());
-    mf->apply(p, m->direction(), _annos);
+    mf->apply(p, m->direction(), _annos, _calc_checksum);
 
     click_jiffies_t now_j = click_jiffies();
     if (_timeouts[1])
diff --git elements/tcpudp/udprewriter.hh elements/tcpudp/udprewriter.hh
index 4246624..6cd0caa 100644
--- elements/tcpudp/udprewriter.hh
+++ elements/tcpudp/udprewriter.hh
@@ -175,7 +175,7 @@ class UDPRewriter : public IPRewriterBase { public:
 	    return _tflags > 6;
 	}
 
-	void apply(WritablePacket *p, bool direction, unsigned annos);
+	void apply(WritablePacket *p, bool direction, unsigned annos, bool calc_checksum);
 
     };
 
diff --git include/click/router.hh include/click/router.hh
index dc83606..87a7b68 100644
--- include/click/router.hh
+++ include/click/router.hh
@@ -129,7 +129,14 @@ class Router { public:
     inline Router* hotswap_router() const;
     void set_hotswap_router(Router* router);
 
-    int initialize(ErrorHandler* errh);
+    /*
+     * Hyper-NF Modification to prevent Click from initializing the elements in this call.
+     * We simply want to have the Click DAG populated with all the elements and connections.
+     * The 2nd argument is set to false by default. This is how normal Click calls the function
+     * so it does not affect normal Click executions.
+     */
+    int initialize(ErrorHandler* errh, bool initialize_only_dag=false);
+
     void activate(bool foreground, ErrorHandler* errh);
     inline void activate(ErrorHandler* errh);
     inline void set_foreground(bool foreground);
@@ -296,6 +303,10 @@ class Router { public:
 
     Router* _next_router;
 
+    // Hyper-NF extension: If set to true, the router's elements are not initialized
+    // Router::initialize() and ~Router() use this field to properly set and reset the router
+    bool _do_not_initialize;
+
 #if CLICK_LINUXMODULE
     Vector<struct module*> _modules;
 #endif
diff --git lib/router.cc lib/router.cc
index d345236..cd11e0d 100644
--- lib/router.cc
+++ lib/router.cc
@@ -83,7 +83,8 @@ Router::Router(const String &configuration, Master *master)
       _configuration(configuration),
       _notifier_signals(0),
       _arena_factory(new HashMap_ArenaFactory),
-      _hotswap_router(0), _thread_sched(0), _name_info(0), _next_router(0)
+      _hotswap_router(0), _thread_sched(0), _name_info(0), _next_router(0),
+      _do_not_initialize(false)
 {
     _refcount = 0;
     _runcount = 0;
@@ -117,7 +118,8 @@ Router::~Router()
 	for (int ord = _elements.size() - 1; ord >= 0; ord--)
 	    _elements[ _element_configure_order[ord] ]->cleanup(Element::CLEANUP_ROUTER_INITIALIZED);
     } else if (_state != ROUTER_DEAD) {
-	assert(_element_configure_order.size() == 0 && _state <= ROUTER_PRECONFIGURE);
+        // We do not follow all the Click states thus this assertion must be commented
+	//assert(_element_configure_order.size() == 0 && _state <= ROUTER_PRECONFIGURE);
 	for (int i = _elements.size() - 1; i >= 0; i--)
 	    _elements[i]->cleanup(Element::CLEANUP_NO_ROUTER);
     }
@@ -151,6 +153,12 @@ Router::~Router()
 	delete ns;
     }
     delete _name_info;
+
+    // Return here in case that the router has been constructed by setting this member to true.
+    // In this case we haven't registered our Router in the first place.
+    if ( _do_not_initialize )
+    	return;
+
     if (_master)
 	_master->unregister_router(this);
 }
@@ -1085,7 +1093,7 @@ Router::initialize_handlers(bool defaults, bool specifics)
 }
 
 int
-Router::initialize(ErrorHandler *errh)
+Router::initialize(ErrorHandler *errh, bool do_not_initialize)
 {
     if (_state != ROUTER_NEW)
 	return errh->error("second attempt to initialize router");
@@ -1165,6 +1173,18 @@ Router::initialize(ErrorHandler *errh)
 	}
     }
 
+    //////////////////////////////////////////////////////////////////////////////
+    /*
+     * Hyper-NF modification to prevent the initialization of Click elements
+     * It happens only when the boolean argument is true. Default is false.
+     */
+    //////////////////////////////////////////////////////////////////////////////
+    if ( do_not_initialize ) {
+	// This field is useful in the destructor
+	_do_not_initialize = true;
+	return 0;
+    }
+
 #if CLICK_DMALLOC
     CLICK_DMALLOC_REG("iHoo");
 #endif
